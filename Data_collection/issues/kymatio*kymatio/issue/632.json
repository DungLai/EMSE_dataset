{"url":"https://api.github.com/repos/kymatio/kymatio/issues/632","repository_url":"https://api.github.com/repos/kymatio/kymatio","labels_url":"https://api.github.com/repos/kymatio/kymatio/issues/632/labels{/name}","comments_url":"https://api.github.com/repos/kymatio/kymatio/issues/632/comments","events_url":"https://api.github.com/repos/kymatio/kymatio/issues/632/events","html_url":"https://github.com/kymatio/kymatio/issues/632","id":716276978,"node_id":"MDU6SXNzdWU3MTYyNzY5Nzg=","number":632,"title":"Indexing 2D (Request)","user":{"login":"jecampagne","id":20539759,"node_id":"MDQ6VXNlcjIwNTM5NzU5","avatar_url":"https://avatars.githubusercontent.com/u/20539759?v=4","gravatar_id":"","url":"https://api.github.com/users/jecampagne","html_url":"https://github.com/jecampagne","followers_url":"https://api.github.com/users/jecampagne/followers","following_url":"https://api.github.com/users/jecampagne/following{/other_user}","gists_url":"https://api.github.com/users/jecampagne/gists{/gist_id}","starred_url":"https://api.github.com/users/jecampagne/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jecampagne/subscriptions","organizations_url":"https://api.github.com/users/jecampagne/orgs","repos_url":"https://api.github.com/users/jecampagne/repos","events_url":"https://api.github.com/users/jecampagne/events{/privacy}","received_events_url":"https://api.github.com/users/jecampagne/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":9,"created_at":"2020-10-07T07:32:53Z","updated_at":"2021-03-18T09:57:56Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"Hi,\r\nWhen using for instance\r\n```\r\nJ, L= 3,4\r\nS = Scattering2D(J=J,shape=(64,64),L=L,backend='torch', max_order=2)\r\n```\r\nI have the coefficient in a array with typically such dimension  [Cin,25,16,16]. Now, if I use `out_type='list'`, then I get a list of dictionary \r\n```\r\nSlist = Scattering2D(J=J,shape=(64,64),L=L,backend='torch', max_order=2, out_type='list')\r\nLcoeff = Slist(t_img)\r\nfor i in range(len(Lcoeff)):\r\n    print(i,Lcoeff[i]['j'],Lcoeff[i]['theta'],Lcoeff[i]['coef'].shape)\r\n```\r\nwhich looks like\r\n```\r\n0 () () torch.Size([5, 8, 8])\r\n1 (0,) (0,) torch.Size([5, 8, 8])\r\n2 (0,) (1,) torch.Size([5, 8, 8])\r\n3 (0,) (2,) torch.Size([5, 8, 8])\r\n4 (0,) (3,) torch.Size([5, 8, 8])\r\n5 (1,) (0,) torch.Size([5, 8, 8])\r\n6 (1,) (1,) torch.Size([5, 8, 8])\r\n7 (1,) (2,) torch.Size([5, 8, 8])\r\n8 (1,) (3,) torch.Size([5, 8, 8])\r\n9 (2,) (0,) torch.Size([5, 8, 8])\r\n10 (2,) (1,) torch.Size([5, 8, 8])\r\n11 (2,) (2,) torch.Size([5, 8, 8])\r\n12 (2,) (3,) torch.Size([5, 8, 8])\r\n13 (0, 1) (0, 0) torch.Size([5, 8, 8])\r\n14 (0, 1) (0, 1) torch.Size([5, 8, 8])\r\n...\r\n```  \r\n Well, in some sense I get a link between the index i of `coeff_i` (i:0,24) and the corresponding (j,theta) or (j1,j2,theta_1,theta_2). Is there some indexing utility routines that can do it \r\n```\r\nidx -> (level, j1,theta1,j2,theta2)   \r\nwith level=0  j1=theta1=j2=theta2=default value as we do not care\r\nwith level=1 j1,theta1  and j2=theta2=default valeue\r\nwith level=2 then all js and thetas matter\r\n```\r\nand vice versa\r\n```\r\n (level, j1,theta1,j2,theta2) -> idx\r\n```\r\nThis could help to make combinaison of the coefficients....\r\nThanks\r\n\r\n","closed_by":null,"reactions":{"url":"https://api.github.com/repos/kymatio/kymatio/issues/632/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/kymatio/kymatio/issues/632/timeline","performed_via_github_app":null,"state_reason":null}