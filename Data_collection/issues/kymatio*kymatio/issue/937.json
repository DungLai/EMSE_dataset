{"url":"https://api.github.com/repos/kymatio/kymatio/issues/937","repository_url":"https://api.github.com/repos/kymatio/kymatio","labels_url":"https://api.github.com/repos/kymatio/kymatio/issues/937/labels{/name}","comments_url":"https://api.github.com/repos/kymatio/kymatio/issues/937/comments","events_url":"https://api.github.com/repos/kymatio/kymatio/issues/937/events","html_url":"https://github.com/kymatio/kymatio/issues/937","id":1341631577,"node_id":"I_kwDOCQLq_c5P96xZ","number":937,"title":"Should we keep `oversampling`?","user":{"login":"lostanlen","id":3943142,"node_id":"MDQ6VXNlcjM5NDMxNDI=","avatar_url":"https://avatars.githubusercontent.com/u/3943142?v=4","gravatar_id":"","url":"https://api.github.com/users/lostanlen","html_url":"https://github.com/lostanlen","followers_url":"https://api.github.com/users/lostanlen/followers","following_url":"https://api.github.com/users/lostanlen/following{/other_user}","gists_url":"https://api.github.com/users/lostanlen/gists{/gist_id}","starred_url":"https://api.github.com/users/lostanlen/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/lostanlen/subscriptions","organizations_url":"https://api.github.com/users/lostanlen/orgs","repos_url":"https://api.github.com/users/lostanlen/repos","events_url":"https://api.github.com/users/lostanlen/events{/privacy}","received_events_url":"https://api.github.com/users/lostanlen/received_events","type":"User","site_admin":false},"labels":[{"id":1076176418,"node_id":"MDU6TGFiZWwxMDc2MTc2NDE4","url":"https://api.github.com/repos/kymatio/kymatio/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"},{"id":1076176424,"node_id":"MDU6TGFiZWwxMDc2MTc2NDI0","url":"https://api.github.com/repos/kymatio/kymatio/labels/question","name":"question","color":"d876e3","default":true,"description":"Further information is requested"},{"id":1138929232,"node_id":"MDU6TGFiZWwxMTM4OTI5MjMy","url":"https://api.github.com/repos/kymatio/kymatio/labels/API","name":"API","color":"002fa7","default":false,"description":"Issues in user-facing code"},{"id":1163515456,"node_id":"MDU6TGFiZWwxMTYzNTE1NDU2","url":"https://api.github.com/repos/kymatio/kymatio/labels/1D","name":"1D","color":"5583cc","default":false,"description":"Issue with 1D scattering code"}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2022-08-17T11:38:46Z","updated_at":"2023-01-12T15:16:52Z","closed_at":null,"author_association":"COLLABORATOR","active_lock_reason":null,"body":"## What is `oversampling` ?\r\nWe've had `oversampling` in 1D, but not 2D nor 3D, since 2018.\r\n\r\nNow that the API of `Scattering1D` is solidifying, i think we should re-discuss as to whether it's the right abstraction for the user. Here's the current docstring (which i wrote, BTW):\r\n\r\n```python\r\n    oversampling : int >=0, optional\r\n        if average_local is True, return scattering coefficients at the sample\r\n        rate max(1, 2**(log2_T-oversampling)). Hence, raising oversampling by\r\n        doubles the sample rate, until reaching the native sample rate.\r\n        if average_local is False, return first-order coefficients at the sample\r\n        rate max(1, 2**(j1-oversampling)) and second-order coefficients at the\r\n        sample rate max(1, 2**(j2-oversampling)).\r\n```\r\n\r\nQuite finicky!\r\n\r\n## `oversampling>0` complicates the interpretation of `T`\r\n\r\nIf the user sets T, the stride (ðŸŽ©  #673 ) is not `T` but `max(1, 2**(log2_T-oversampling))`.\r\n\r\nI've already raised attention about this in https://github.com/kymatio/kymatio/pull/887#issuecomment-1157257477\r\n\r\n> [... ]i'll admit i don't love the current semantics. alpha also achieves a form of oversampling when getting the j's from xi's and sigma's. It's also a bit surprising that the stride (if average) is not T \r\n\r\nT does not guarantee a low-pass width either because that also depends upon `self.sigma0`. \r\n\r\n## `oversampling>0` post-#913 triggers a bug\r\n\r\nDespite its central role, it's largely untested, except for very basic API checks i wrote recently (#887).\r\nThis had caused a bug to slip through in #913, merged 5 days ago:\r\n\r\n```python\r\nif self.average:\r\n    res = self.log2_T\r\n```\r\n\r\nThis should have read as \r\n\r\n```python\r\nif self.average:\r\n    res = max(self.log2_T - self.oversampling, 0)\r\n```\r\n\r\nand causes an unpadding error (and thus array concatenation error) in the non-default case `self.oversampling > 0`. The bug wasn't caught by unit tests because they all work under `self.oversampling=0`\r\n\r\nI'd like to hear from everyone as to what should be the appropriate response beyond this specific bugfix?\r\n\r\nThis is an important decision because it propagates through JTFS (and doubly so, because of `oversampling_fr`).\r\n\r\n\r\n## What i propose: deprecate `self.oversampling` and introduce `log2_stride`\r\n\r\nRight now, one thing we could do would be to define a property called `stride` and which will return `max(1, 2**(log2_T-oversampling))`. \r\n\r\nBut at a deeper level of discussion, i'm of the opinion that perhaps we should deprecate `oversampling` from the 1D API. I have yet to see a practical use case for it that wouldn't be covered by a careful modification of `alpha`, `T`, and `sigma0`. \r\n\r\nI've grepped for `oversampling` on `main` and find it appear over 60 times. Specifically, it appears in the computation of subsampling factors, one of the most complicated parts in the codebase:\r\n\r\n```python\r\nsub1_adj = min(j1, log2_T) if average_local else j1\r\nk1 = max(sub1_adj - oversampling, 0)\r\nsub2_adj = min(j2, log2_T) if average_local else j2\r\nk2 = max(sub2_adj - k1 - oversampling, 0)\r\nk2_log2_T = max(log2_T - k2 - k1 - oversampling, 0)\r\n```\r\n\r\n\r\nA possible API would be to replace `oversampling` by a keyword argument named `log2_stride`, which would default to `J`.\r\n`T` would only serve to control the width of the `phi` filter, and would no longer control stride.\r\nInternally, `log2_stride` would play the role of the current `log2_T`, i.e., `phi['j']`. We could do a basic rename from `log2_T` to `log2_stride`. It wouldn't require a lot of new code.\r\nThe main change is that `log2_T` is defined at `build`-time and is not directly controllable by the user, whereas `log2_stride` would be passed at `scattering` time. Setting `log2_stride` on a `Scattering1D` object such that `T=0` (i.e. `average=False`) or `T='global'` would immediately raise a `ValueError`.\r\n\r\n(Another name for `log2_stride` would be `J_phi`, although i'm worried that the `J`/ `J_phi` distinction might be too subtle and cause confusion. )\r\n\r\n`oversampling` would disappear from the codebase, improving the consistency with 2D: something @MuawizChaudhary would applaud. The change would be backwards compatible for the 99% of our users who've ignored this kwarg and stuck to the default value (`oversampling=0`). For the remaining 1%, we could write an informative `DeprecationWarning`:\r\n\r\n```python\r\nwarning.warn(\"oversampling is deprecated in v0.3 and will be removed in v0.4. \"\r\n\"Pass log2_stride = (J-oversampling) or log2_stride = (log2(T)-oversampling) \"\r\n\"to retain current behavior.\", DeprecatedWarning)\r\n```\r\nIf we do this, the only feature we'd drop would be `oversampling>0` under `average=False`. But that sounds like an extremely niche thing to want. On the other hand, it would be nice so special-case `log2_stride=0` and `T=0` to perform \"full\" oversampling. This would allow U1/U2 array concatenation, which is useful for visualization. Right now this is achieved with `T=0` and `oversampling > J`.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/kymatio/kymatio/issues/937/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/kymatio/kymatio/issues/937/timeline","performed_via_github_app":null,"state_reason":null}