{"url":"https://api.github.com/repos/sktime/sktime/issues/3889","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/3889/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/3889/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/3889/events","html_url":"https://github.com/sktime/sktime/issues/3889","id":1477202400,"node_id":"I_kwDOCVKAsc5YDFHg","number":3889,"title":"[BUG] Error when fitting `ConformalIntervals` with `AutoEnsembleForecaster`","user":{"login":"chillerobscuro","id":5232872,"node_id":"MDQ6VXNlcjUyMzI4NzI=","avatar_url":"https://avatars.githubusercontent.com/u/5232872?v=4","gravatar_id":"","url":"https://api.github.com/users/chillerobscuro","html_url":"https://github.com/chillerobscuro","followers_url":"https://api.github.com/users/chillerobscuro/followers","following_url":"https://api.github.com/users/chillerobscuro/following{/other_user}","gists_url":"https://api.github.com/users/chillerobscuro/gists{/gist_id}","starred_url":"https://api.github.com/users/chillerobscuro/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/chillerobscuro/subscriptions","organizations_url":"https://api.github.com/users/chillerobscuro/orgs","repos_url":"https://api.github.com/users/chillerobscuro/repos","events_url":"https://api.github.com/users/chillerobscuro/events{/privacy}","received_events_url":"https://api.github.com/users/chillerobscuro/received_events","type":"User","site_admin":false},"labels":[{"id":1118163262,"node_id":"MDU6TGFiZWwxMTE4MTYzMjYy","url":"https://api.github.com/repos/sktime/sktime/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":6,"created_at":"2022-12-05T18:50:47Z","updated_at":"2022-12-07T18:07:26Z","closed_at":"2022-12-07T18:07:25Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"**Describe the bug**\r\nCombining forecasters in an `AutoEnsembleForecaster` which makes good predictions. I'd like to get conformal predictions for the same ensembled model. It's returning an error related to `_split()`, and I'm treating the Ensemble as a regular forecaster and following the example in the [CI Docs](https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.conformal.ConformalIntervals.html).\r\n\r\nLooks like there is some parallelism when trying to `_compute_sliding_residuals`, which overly divides the training series. I wonder if there's a straightforward way to avoid this in Ensemble models which may have an arbitrary number of child models, but I haven't dove into the deep logic. I could imagine there are issues with aggregating in sample forecasts for ensemble models but this would be a great feature to have if possible.\r\n\r\nOn further digging, it seems to work if `len(ytrain)` > `10*len(fh)`. I suppose there might be 10x parallelism. Perhaps we could check the `len`s and reduce `n_jobs` or similar, or provide an explicit warning if there are unavoidable length requirements.\r\n\r\n**To Reproduce**\r\n\r\n```python\r\nfrom sktime.forecasting.conformal import ConformalIntervals\r\nfrom sktime.forecasting.compose import AutoEnsembleForecaster\r\nfrom sktime.forecasting.exp_smoothing import ExponentialSmoothing\r\nfrom sktime.forecasting.arima import ARIMA\r\nfrom sktime.forecasting.model_selection import temporal_train_test_split\r\nfrom sktime.datasets import load_airline\r\nfrom sktime.forecasting.base import ForecastingHorizon\r\n\r\ny = load_airline()\r\nytrain, ytest = temporal_train_test_split(y, test_size=24)\r\nprint(len(ytrain), len(ytest))\r\n\r\nfh = ForecastingHorizon(ytest.index, is_relative=False)\r\n\r\nes = ExponentialSmoothing(sp=12)\r\nar = ARIMA()\r\n\r\nforecasters = [\r\n    (\"AR\", ar),\r\n    (\"ES\", es)\r\n]\r\n\r\nae = AutoEnsembleForecaster(forecasters=forecasters, test_size=24, method='inverse-variance')\r\n\r\nconformal_forecaster = ConformalIntervals(ae)\r\nconformal_forecaster.fit(ytrain, fh=fh)\r\n```\r\nOutput:\r\n```\r\n120 24\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\nInput In [1], in <cell line: 26>()\r\n     23 ae = AutoEnsembleForecaster(forecasters=forecasters, test_size=24, method='inverse-variance')\r\n     25 conformal_forecaster = ConformalIntervals(ae)\r\n---> 26 conformal_forecaster.fit(ytrain, fh=fh)\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/sktime/forecasting/base/_base.py:303, in BaseForecaster.fit(self, y, X, fh)\r\n    301 # we call the ordinary _fit if no looping/vectorization needed\r\n    302 if not vectorization_needed:\r\n--> 303     self._fit(y=y_inner, X=X_inner, fh=fh)\r\n    304 else:\r\n    305     # otherwise we call the vectorized version of fit\r\n    306     self._vectorize(\"fit\", y=y_inner, X=X_inner, fh=fh)\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/sktime/forecasting/conformal.py:150, in ConformalIntervals._fit(self, y, X, fh)\r\n    147 self.forecaster_.fit(y=y, X=X, fh=fh)\r\n    149 if self.fh_early_:\r\n--> 150     self.residuals_matrix_ = self._compute_sliding_residuals(\r\n    151         y=y,\r\n    152         X=X,\r\n    153         forecaster=self.forecaster,\r\n    154         initial_window=self.initial_window,\r\n    155         sample_frac=self.sample_frac,\r\n    156     )\r\n    158 return self\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/sktime/forecasting/conformal.py:411, in ConformalIntervals._compute_sliding_residuals(self, y, X, forecaster, initial_window, sample_frac, update)\r\n    405         warn(\r\n    406             f\"Couldn't predict after fitting on time series of length \\\r\n    407                          {len(y_train)}.\\n\"\r\n    408         )\r\n    409     return residuals\r\n--> 411 all_residuals = Parallel(n_jobs=self.n_jobs)(\r\n    412     delayed(_get_residuals_matrix_row)(forecaster.clone(), y, X, id)\r\n    413     for id in y_index\r\n    414 )\r\n    415 for idx, id in enumerate(y_index):\r\n    416     residuals_matrix.loc[id] = all_residuals[idx]\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/joblib/parallel.py:1043, in Parallel.__call__(self, iterable)\r\n   1034 try:\r\n   1035     # Only set self._iterating to True if at least a batch\r\n   1036     # was dispatched. In particular this covers the edge\r\n   (...)\r\n   1040     # was very quick and its callback already dispatched all the\r\n   1041     # remaining jobs.\r\n   1042     self._iterating = False\r\n-> 1043     if self.dispatch_one_batch(iterator):\r\n   1044         self._iterating = self._original_iterator is not None\r\n   1046     while self.dispatch_one_batch(iterator):\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/joblib/parallel.py:861, in Parallel.dispatch_one_batch(self, iterator)\r\n    859     return False\r\n    860 else:\r\n--> 861     self._dispatch(tasks)\r\n    862     return True\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/joblib/parallel.py:779, in Parallel._dispatch(self, batch)\r\n    777 with self._lock:\r\n    778     job_idx = len(self._jobs)\r\n--> 779     job = self._backend.apply_async(batch, callback=cb)\r\n    780     # A job can complete so quickly than its callback is\r\n    781     # called before we get here, causing self._jobs to\r\n    782     # grow. To ensure correct results ordering, .insert is\r\n    783     # used (rather than .append) in the following line\r\n    784     self._jobs.insert(job_idx, job)\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/joblib/_parallel_backends.py:208, in SequentialBackend.apply_async(self, func, callback)\r\n    206 def apply_async(self, func, callback=None):\r\n    207     \"\"\"Schedule a func to be run\"\"\"\r\n--> 208     result = ImmediateResult(func)\r\n    209     if callback:\r\n    210         callback(result)\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/joblib/_parallel_backends.py:572, in ImmediateResult.__init__(self, batch)\r\n    569 def __init__(self, batch):\r\n    570     # Don't delay the application, to avoid keeping the input\r\n    571     # arguments in memory\r\n--> 572     self.results = batch()\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/joblib/parallel.py:262, in BatchedCalls.__call__(self)\r\n    258 def __call__(self):\r\n    259     # Set the default nested backend to self._backend but do not set the\r\n    260     # change the default number of processes to -1\r\n    261     with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n--> 262         return [func(*args, **kwargs)\r\n    263                 for func, args, kwargs in self.items]\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/joblib/parallel.py:262, in <listcomp>(.0)\r\n    258 def __call__(self):\r\n    259     # Set the default nested backend to self._backend but do not set the\r\n    260     # change the default number of processes to -1\r\n    261     with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n--> 262         return [func(*args, **kwargs)\r\n    263                 for func, args, kwargs in self.items]\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/sktime/forecasting/conformal.py:400, in ConformalIntervals._compute_sliding_residuals.<locals>._get_residuals_matrix_row(forecaster, y, X, id)\r\n    398 X_train = get_slice(X, start=None, end=id)\r\n    399 X_test = get_slice(X, start=id, end=None)\r\n--> 400 forecaster.fit(y_train, X=X_train, fh=y_test.index)\r\n    402 try:\r\n    403     residuals = forecaster.predict_residuals(y_test, X_test)\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/sktime/forecasting/base/_base.py:303, in BaseForecaster.fit(self, y, X, fh)\r\n    301 # we call the ordinary _fit if no looping/vectorization needed\r\n    302 if not vectorization_needed:\r\n--> 303     self._fit(y=y_inner, X=X_inner, fh=fh)\r\n    304 else:\r\n    305     # otherwise we call the vectorized version of fit\r\n    306     self._vectorize(\"fit\", y=y_inner, X=X_inner, fh=fh)\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/sktime/forecasting/compose/_ensemble.py:157, in AutoEnsembleForecaster._fit(self, y, X, fh)\r\n    153     y_train, y_test, X_train, X_test = temporal_train_test_split(\r\n    154         y, X, test_size=self.test_size\r\n    155     )\r\n    156 else:\r\n--> 157     y_train, y_test = temporal_train_test_split(y, test_size=self.test_size)\r\n    158     X_train, X_test = None, None\r\n    160 # fit ensemble models\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/sktime/forecasting/model_selection/_split.py:1445, in temporal_train_test_split(y, X, test_size, train_size, fh)\r\n   1443 else:\r\n   1444     series = (y,) if X is None else (y, X)\r\n-> 1445     return _train_test_split(\r\n   1446         *series,\r\n   1447         shuffle=False,\r\n   1448         stratify=None,\r\n   1449         test_size=test_size,\r\n   1450         train_size=train_size,\r\n   1451     )\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/sklearn/model_selection/_split.py:2448, in train_test_split(test_size, train_size, random_state, shuffle, stratify, *arrays)\r\n   2445 arrays = indexable(*arrays)\r\n   2447 n_samples = _num_samples(arrays[0])\r\n-> 2448 n_train, n_test = _validate_shuffle_split(\r\n   2449     n_samples, test_size, train_size, default_test_size=0.25\r\n   2450 )\r\n   2452 if shuffle is False:\r\n   2453     if stratify is not None:\r\n\r\nFile ~/Code/ts/notebooks/tsdl/lib/python3.9/site-packages/sklearn/model_selection/_split.py:2071, in _validate_shuffle_split(n_samples, test_size, train_size, default_test_size)\r\n   2063 train_size_type = np.asarray(train_size).dtype.kind\r\n   2065 if (\r\n   2066     test_size_type == \"i\"\r\n   2067     and (test_size >= n_samples or test_size <= 0)\r\n   2068     or test_size_type == \"f\"\r\n   2069     and (test_size <= 0 or test_size >= 1)\r\n   2070 ):\r\n-> 2071     raise ValueError(\r\n   2072         \"test_size={0} should be either positive and smaller\"\r\n   2073         \" than the number of samples {1} or a float in the \"\r\n   2074         \"(0, 1) range\".format(test_size, n_samples)\r\n   2075     )\r\n   2077 if (\r\n   2078     train_size_type == \"i\"\r\n   2079     and (train_size >= n_samples or train_size <= 0)\r\n   2080     or train_size_type == \"f\"\r\n   2081     and (train_size <= 0 or train_size >= 1)\r\n   2082 ):\r\n   2083     raise ValueError(\r\n   2084         \"train_size={0} should be either positive and smaller\"\r\n   2085         \" than the number of samples {1} or a float in the \"\r\n   2086         \"(0, 1) range\".format(train_size, n_samples)\r\n   2087     )\r\n\r\nValueError: test_size=24 should be either positive and smaller than the number of samples 12 or a float in the (0, 1) range\r\n```\r\n\r\n**Versions**\r\n<details>\r\n\r\n<!--\r\nPlease run the following code snippet and paste the output here:\r\n-->\r\nversion: 0.14.0\r\n</details>\r\n\r\n\r\n","closed_by":{"login":"chillerobscuro","id":5232872,"node_id":"MDQ6VXNlcjUyMzI4NzI=","avatar_url":"https://avatars.githubusercontent.com/u/5232872?v=4","gravatar_id":"","url":"https://api.github.com/users/chillerobscuro","html_url":"https://github.com/chillerobscuro","followers_url":"https://api.github.com/users/chillerobscuro/followers","following_url":"https://api.github.com/users/chillerobscuro/following{/other_user}","gists_url":"https://api.github.com/users/chillerobscuro/gists{/gist_id}","starred_url":"https://api.github.com/users/chillerobscuro/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/chillerobscuro/subscriptions","organizations_url":"https://api.github.com/users/chillerobscuro/orgs","repos_url":"https://api.github.com/users/chillerobscuro/repos","events_url":"https://api.github.com/users/chillerobscuro/events{/privacy}","received_events_url":"https://api.github.com/users/chillerobscuro/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/3889/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/3889/timeline","performed_via_github_app":null,"state_reason":"completed"}