{"url":"https://api.github.com/repos/sktime/sktime/issues/2603","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/2603/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/2603/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/2603/events","html_url":"https://github.com/sktime/sktime/issues/2603","id":1225856882,"node_id":"I_kwDOCVKAsc5JERdy","number":2603,"title":"[ENH] General Delegator Design Discussion","user":{"login":"miraep8","id":10511777,"node_id":"MDQ6VXNlcjEwNTExNzc3","avatar_url":"https://avatars.githubusercontent.com/u/10511777?v=4","gravatar_id":"","url":"https://api.github.com/users/miraep8","html_url":"https://github.com/miraep8","followers_url":"https://api.github.com/users/miraep8/followers","following_url":"https://api.github.com/users/miraep8/following{/other_user}","gists_url":"https://api.github.com/users/miraep8/gists{/gist_id}","starred_url":"https://api.github.com/users/miraep8/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/miraep8/subscriptions","organizations_url":"https://api.github.com/users/miraep8/orgs","repos_url":"https://api.github.com/users/miraep8/repos","events_url":"https://api.github.com/users/miraep8/events{/privacy}","received_events_url":"https://api.github.com/users/miraep8/received_events","type":"User","site_admin":false},"labels":[{"id":1180363817,"node_id":"MDU6TGFiZWwxMTgwMzYzODE3","url":"https://api.github.com/repos/sktime/sktime/labels/API%20design","name":"API design","color":"874db7","default":false,"description":"API design & software architecture"},{"id":1180366006,"node_id":"MDU6TGFiZWwxMTgwMzY2MDA2","url":"https://api.github.com/repos/sktime/sktime/labels/implementing%20framework","name":"implementing framework","color":"61c7f9","default":false,"description":"Implementing frameworks for new learning tasks"},{"id":3796180314,"node_id":"LA_kwDOCVKAsc7iRR1a","url":"https://api.github.com/repos/sktime/sktime/labels/enhancement","name":"enhancement","color":"fef2c0","default":true,"description":"Adding new functionality"}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":18,"created_at":"2022-05-04T19:56:51Z","updated_at":"2022-07-26T21:55:49Z","closed_at":null,"author_association":"COLLABORATOR","active_lock_reason":null,"body":"### Overview:\r\n\r\nThis issue is intended to be a spot for a design discussion for how to implement a new more general delegation functionality per a suggestion from @fkiraly .\r\n\r\nTo give some context for the issue at hand - many of the composite classes related to multiple estimator testing/comparison - e.g. `MultiplexForecaster` behave *like* a wrapper where most of their forecasting functionality is delegated to a wrapped forecaster. In implementing `MultiplexTransformer` it became clear a more general delegation functionality (that also extended to transformers) would be useful. And that the current delegation approach seemed to have some issues that required dynamic tag setting/might make it hard to apply to BaseGridSearch (which it would also be useful, as it has a very important `_fit` class).  #2570 is an attempt to solve this problem, however I think it has some design issues, so thought opening it up to move discussion might be very useful!\r\n\r\n### Summary of the Two Approaches:\r\n\r\n(*there are of course more than 2 ways to solve this problem, but this summarizes the approach I have implemented and the mixin approach already in place.  Also, just an attempt to  give a high level sense of what these two approaches are doing/how they differ, but I may have left something important out - so please chime in if I did. *)\r\n\r\n##### Current approach via the mixin (as it was implemented):\r\n- Have a `DelegatedForecaster` class each class requiring delegation inherits from (as a \"mixin\")\r\n- This class overwrites all the underscore methods (eg `_fit()`, `_predict()` etc) so that they are called on the delegated forecaster instead.\r\n- This means the original functions are called on all wrapped estimators - which can have various issues (namely we now need to dynamically set the tags of the composite classes so that when we call `fit()` on them we accept inputs. \r\n- The solution to this is to add some logic to `__init__`, and have a `reset()` function that is called at the start of each call to `fit()`. \r\n- The advantage of this approach is only the estimator actually in need of having a delegation ability is exposed to the delegation logic by inheriting from the mixin. \r\n\r\n##### Proposed new approach via the decorator (as it was implemented):\r\n- Add a decorator to all the main functions in `BaseEstimator` (eg `fit()`, `predict()` etc) which will delegate that function to the wrapped estimator if one is provided.\r\n- Add an attribute to store the name of the attribute storing the estimator these functions should be delegated to. Defaults to `None` so estimators that do not delegate should not be affected. \r\n- This approach has a disadvantage in that all `BaseEstimator`'s now have delegation logic attached to them even though many of them might not need it. \r\n- Because `fit()` is no longer being called on the \"main estimator\" we now no longer need to dynamically set tags, (at least not to get `fit()` to work).  This makes sense to me at least.\r\n- But because `fit()` is no longer called on the main estimator, we now need a way to copy over certain attributes to the main estimator (e.g. `_y`, `_fh`, `_is_fitted` and `_cutoff`), so we need an additional functionality in the decorator which takes care of copying over these attributes from the wrapped estimator to the main estimator.  - we keep track of the names of the estimator to copy over in a new attribute. \r\n\r\nNote, in my mind the main design advantages/disadvantages of each approach actually don't come from either using a delegator/mixin, but rather how each are implemented (in my mind). Taking this into account, I propose a hybrid solution: \r\n\r\n##### Hybrid Solution: \r\n- Use a mixin (Personally I think the mixin would work well here, as I think it is the easiest way to make sure only the classes which need delegation functionality get it.)\r\n- Give the mixin has an attribute called `_funcs_to_delegate` which will include the names of the functions to be delegated ie [`fit`, `predict`,...] etc.  This will be nice because certain functions might not want to delegate all functions (ie `BaseGridSearch` which for the most part is a great candidate for delegation doesn't actually work well if you delegate `fit()`, and having the ability to control which functions get delegated is useful.)\r\n- We will then use a decorator to wrap all these functions based on the function names provided. (@ltsaprounis has to do something similar in his mock estimator stuff/I like the way he did it so I would plan to do it similarly here). \r\n\r\nNote - this would stick with delegating the non-underscore classes, which I think is a good idea. We will then still need to copy over certain attributes from the fitted data to the wrapped estimator. (And I would probably do this in a similar way as I did before). ","closed_by":null,"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/2603/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/2603/timeline","performed_via_github_app":null,"state_reason":null}