{"url":"https://api.github.com/repos/sktime/sktime/issues/3838","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/3838/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/3838/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/3838/events","html_url":"https://github.com/sktime/sktime/issues/3838","id":1465178711,"node_id":"I_kwDOCVKAsc5XVNpX","number":3838,"title":"[ENH] Catching failure of forecast fit (e.g., arima zero division error), naive fallback","user":{"login":"RikStarmans","id":109525630,"node_id":"U_kgDOBoc6fg","avatar_url":"https://avatars.githubusercontent.com/u/109525630?v=4","gravatar_id":"","url":"https://api.github.com/users/RikStarmans","html_url":"https://github.com/RikStarmans","followers_url":"https://api.github.com/users/RikStarmans/followers","following_url":"https://api.github.com/users/RikStarmans/following{/other_user}","gists_url":"https://api.github.com/users/RikStarmans/gists{/gist_id}","starred_url":"https://api.github.com/users/RikStarmans/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/RikStarmans/subscriptions","organizations_url":"https://api.github.com/users/RikStarmans/orgs","repos_url":"https://api.github.com/users/RikStarmans/repos","events_url":"https://api.github.com/users/RikStarmans/events{/privacy}","received_events_url":"https://api.github.com/users/RikStarmans/received_events","type":"User","site_admin":false},"labels":[{"id":3105906374,"node_id":"MDU6TGFiZWwzMTA1OTA2Mzc0","url":"https://api.github.com/repos/sktime/sktime/labels/module:forecasting","name":"module:forecasting","color":"35FCCE","default":false,"description":""},{"id":3796180314,"node_id":"LA_kwDOCVKAsc7iRR1a","url":"https://api.github.com/repos/sktime/sktime/labels/enhancement","name":"enhancement","color":"fef2c0","default":true,"description":"Adding new functionality"}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":9,"created_at":"2022-11-26T15:06:38Z","updated_at":"2022-12-03T12:04:22Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"**Is your feature request related to a problem? Please describe.**\r\nI am fitting a lot of time series with a column ensemble forecaster.\r\nEach forecaster is now a simple autoarima model.\r\nIF the fit fails, I want to be able to have a backup forecaster. Now, the entire pipeline fails.\r\n\r\nAutoarima can simply fail and raise a ZeroDivisionError. I tried differencing etc, still this seems to be inherent to the method.\r\nI tried the StatsForecast and the PMDarima implementation.\r\nYou are supposed to capture it.\r\nSome of my signals seem to change over time and then the ZeroDivisionError is triggered.\r\nThese are my settings for StatsForecastAutoarima\r\n```python\r\ndefaults = {\r\n            \"seasonal\": False,\r\n            # Seasonality, temperature is highly seasonal, does not add value\r\n            # regular settings\r\n            \"d\": None,  # is should look for ultimate difference term\r\n            \"max_p\": 12,\r\n            \"max_q\": 5,\r\n            \"stepwise\": True,  \r\n            \"trend\": True,  # considers trend models\r\n            \"n_jobs\": None,\r\n            \"parallel\": False,  # TRUE NOT IMPLEMENTED\r\n            \"n_fits\": int(nfits),\r\n            \"trace\": False,  # print status of fits\r\n        }\r\n```\r\n\r\n**Describe the solution you'd like**\r\nI rather have a bad estimate or a naive estimate then a failure.\r\nAlso I want to know for which column the fit failed.\r\n\r\n**Describe alternatives you've considered**\r\nA clear and concise description of any alternative solutions or features you've considered.\r\n@aiwalter \r\nI can think of a solution: convert your columns into panel data, then run a grid search on ForecastByLevel with multiple models, if ARIMA fails there would still be another one\r\n\r\nIn my case this costs too much compute.  I have fixed it as follows.\r\nIf the fit fails, it falls back to naive. \r\nOther options could be to handle this in ColumnEnsembleForecaster or BaseForecaster.\r\n\r\n```python\r\nclass ARIMAMOD(BaseForecaster):\r\n    _tags = {\r\n        \"scitype:y\": \"univariate\",  # which y are fine? univariate/multivariate/both\r\n        \"ignores-exogeneous-X\": False,  # does estimator ignore the exogeneous X?\r\n        \"handles-missing-data\": False,  # can estimator handle missing data?\r\n        \"y_inner_mtype\": \"pd.Series\",  # which types do _fit, _predict, assume for y?\r\n        \"X_inner_mtype\": \"pd.DataFrame\",  # which types do _fit, _predict, assume for X?\r\n        \"requires-fh-in-fit\": False,  # is forecasting horizon already required in fit?\r\n        \"X-y-must-have-same-index\": False,  # can estimator handle different X/y index?\r\n        \"enforce_index_type\": None,  # index type that needs to be enforced in X/y\r\n        \"capability:pred_int\": True,  # does forecaster implement predict_quantiles?\r\n        \"python_dependencies\": \"statsforecast\",\r\n    }\r\n\r\n    def __init__(\r\n        self,\r\n        start_p: int = 2,\r\n        d: Optional[int] = None,\r\n        start_q: int = 2,\r\n        max_p: int = 5,\r\n        max_d: int = 2,\r\n        max_q: int = 5,\r\n        start_P: int = 1,\r\n        D: Optional[int] = None,\r\n        start_Q: int = 1,\r\n        max_P: int = 2,\r\n        max_D: int = 1,\r\n        max_Q: int = 2,\r\n        max_order: int = 5,\r\n        sp: int = 1,\r\n        seasonal: bool = True,\r\n        stationary: bool = False,\r\n        information_criterion: str = \"aicc\",\r\n        test: str = \"kpss\",\r\n        seasonal_test: str = \"seas\",\r\n        stepwise: bool = True,\r\n        n_jobs: int = 2,\r\n        trend: bool = True,\r\n        method: Optional[str] = None,\r\n        offset_test_args: Optional[str] = None,\r\n        seasonal_test_args: Optional[Dict] = None,\r\n        trace: bool = False,\r\n        n_fits: int = 94,\r\n        with_intercept: bool = True,\r\n        approximation: Optional[bool] = None,\r\n        truncate: Optional[bool] = None,\r\n        blambda: Optional[float] = None,\r\n        biasadj: bool = False,\r\n        parallel: bool = False,\r\n        strategy=\"last\",\r\n        window_length=None,\r\n    ):\r\n        self.start_p = start_p\r\n        self.d = d\r\n        self.start_q = start_q\r\n        self.max_p = max_p\r\n        self.max_d = max_d\r\n        self.max_q = max_q\r\n        self.start_P = start_P\r\n        self.D = D\r\n        self.start_Q = start_Q\r\n        self.max_P = max_P\r\n        self.max_D = max_D\r\n        self.max_Q = max_Q\r\n        self.max_order = max_order\r\n        self.seasonal = seasonal\r\n        self.stationary = stationary\r\n        self.information_criterion = information_criterion\r\n        self.test = test\r\n        self.seasonal_test = seasonal_test\r\n        self.stepwise = stepwise\r\n        self.n_jobs = n_jobs\r\n        self.trend = trend\r\n        self.method = method\r\n        self.offset_test_args = offset_test_args\r\n        self.seasonal_test_args = seasonal_test_args\r\n        self.trace = trace\r\n        self.n_fits = n_fits\r\n        self.with_intercept = with_intercept\r\n        self.approximation = approximation\r\n        self.truncate = truncate\r\n        self.blambda = blambda\r\n        self.biasadj = biasadj\r\n        self.parallel = parallel\r\n        self.strategy = strategy\r\n        self.sp = sp\r\n        self.window_length = window_length\r\n        self.armamodel = StatsForecastAutoARIMA(\r\n            start_p,\r\n            d,\r\n            start_q,\r\n            max_p,\r\n            max_d,\r\n            max_q,\r\n            start_P,\r\n            D,\r\n            start_Q,\r\n            max_P,\r\n            max_D,\r\n            max_Q,\r\n            max_order,\r\n            sp,\r\n            seasonal,\r\n            stationary,\r\n            information_criterion,\r\n            test,\r\n            seasonal_test,\r\n            stepwise,\r\n            n_jobs,\r\n            trend,\r\n            method,\r\n            offset_test_args,\r\n            seasonal_test_args,\r\n            trace,\r\n            n_fits,\r\n            with_intercept,\r\n            approximation,\r\n            truncate,\r\n            blambda,\r\n            biasadj,\r\n            parallel,\r\n        )\r\n        self.naivemodel = NaiveForecaster(strategy, window_length, sp)\r\n        self.naive = False\r\n        super().__init__()\r\n\r\n    def _fit(self, y, X=None, fh=None):\r\n        try:\r\n            self.naive = False\r\n            return self.armamodel.fit(fh=fh, X=X, y=y)\r\n        except ZeroDivisionError:\r\n            print(\"failed, using naive\")\r\n            self.naive = True\r\n            return self.naivemodel.fit(fh=fh, X=X, y=y)\r\n\r\n    def _predict(self, fh, X=None):\r\n        if self.naive:\r\n            return self.naivemodel.predict(fh=fh, X=X)\r\n        else:\r\n            return self.armamodel.predict(fh=fh, X=X)\r\n```\r\n\r\n\r\n**Additional context**\r\nTested the code and it seems to work.\r\n","closed_by":null,"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/3838/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/3838/timeline","performed_via_github_app":null,"state_reason":null}