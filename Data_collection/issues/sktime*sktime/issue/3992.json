{"url":"https://api.github.com/repos/sktime/sktime/issues/3992","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/3992/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/3992/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/3992/events","html_url":"https://github.com/sktime/sktime/issues/3992","id":1510160421,"node_id":"I_kwDOCVKAsc5aAzgl","number":3992,"title":"[ENH] A simple Moving Average Forecaster","user":{"login":"ngupta23","id":33585645,"node_id":"MDQ6VXNlcjMzNTg1NjQ1","avatar_url":"https://avatars.githubusercontent.com/u/33585645?v=4","gravatar_id":"","url":"https://api.github.com/users/ngupta23","html_url":"https://github.com/ngupta23","followers_url":"https://api.github.com/users/ngupta23/followers","following_url":"https://api.github.com/users/ngupta23/following{/other_user}","gists_url":"https://api.github.com/users/ngupta23/gists{/gist_id}","starred_url":"https://api.github.com/users/ngupta23/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ngupta23/subscriptions","organizations_url":"https://api.github.com/users/ngupta23/orgs","repos_url":"https://api.github.com/users/ngupta23/repos","events_url":"https://api.github.com/users/ngupta23/events{/privacy}","received_events_url":"https://api.github.com/users/ngupta23/received_events","type":"User","site_admin":false},"labels":[{"id":3796180314,"node_id":"LA_kwDOCVKAsc7iRR1a","url":"https://api.github.com/repos/sktime/sktime/labels/enhancement","name":"enhancement","color":"fef2c0","default":true,"description":"Adding new functionality"}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":10,"created_at":"2022-12-24T17:36:50Z","updated_at":"2022-12-25T15:34:18Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"**Is your feature request related to a problem? Please describe.**\r\n\r\nA simple moving average forecaster is often a good baseline model. I would like this forecaster using sktime, e.g. one which will forecast based on the moving average of the last N data points. For some reason, I am not able to create this currently, so any guidance on this would be appreciated.\r\n\r\n**Describe the solution you'd like**\r\nSee above\r\n\r\n**Describe alternatives you've considered**\r\n\r\nThis is what I have done so far. \r\n\r\n1. Created a `WindowSummarizer` that find the moving average\r\n2. Used this `WindowSummarizer` in a TransformedTargetForecaster along with `make_reduction`.\r\n3. I was not sure what estimator to use in `make_reduction` since I want the output to be exactly equal to the MA value.  So I created a custom sklearn estimator which just returns X back as the prediction (in our case, X would be the MA created by the `WindowSummarizer`.\r\n\r\nThe code is below, but there are 2 issues\r\n\r\n1. This seems to be an overly complicated implementation for a Moving Average Forecaster.\r\n2. It does not work completely. The first prediction is correct (MA of the last 3 data points), but all subsequent predictions are not correct. It seems as if the recursive nature is not working with the way I am using the code now (or maybe a bug?)\r\n\r\n```python\r\n\r\n# Custom scikit estimator where predictions are the same as X (first column)\r\n# Based on https://github.com/scikit-learn-contrib/project-template/blob/master/skltemplate/_template.py\r\n\r\nimport numpy as np\r\nfrom sklearn.base import BaseEstimator\r\nfrom sklearn.utils.validation import check_X_y, check_array, check_is_fitted\r\n\r\nclass PredictX0(BaseEstimator):\r\n    def fit(self, X, y):\r\n        X, y = check_X_y(X, y, accept_sparse=True)\r\n        self.is_fitted_ = True\r\n        # `fit` should always return `self`\r\n        return self\r\n\r\n    def predict(self, X):\r\n        X = check_array(X, accept_sparse=True)\r\n        check_is_fitted(self, \"is_fitted_\")\r\n        # Returns the first column\r\n        return X[:, 0]\r\n\r\nX = np.array([1, 2, 3, 4, 5]).reshape(-1, 1)\r\ny = np.array([100, 100, 100, 100, 100])\r\n\r\nmodel = PredictX0()\r\nmodel.fit(X, y)\r\np = model.predict(X + 2)\r\n\r\n# Predictions are the same as the X value passed in\r\n```\r\n\r\n\r\n```python\r\n# Code for Moving Average forecaster\r\n\r\ndata = load_airline()\r\nma_window = 3\r\nkwargs = {\"lag_feature\": {\"mean\": [[0, ma_window]]}}\r\ntransformer = WindowSummarizer(**kwargs, truncate=\"bfill\")\r\n\r\nforecaster = TransformedTargetForecaster(\r\n    [\r\n        (\"ma\", transformer),\r\n        (\r\n            \"forecast\",\r\n            make_reduction(\r\n                estimator=PredictX0(),\r\n                scitype=\"tabular-regressor\",\r\n                window_length=1,\r\n                strategy=\"recursive\",                \r\n            ),\r\n        ),\r\n    ]\r\n)\r\nforecaster.fit(y=data, fh=[1, 2, 3, 4, 5])\r\npreds = forecaster.predict()\r\n```\r\n\r\nThe last few data points and the predictions are as follows\r\n\r\n![image](https://user-images.githubusercontent.com/33585645/209446109-c6f19076-0d29-4ea8-8471-1125a2c43149.png)\r\n\r\n\r\nAs can be seen the first prediction of 427.667 is correct, but all further predictions are simply matching the first one which is incorrect.\r\nKindly advice on how to implement this using sktime. Thanks!\r\n\r\n**Additional context**\r\n\r\nSort of related ... I built my code based on discussions in the Issue: https://github.com/sktime/sktime/issues/1577\r\n","closed_by":null,"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/3992/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/3992/timeline","performed_via_github_app":null,"state_reason":null}