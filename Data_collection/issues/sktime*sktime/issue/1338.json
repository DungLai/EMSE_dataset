{"url":"https://api.github.com/repos/sktime/sktime/issues/1338","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/1338/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/1338/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/1338/events","html_url":"https://github.com/sktime/sktime/issues/1338","id":973921411,"node_id":"MDU6SXNzdWU5NzM5MjE0MTE=","number":1338,"title":"[ENH] Unifying and refactoring sub-module structure across modules","user":{"login":"RNKuhns","id":26907244,"node_id":"MDQ6VXNlcjI2OTA3MjQ0","avatar_url":"https://avatars.githubusercontent.com/u/26907244?v=4","gravatar_id":"","url":"https://api.github.com/users/RNKuhns","html_url":"https://github.com/RNKuhns","followers_url":"https://api.github.com/users/RNKuhns/followers","following_url":"https://api.github.com/users/RNKuhns/following{/other_user}","gists_url":"https://api.github.com/users/RNKuhns/gists{/gist_id}","starred_url":"https://api.github.com/users/RNKuhns/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/RNKuhns/subscriptions","organizations_url":"https://api.github.com/users/RNKuhns/orgs","repos_url":"https://api.github.com/users/RNKuhns/repos","events_url":"https://api.github.com/users/RNKuhns/events{/privacy}","received_events_url":"https://api.github.com/users/RNKuhns/received_events","type":"User","site_admin":false},"labels":[{"id":1180363817,"node_id":"MDU6TGFiZWwxMTgwMzYzODE3","url":"https://api.github.com/repos/sktime/sktime/labels/API%20design","name":"API design","color":"874db7","default":false,"description":"API design & software architecture"},{"id":1631667223,"node_id":"MDU6TGFiZWwxNjMxNjY3MjIz","url":"https://api.github.com/repos/sktime/sktime/labels/maintenance","name":"maintenance","color":"ea761e","default":false,"description":"Continuous integration, unit testing & package distribution"}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2021-08-18T17:57:14Z","updated_at":"2022-01-12T14:06:44Z","closed_at":null,"author_association":"COLLABORATOR","active_lock_reason":null,"body":"**Is your feature request related to a problem? Please describe.**\r\n\r\nAs I've been going through looking at docstrings, I've noticed that sktime has a variety of \"top-level\" modules (e.g. forecasting, annotation, classification, etc). The sub-modules within these modules tend to have different \"structures\". \r\n\r\nFor instance forecasting/classification provide access to \"all\" functionality related to those learning tasks via the \"all\" sub-module. \r\n\r\nIn forecasting and transformation modules individual algorithms (for the most part) are in their own sub-modules (e.g. `from sktime.forecasting.arima import AutoArima`). In classification there is another level (e.g.: dictionary_based) and the files with the algorithms are non-public (e.g. `_cboss.py`).\r\n\r\nIn clustering the algorithms are imported from the top-level package (and the files they are implemented in are non-public). \r\n\r\nIn annotation there is an `adapters` sub-module, but in forecasting we have adapter code that is imported in the individual algorithm sub-modules (e.g. prophet is in its own module that imports its adapter as opposed to being in an adapter module). \r\n\r\nHaving so many different structures is not ideal. There is the Python idiom about having one clear way to do something. And importantly having all these different layouts can cause confusion to new users about where functionality should be imported from.\r\n\r\n**Describe the solution you'd like**\r\nFollowing the docsprint I think propose we have a developer meeting to build consensus on how we think sktime sub-modules should be structured. \r\n\r\nI'd propose that developers agree on a general sub-module format and then we create a summary issue to track each module's refactoring to align with the format we agree on. This will of course involve some \"pain\" in refactoring modules and adding deprecations (I'd propose we deprecate for a release before removing). But doing it now makes things much easier down the road. I also think that it might not be too bad to do because we are not changing anything beyond filenames/locations and then of course imports. \r\n\r\n**Describe alternatives you've considered**\r\nAn alternative would be to try and have a module restructuring sprint and milestone where we try to do all the restructuring in a week or two.\r\n\r\n**Additional context**\r\nI'm partial to the way the classification module is set up (individual code files are non-public and related algorithms are all imported from the same sub-module). This has the added benefit that in many cases the sub-modules don't match 100% with the code file that implemented the algorithm. This makes it easier if we need to rename, refactor or otherwise move around those code files. For example, as long a user can use `from sktime.classification.dictionary_based import BOSSEnsemble` we can potentially rename the underlying file, condense it with another file, etc and not impact the user.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/1338/reactions","total_count":4,"+1":4,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/1338/timeline","performed_via_github_app":null,"state_reason":null}