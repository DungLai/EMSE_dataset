{"url":"https://api.github.com/repos/sktime/sktime/issues/1273","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/1273/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/1273/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/1273/events","html_url":"https://github.com/sktime/sktime/issues/1273","id":964775614,"node_id":"MDU6SXNzdWU5NjQ3NzU2MTQ=","number":1273,"title":"[ENH] Calendar Feature Extractor","user":{"login":"danbartl","id":19947407,"node_id":"MDQ6VXNlcjE5OTQ3NDA3","avatar_url":"https://avatars.githubusercontent.com/u/19947407?v=4","gravatar_id":"","url":"https://api.github.com/users/danbartl","html_url":"https://github.com/danbartl","followers_url":"https://api.github.com/users/danbartl/followers","following_url":"https://api.github.com/users/danbartl/following{/other_user}","gists_url":"https://api.github.com/users/danbartl/gists{/gist_id}","starred_url":"https://api.github.com/users/danbartl/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/danbartl/subscriptions","organizations_url":"https://api.github.com/users/danbartl/orgs","repos_url":"https://api.github.com/users/danbartl/repos","events_url":"https://api.github.com/users/danbartl/events{/privacy}","received_events_url":"https://api.github.com/users/danbartl/received_events","type":"User","site_admin":false},"labels":[{"id":1118163264,"node_id":"MDU6TGFiZWwxMTE4MTYzMjY0","url":"https://api.github.com/repos/sktime/sktime/labels/feature%20request","name":"feature request","color":"38d191","default":false,"description":"New feature or request"},{"id":3105907331,"node_id":"MDU6TGFiZWwzMTA1OTA3MzMx","url":"https://api.github.com/repos/sktime/sktime/labels/module:transformations","name":"module:transformations","color":"0865AF","default":false,"description":""}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":10,"created_at":"2021-08-10T09:25:02Z","updated_at":"2021-10-28T09:34:24Z","closed_at":"2021-10-28T09:34:24Z","author_association":"COLLABORATOR","active_lock_reason":null,"body":"**Is your feature request related to a problem? Please describe.**\r\nI would like to use sktime in the context of tree based models for time series. In general, these models need some data preparation to make them useful for time series. One data prepation step involves creating calendar dummy features representing the current day of the year, day of the month, week of the quarter etc. Another data preparation step would involve generating features representing fourier terms of different order and periodicity.\r\n\r\n**Describe the solution you'd like**\r\nI have been thinking about the best way to implement this, and @aiwalter  suggested to use an SeriesToSeries Transformer to generate new exogeneous features based on the index in ForecastingPipeline. Would that approach work from an architecture point of view, or do we need a separate not yet defined class \"FeatureExtractor\" and / or a specific IndexToSeries Generator?\r\n\r\nWe could either try to adapt solutions from GluonTS (dummies) / Prophet (fourier features) or build our own approach. Attached is some example code (not yet adapted to sktime) to outline the general goal.\r\n\r\n```python\r\nimport pandas as pd\r\nimport numpy as np\r\n\r\nbase_seasons = [\r\n    [\"parent\",\"child\",\"period\",\"dummy\"],\r\n    [\"year\",\"year\",None,\"year\"],\r\n    [\"year\",\"quarter\",365.25/4,\"quarter\"],  \r\n    [\"year\",\"month\",12,\"month\"],\r\n    [\"year\",\"week\",365.25/7,\"week_of_year\"],\r\n    [\"year\",\"day\",365.25,\"day_of_year\"],\r\n    [\"quarter\",\"month\",12/4,\"month_of_quarter\"],\r\n    [\"quarter\",\"week\",365.25/(4*7),\"week_of_quarter\"],\r\n    [\"quarter\",\"day\",365.25/4,\"day_of_quarter\"],\r\n    [\"month\",\"week\",365.25/(12*7),\"week_of_month\"],\r\n    [\"month\",\"day\",30,\"day\"],\r\n    [\"week\",\"day\",7,\"day_of_week\"],\r\n    [\"day\",\"hour\",24,\"hour\"],\r\n    [\"hour\",\"minute\",60,\"minute\"],\r\n    [\"minute\",\"second\",60,\"second\"],\r\n    [\"second\",\"millisecond\",1000,\"millisecond\"]\r\n]\r\n\r\n\r\nbase_seasons = pd.DataFrame(base_seasons[1:],columns=base_seasons[0])\r\n\r\nbase_seasons[\"fourier\"] = base_seasons[\"child\"] + '_in_' + base_seasons[\"parent\"]\r\nbase_seasons[\"child\"] = base_seasons[\"child\"].astype(\"category\").cat.reorder_categories(['year','quarter','month', 'week','day',\"hour\",\"minute\",\"second\",\"millisecond\"])\r\nbase_seasons[\"rank\"] = base_seasons[\"child\"].cat.codes\r\n\r\n\r\n\r\ndef get_supported_seasons(base_frequency,base_seasons=base_seasons):\r\n    rank = base_seasons.loc[base_seasons[\"child\"]==base_frequency,\"rank\"].max()\r\n    matches = base_seasons.loc[base_seasons[\"rank\"]<=rank]\r\n    if matches.shape[0] == 0:\r\n        raise ValueError(\"Seasonality or Frequency not supported\")\r\n    return matches\r\n\r\ndef calendar_fourier(dti_actual,fourier_period,fourier_order,base_frequency):\r\n    dti = pd.date_range(dti_actual.min(),dti_actual.max(),freq=base_frequency.upper()[0]) \r\n    \r\n    if dti.min().to_numpy() != dti_actual.min().to_numpy():\r\n        raise ValueError(\"Actual time Series does not correspond to frequencies provided by pandas Datetimeindex. This can happen when e.g. monthly data does not correspond to month end.\")\r\n    \r\n    funcs = [np.sin,np.cos] \r\n\r\n    outlist = list()\r\n    for index,item in enumerate(fourier_order):\r\n        outlist.append((np.arange(item)+1)*1/fourier_period[index])\r\n\r\n    inlist = np.zeros(shape=(len(dti),np.concatenate(outlist).shape[0]*len(funcs)))\r\n    colnames = list()\r\n    k = 0\r\n    for item in outlist:\r\n        for index,p in enumerate(item):\r\n            for func in funcs:\r\n                inlist[:,k] =func(2*np.pi*p*np.arange(len(dti)))\r\n#                colnames.append(\"per\"+ str(int(1/p)*int(index+1)) + \"_or\" + str(int(index+1))+func.__name__)\r\n                colnames.append(\"per\"+ str(int(1/p)) + func.__name__)\r\n                k = k +1\r\n\r\n    inlist = pd.DataFrame(inlist)\r\n    inlist.columns = colnames\r\n    inlist.set_index(dti,inplace=True)\r\n\r\n    inlist = inlist[inlist.index.isin(dti_actual)]\r\n    inlist = inlist.reset_index(drop=True)\r\n    return inlist\r\n\r\ndef calendar_dummies(x,funcs):\r\n    if funcs == \"week_of_year\":\r\n        return pd.DataFrame({funcs:getattr(x,\"isocalendar\")()[\"week\"].reset_index(drop=\"date\")})\r\n    elif funcs == \"week_of_month\":\r\n        return  pd.DataFrame({funcs:(x.day - 1) // 7 + 1})\r\n    elif funcs == \"month_of_quarter\":\r\n        return pd.DataFrame({funcs:(np.floor(x.month/4)+1).astype(np.int64)})\r\n    elif funcs == \"week_of_quarter\":\r\n        year_week = getattr(x,\"isocalendar\")()[\"week\"]\r\n        def week_of_quarter(x):\r\n            if x <= 13:\r\n                return 1\r\n            elif x <=26:\r\n                return x-13\r\n            elif x <=39:\r\n                return x-26\r\n            elif x <=53:\r\n                return x-39\r\n        year_week.apply(lambda x: week_of_quarter(x))\r\n    elif funcs == \"millisecond\":\r\n        return  pd.DataFrame({funcs:x.microsecond*1000})\r\n    elif funcs == \"day_of_quarter\":\r\n        quarter = x.quarter\r\n        quarter_start = pd.DatetimeIndex(\r\n        x.year.map(str) + \"-\" + (3 * quarter - 2).map(int).map(str) + \"-01\")\r\n        values  = ((x - quarter_start) / pd.to_timedelta(\"1D\") + 1).astype(int)\r\n        return pd.DataFrame({funcs:values},dtype=np.float64)\r\n    else:\r\n        return pd.DataFrame({funcs:getattr(x,funcs)})\r\n\r\n\r\ndef calendar_other(x,funcs):\r\n    if funcs == \"proportion_total\":\r\n        values = 1+(x.view(np.int64)-x.view(np.int64).max())/(x.view(np.int64).max()-x.view(np.int64).min())\r\n        return pd.DataFrame({funcs:values},dtype=np.float64)\r\n    elif funcs == \"proportion_total_squared\":\r\n        values = (1+(x.view(np.int64)-x.view(np.int64).max())/(x.view(np.int64).max()-x.view(np.int64).min()))^2\r\n        return pd.DataFrame({funcs:values},dtype=np.float64)\r\n    elif funcs == \"proportion_total_cubic\":\r\n        values = (1+(x.view(np.int64)-x.view(np.int64).max())/(x.view(np.int64).max()-x.view(np.int64).min()))^3\r\n        return pd.DataFrame({funcs:values},dtype=np.float64)\r\n    elif funcs == \"proportion_total_squared_root\":\r\n        values = (1+(x.view(np.int64)-x.view(np.int64).max())/(x.view(np.int64).max()-x.view(np.int64).min()))^(1/2)\r\n        return pd.DataFrame({funcs:values},dtype=np.float64)\r\n    elif funcs == \"proportion_total_cubic_root\":\r\n        values = (1+(x.view(np.int64)-x.view(np.int64).max())/(x.view(np.int64).max()-x.view(np.int64).min()))^(1/3)\r\n        return pd.DataFrame({funcs:values},dtype=np.float64)\r\n    elif funcs == \"proportion_month\":\r\n        values = x.day/x.days_in_month\r\n        return pd.DataFrame({funcs:values},dtype=np.float64)\r\n    elif funcs == \"proportion_quarter\":\r\n        quarter = x.dt.quarter\r\n        quarter_start = pd.DatetimeIndex(\r\n        x.dt.year.map(str) + \"-\" + (3 * quarter - 2).map(int).map(str) + \"-01\")\r\n        next_quarter_start = x + pd.tseries.offsets.QuarterBegin(startingMonth=1)\r\n        quarter_length = (next_quarter_start - quarter_start).dt.days\r\n        doq  = ((x - quarter_start) / pd.to_timedelta(\"1D\") + 1).astype(int)\r\n        values = doq / quarter_length\r\n        return pd.DataFrame({funcs:values},dtype=np.float64)\r\n```\r\n","closed_by":{"login":"fkiraly","id":7985502,"node_id":"MDQ6VXNlcjc5ODU1MDI=","avatar_url":"https://avatars.githubusercontent.com/u/7985502?v=4","gravatar_id":"","url":"https://api.github.com/users/fkiraly","html_url":"https://github.com/fkiraly","followers_url":"https://api.github.com/users/fkiraly/followers","following_url":"https://api.github.com/users/fkiraly/following{/other_user}","gists_url":"https://api.github.com/users/fkiraly/gists{/gist_id}","starred_url":"https://api.github.com/users/fkiraly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fkiraly/subscriptions","organizations_url":"https://api.github.com/users/fkiraly/orgs","repos_url":"https://api.github.com/users/fkiraly/repos","events_url":"https://api.github.com/users/fkiraly/events{/privacy}","received_events_url":"https://api.github.com/users/fkiraly/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/1273/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/1273/timeline","performed_via_github_app":null,"state_reason":"completed"}