{"url":"https://api.github.com/repos/sktime/sktime/issues/2710","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/2710/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/2710/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/2710/events","html_url":"https://github.com/sktime/sktime/issues/2710","id":1251695442,"node_id":"I_kwDOCVKAsc5Km1tS","number":2710,"title":"[BUG] Global forecaster unable to make predictions","user":{"login":"ngupta23","id":33585645,"node_id":"MDQ6VXNlcjMzNTg1NjQ1","avatar_url":"https://avatars.githubusercontent.com/u/33585645?v=4","gravatar_id":"","url":"https://api.github.com/users/ngupta23","html_url":"https://github.com/ngupta23","followers_url":"https://api.github.com/users/ngupta23/followers","following_url":"https://api.github.com/users/ngupta23/following{/other_user}","gists_url":"https://api.github.com/users/ngupta23/gists{/gist_id}","starred_url":"https://api.github.com/users/ngupta23/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ngupta23/subscriptions","organizations_url":"https://api.github.com/users/ngupta23/orgs","repos_url":"https://api.github.com/users/ngupta23/repos","events_url":"https://api.github.com/users/ngupta23/events{/privacy}","received_events_url":"https://api.github.com/users/ngupta23/received_events","type":"User","site_admin":false},"labels":[{"id":1118163262,"node_id":"MDU6TGFiZWwxMTE4MTYzMjYy","url":"https://api.github.com/repos/sktime/sktime/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"},{"id":3105906374,"node_id":"MDU6TGFiZWwzMTA1OTA2Mzc0","url":"https://api.github.com/repos/sktime/sktime/labels/module:forecasting","name":"module:forecasting","color":"35FCCE","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":9,"created_at":"2022-05-28T18:19:19Z","updated_at":"2022-11-09T10:14:12Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"**Describe the bug**\r\nGlobal forecaster not able to make predictions due to (missing) frequency information?\r\n\r\n\r\n**To Reproduce**\r\nModified from pydata Berlin notebooks. **Complete code & data [here](https://github.com/ngupta23/sktime-tutorial-pydata-berlin-2022/blob/109e25cafe798dc2d24d96427a5fd62866bab901/notebooks/minimal_issue_global.ipynb).** \r\n\r\n```python\r\ny_train_global, y_test_global, X_train_global, X_test_global = temporal_train_test_split(y_global, X_global)\r\n\r\nregressor = make_pipeline(\r\n    RandomForestRegressor(random_state=1),\r\n)\r\n\r\ndef count_gt130(x):\r\n    \"\"\"Count how many observations lie above threshold.\"\"\"\r\n    return np.sum((x > 700)[::-1])\r\n\r\n\r\nkwargs = {\r\n    \"lag_feature\": {\r\n        \"lag\": [1],\r\n        \"mean\": [[1, 3], [3, 6]],\r\n        \"std\": [[1, 4]],\r\n        count_gt130: [[2, 3]],\r\n    }\r\n}\r\n\r\n\r\nsteps=[\r\n        (\"daily_season\", DateTimeFeatures(ts_freq=\"D\")),  \r\n        (\"daily_season2\", DateTimeFeatures(manual_selection=[\"week_of_month\", \"day_of_quarter\"])),\r\n]  \r\n\r\nforecaster_global = make_reduction(\r\n    regressor,\r\n    scitype=\"tabular-regressor\",\r\n    transformers=[WindowSummarizer(**kwargs, n_jobs=1, truncate=\"bfill\")],\r\n    window_length=None,\r\n    strategy=\"recursive\",\r\n)\r\n\r\n\r\n# Version 2: Global Forecasting\r\npipe_global = ForecastingPipeline(steps= steps + [(\"forecaster\", forecaster_global)])\r\n\r\n_ = pipe_global.fit(y_train_global, X_train_global, fh=FH)\r\n\r\n# TODO (check): Does not recognize freq in X (so how did train work?)\r\ny_pred_global = pipe_global.predict(X=X_test_global)\r\n```\r\n\r\n```python-traceback\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\nInput In [10], in <cell line: 2>()\r\n      1 # TODO (check): Does not recognize freq in X (so how did train work?)\r\n----> 2 y_pred_global = pipe_global.predict(X=X_test_global)\r\n\r\nFile ~\\.conda\\envs\\sktime-pydata\\lib\\site-packages\\sktime\\forecasting\\base\\_base.py:320, in BaseForecaster.predict(self, fh, X)\r\n    318 # we call the ordinary _predict if no looping/vectorization needed\r\n    319 if not self._is_vectorized:\r\n--> 320     y_pred = self._predict(fh=fh, X=X_inner)\r\n    321 else:\r\n    322     # otherwise we call the vectorized version of predict\r\n    323     y_pred = self._vectorize(\"predict\", X=X_inner, fh=fh)\r\n\r\nFile ~\\.conda\\envs\\sktime-pydata\\lib\\site-packages\\sktime\\forecasting\\compose\\_pipeline.py:358, in ForecastingPipeline._predict(self, fh, X)\r\n    343 \"\"\"Forecast time series at future horizon.\r\n    344 \r\n    345 Parameters\r\n   (...)\r\n    355     Point predictions\r\n    356 \"\"\"\r\n    357 X = self._transform(X=X)\r\n--> 358 return self.forecaster_.predict(fh, X)\r\n\r\nFile ~\\.conda\\envs\\sktime-pydata\\lib\\site-packages\\sktime\\forecasting\\base\\_base.py:320, in BaseForecaster.predict(self, fh, X)\r\n    318 # we call the ordinary _predict if no looping/vectorization needed\r\n    319 if not self._is_vectorized:\r\n--> 320     y_pred = self._predict(fh=fh, X=X_inner)\r\n    321 else:\r\n    322     # otherwise we call the vectorized version of predict\r\n    323     y_pred = self._vectorize(\"predict\", X=X_inner, fh=fh)\r\n\r\nFile ~\\.conda\\envs\\sktime-pydata\\lib\\site-packages\\sktime\\forecasting\\base\\_sktime.py:62, in _BaseWindowForecaster._predict(self, fh, X)\r\n     60 # all values are out-of-sample\r\n     61 if fh.is_all_out_of_sample(self.cutoff):\r\n---> 62     return self._predict_fixed_cutoff(\r\n     63         fh.to_out_of_sample(self.cutoff), **kwargs\r\n     64     )\r\n     66 # all values are in-sample\r\n     67 elif fh.is_all_in_sample(self.cutoff):\r\n\r\nFile ~\\.conda\\envs\\sktime-pydata\\lib\\site-packages\\sktime\\forecasting\\base\\_sktime.py:96, in _BaseWindowForecaster._predict_fixed_cutoff(self, fh, X, return_pred_int, alpha)\r\n     81 \"\"\"Make single-step or multi-step fixed cutoff predictions.\r\n     82 \r\n     83 Parameters\r\n   (...)\r\n     93 y_pred = pd.Series or pd.DataFrame\r\n     94 \"\"\"\r\n     95 # assert all(fh > 0)\r\n---> 96 y_pred = self._predict_last_window(\r\n     97     fh, X, return_pred_int=return_pred_int, alpha=alpha\r\n     98 )\r\n     99 if isinstance(y_pred, pd.Series) or isinstance(y_pred, pd.DataFrame):\r\n    100     return y_pred\r\n\r\nFile ~\\.conda\\envs\\sktime-pydata\\lib\\site-packages\\sktime\\forecasting\\compose\\_reduce.py:525, in _RecursiveReducer._predict_last_window(self, fh, X, return_pred_int, alpha)\r\n    523 # Get last window of available data.\r\n    524 if self.transformers_ is not None:\r\n--> 525     y_last, X_last = self._get_shifted_window()\r\n    526 else:\r\n    527     y_last, X_last = self._get_last_window()\r\n\r\nFile ~\\.conda\\envs\\sktime-pydata\\lib\\site-packages\\sktime\\forecasting\\compose\\_reduce.py:478, in _RecursiveReducer._get_shifted_window(self, shift, y_update, X_update)\r\n    476 \"\"\"Select shifted window.\"\"\"\r\n    477 # Get the start and end points of the last window.\r\n--> 478 cutoff = _shift(self.cutoff, by=shift)\r\n    479 start = _shift(cutoff, by=-self.window_length_ + 1)\r\n    481 if self.transformers_ is not None:\r\n    482     # Get the last window of the endogenous variable.\r\n    483     # If X is given, also get the last window of the exogenous variables.\r\n\r\nFile ~\\.conda\\envs\\sktime-pydata\\lib\\site-packages\\sktime\\utils\\datetime.py:106, in _shift(x, by)\r\n    104 if isinstance(x, pd.Timestamp):\r\n    105     if not hasattr(x, \"freq\") or x.freq is None:\r\n--> 106         raise ValueError(\"No `freq` information available\")\r\n    107     by *= x.freq\r\n    108 return x + by\r\n\r\nValueError: No `freq` information available\r\n```\r\n\r\n\r\n**Expected behavior**\r\nWould have expected this to work since training uses the same X data frame indices.\r\n\r\n\r\n**Versions**\r\n<details>\r\n\r\nSystem:\r\n    python: 3.9.12 | packaged by conda-forge | (main, Mar 24 2022, 23:17:03) [MSC v.1929 64 bit (AMD64)]\r\nexecutable: C:\\Users\\Nikhil\\.conda\\envs\\sktime-pydata\\python.exe\r\n   machine: Windows-10-10.0.19044-SP0\r\n\r\nPython dependencies:\r\n          pip: 22.1.1\r\n   setuptools: 62.3.2\r\n      sklearn: 1.1.1\r\n       sktime: 0.11.4\r\n  statsmodels: 0.13.2\r\n        numpy: 1.22.4\r\n        scipy: 1.7.3\r\n       pandas: 1.4.2\r\n   matplotlib: 3.5.2\r\n       joblib: 1.1.0\r\n        numba: 0.53.0\r\n     pmdarima: 1.8.5\r\n      tsfresh: 0.19.0\r\n\r\n</details>\r\n\r\n<!-- Thanks for contributing! -->\r\n","closed_by":null,"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/2710/reactions","total_count":1,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":1},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/2710/timeline","performed_via_github_app":null,"state_reason":null}