{"url":"https://api.github.com/repos/sktime/sktime/issues/104","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/104/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/104/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/104/events","html_url":"https://github.com/sktime/sktime/issues/104","id":475206313,"node_id":"MDU6SXNzdWU0NzUyMDYzMTM=","number":104,"title":"pmdarima interface comparison","user":{"login":"mloning","id":21020482,"node_id":"MDQ6VXNlcjIxMDIwNDgy","avatar_url":"https://avatars.githubusercontent.com/u/21020482?v=4","gravatar_id":"","url":"https://api.github.com/users/mloning","html_url":"https://github.com/mloning","followers_url":"https://api.github.com/users/mloning/followers","following_url":"https://api.github.com/users/mloning/following{/other_user}","gists_url":"https://api.github.com/users/mloning/gists{/gist_id}","starred_url":"https://api.github.com/users/mloning/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mloning/subscriptions","organizations_url":"https://api.github.com/users/mloning/orgs","repos_url":"https://api.github.com/users/mloning/repos","events_url":"https://api.github.com/users/mloning/events{/privacy}","received_events_url":"https://api.github.com/users/mloning/received_events","type":"User","site_admin":false},"labels":[{"id":1180391124,"node_id":"MDU6TGFiZWwxMTgwMzkxMTI0","url":"https://api.github.com/repos/sktime/sktime/labels/interfacing%20algorithms","name":"interfacing algorithms","color":"ffc9cd","default":false,"description":"Interfacing existing algorithms/estimators for other packages"}],"state":"closed","locked":false,"assignee":{"login":"mloning","id":21020482,"node_id":"MDQ6VXNlcjIxMDIwNDgy","avatar_url":"https://avatars.githubusercontent.com/u/21020482?v=4","gravatar_id":"","url":"https://api.github.com/users/mloning","html_url":"https://github.com/mloning","followers_url":"https://api.github.com/users/mloning/followers","following_url":"https://api.github.com/users/mloning/following{/other_user}","gists_url":"https://api.github.com/users/mloning/gists{/gist_id}","starred_url":"https://api.github.com/users/mloning/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mloning/subscriptions","organizations_url":"https://api.github.com/users/mloning/orgs","repos_url":"https://api.github.com/users/mloning/repos","events_url":"https://api.github.com/users/mloning/events{/privacy}","received_events_url":"https://api.github.com/users/mloning/received_events","type":"User","site_admin":false},"assignees":[{"login":"mloning","id":21020482,"node_id":"MDQ6VXNlcjIxMDIwNDgy","avatar_url":"https://avatars.githubusercontent.com/u/21020482?v=4","gravatar_id":"","url":"https://api.github.com/users/mloning","html_url":"https://github.com/mloning","followers_url":"https://api.github.com/users/mloning/followers","following_url":"https://api.github.com/users/mloning/following{/other_user}","gists_url":"https://api.github.com/users/mloning/gists{/gist_id}","starred_url":"https://api.github.com/users/mloning/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mloning/subscriptions","organizations_url":"https://api.github.com/users/mloning/orgs","repos_url":"https://api.github.com/users/mloning/repos","events_url":"https://api.github.com/users/mloning/events{/privacy}","received_events_url":"https://api.github.com/users/mloning/received_events","type":"User","site_admin":false}],"milestone":null,"comments":2,"created_at":"2019-07-31T15:17:13Z","updated_at":"2020-04-25T11:31:44Z","closed_at":"2020-04-25T11:31:43Z","author_association":"COLLABORATOR","active_lock_reason":null,"body":"**Data container**\r\n* pmdarima assumes for y (target) array of shape=(n_obs,) and for X (exogeneous) array of shape=(n_obs, n_features), crucially with time series observations in rows. \r\n* by contrast, we have a nested pandas Series or DataFrame, with rows representing iid samples, i.e. in the classical forecasting setting a single row, and columns representing different kinds of measurements (i.e. features), the format is nested because each cell may contain no longer only primitive types but also arrays or pandas Series of shape=(n_obs,), \r\n* we chose this data container because it allows to have a unified interface for different time series related learning settings including forecasting, but also panel/longitunidal data settings such as time series classification/regression or supervised/panel forecasting.\r\n\r\n**Forecasting horizon**\r\n* we allow the forecasting horizon to be an array with the steps ahead, not only the number of steps ahead (`n_periods`), allowing for gaps e.g. predicting only the third and fifth step ahead with `fh = np.array([3, 5])`, may not make a difference for ARIMA, but will do for reduction strategies\r\n\r\n**Fit method**\r\n* some methods already require the forecasting horizon in `fit` (e.g. non-dynamic reduction to time series regression where one time series regressor is fitted for each step of the forcasting horizon)\r\n* pmdarima currently takes the forecasting horizon only in `predict`\r\n* should we allow the forecasting horizon when passed in `fit` to be then changed in `predict`?\r\n\r\n**Update method**\r\n* pmdarima adds the new data to the old data (kept in the model) and refits the model using the previously fitted params as start params,\r\n* is the new data always in the future?\r\n* alternatively, one could use the new data to update the already fitted parameters using Kalman smoothing/filtering, ideally only the new data is used so that the data seen in training does not have to be stored in the model? \r\n\r\n**In-sample forecasts**\r\n* pmdarima has a separate method for in-sample forecasts\r\n* currently, we don't have a good way to do in-sample forecasts, our forecasting horizon is currently relative to the end of the series seen in training, allowing negative values would perhaps be one option?\r\n\r\n**Forecast confidence intervals**\r\n* pmdarima returns intervals from `predict` method via an optional kwarg changing the output of predict \r\n* should we return intervals from a separate method instead to have a stable method signature for `predict`?\r\n* related to design discussion on probabilistic forecasting #97 \r\n\r\n**Composition**\r\n* Pipelines for target variable vs `TransformedTargetForecaster` ","closed_by":{"login":"mloning","id":21020482,"node_id":"MDQ6VXNlcjIxMDIwNDgy","avatar_url":"https://avatars.githubusercontent.com/u/21020482?v=4","gravatar_id":"","url":"https://api.github.com/users/mloning","html_url":"https://github.com/mloning","followers_url":"https://api.github.com/users/mloning/followers","following_url":"https://api.github.com/users/mloning/following{/other_user}","gists_url":"https://api.github.com/users/mloning/gists{/gist_id}","starred_url":"https://api.github.com/users/mloning/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mloning/subscriptions","organizations_url":"https://api.github.com/users/mloning/orgs","repos_url":"https://api.github.com/users/mloning/repos","events_url":"https://api.github.com/users/mloning/events{/privacy}","received_events_url":"https://api.github.com/users/mloning/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/104/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/104/timeline","performed_via_github_app":null,"state_reason":"completed"}