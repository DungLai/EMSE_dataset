{"url":"https://api.github.com/repos/sktime/sktime/issues/1526","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/1526/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/1526/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/1526/events","html_url":"https://github.com/sktime/sktime/issues/1526","id":1027662341,"node_id":"I_kwDOCVKAsc49QOIF","number":1526,"title":"[ENH] Add ability to time estimator methods","user":{"login":"RNKuhns","id":26907244,"node_id":"MDQ6VXNlcjI2OTA3MjQ0","avatar_url":"https://avatars.githubusercontent.com/u/26907244?v=4","gravatar_id":"","url":"https://api.github.com/users/RNKuhns","html_url":"https://github.com/RNKuhns","followers_url":"https://api.github.com/users/RNKuhns/followers","following_url":"https://api.github.com/users/RNKuhns/following{/other_user}","gists_url":"https://api.github.com/users/RNKuhns/gists{/gist_id}","starred_url":"https://api.github.com/users/RNKuhns/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/RNKuhns/subscriptions","organizations_url":"https://api.github.com/users/RNKuhns/orgs","repos_url":"https://api.github.com/users/RNKuhns/repos","events_url":"https://api.github.com/users/RNKuhns/events{/privacy}","received_events_url":"https://api.github.com/users/RNKuhns/received_events","type":"User","site_admin":false},"labels":[{"id":1118163264,"node_id":"MDU6TGFiZWwxMTE4MTYzMjY0","url":"https://api.github.com/repos/sktime/sktime/labels/feature%20request","name":"feature request","color":"38d191","default":false,"description":"New feature or request"}],"state":"open","locked":false,"assignee":{"login":"RNKuhns","id":26907244,"node_id":"MDQ6VXNlcjI2OTA3MjQ0","avatar_url":"https://avatars.githubusercontent.com/u/26907244?v=4","gravatar_id":"","url":"https://api.github.com/users/RNKuhns","html_url":"https://github.com/RNKuhns","followers_url":"https://api.github.com/users/RNKuhns/followers","following_url":"https://api.github.com/users/RNKuhns/following{/other_user}","gists_url":"https://api.github.com/users/RNKuhns/gists{/gist_id}","starred_url":"https://api.github.com/users/RNKuhns/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/RNKuhns/subscriptions","organizations_url":"https://api.github.com/users/RNKuhns/orgs","repos_url":"https://api.github.com/users/RNKuhns/repos","events_url":"https://api.github.com/users/RNKuhns/events{/privacy}","received_events_url":"https://api.github.com/users/RNKuhns/received_events","type":"User","site_admin":false},"assignees":[{"login":"RNKuhns","id":26907244,"node_id":"MDQ6VXNlcjI2OTA3MjQ0","avatar_url":"https://avatars.githubusercontent.com/u/26907244?v=4","gravatar_id":"","url":"https://api.github.com/users/RNKuhns","html_url":"https://github.com/RNKuhns","followers_url":"https://api.github.com/users/RNKuhns/followers","following_url":"https://api.github.com/users/RNKuhns/following{/other_user}","gists_url":"https://api.github.com/users/RNKuhns/gists{/gist_id}","starred_url":"https://api.github.com/users/RNKuhns/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/RNKuhns/subscriptions","organizations_url":"https://api.github.com/users/RNKuhns/orgs","repos_url":"https://api.github.com/users/RNKuhns/repos","events_url":"https://api.github.com/users/RNKuhns/events{/privacy}","received_events_url":"https://api.github.com/users/RNKuhns/received_events","type":"User","site_admin":false}],"milestone":null,"comments":2,"created_at":"2021-10-15T17:45:16Z","updated_at":"2021-10-16T12:08:22Z","closed_at":null,"author_association":"COLLABORATOR","active_lock_reason":null,"body":"**Is your feature request related to a problem? Please describe.**\r\n\r\nHaving the ability to measure run-time of different estimator methods would be useful for several reasons, including:\r\n\r\n- Making it easy for users to get an estimate of timings in the case that something like fit time is important to them\r\n- Allow users to understand the timings of individual pipeline components (as well as the total pipeline time)\r\n\r\nRight now you could use notebook cell magic to get timings for a particular method for a given estimator or pipeline. In the non-notebook case, a user could still get the timing of a specific method relatively easily. But this is difficult for composite functionality (a user could measure total time, but wouldn't be able to easily measure the time of the components in a pipeline).\r\n\r\n\r\n**Describe the solution you'd like**\r\n\r\nI'd like to see us add functionality to get the run time from estimator methods. A straight-forward approach would be to add functionality to the public base class methods that stores the start and end time for that method. This could then be retrieved by a new method (or property) that returns the difference between the times (it could take name of a method and return the times for that method).\r\n\r\nThe `time` module has `time.perf_counter()` and the difference in time between two calls seems like it could be used to measure the elapsed time of different methods. \r\n\r\nOne option is to alter the base classes directly with something like:\r\n\r\n```python\r\nimport time\r\nclass BaseObject:\r\n    ...\r\n    def _get_time(self):\r\n        return time.perf_counter()\r\n\r\nclass BaseForecaster:\r\n    \"\"\"This example shows just measuring fit/predict, but could be applied to update, etc.\r\n\r\n    The new attributes in a class would depend on the estimator type, e.g. expect\r\n    \"fit_time_\" and \"transform_time_\" for timing a transformer, etc.\r\n    \"\"\"\r\n    ...\r\n    def __init__(self, ...):\r\n        ... # usual stuff in __init__\r\n        self.fit_time_\r\n        self.predict_time_\r\n\r\n    def fit(self, ...):\r\n        st = self._get_time()\r\n        ... # the usual stuff that is in fit\r\n        self.fit_time_ = st - self._get_time()\r\n\r\n    def predict(self, ...):\r\n        st = self._get_time()\r\n        ... # the usual stuff that is in predict\r\n        self.predict_time_ = st - self._get_time()\r\n\r\n```\r\n\r\nAnother alternative is to try and figure out a decorator to add the attributes and the functionality in the public methods.\r\n\r\nGiven the functionality being added to the base classes, things like `ForecastingPipeline` could be updated to capture the total timings of different steps in the pipeline (Note for transformers the fit time for a given transformer would be fit + transform time within a pipeline, since both are called during pipeline fit). \r\n\r\n**Describe alternatives you've considered**\r\nThe alternative would be a more complex way of having some sort of wrapper (function, composite class, etc) that enabled this functionality. But not sure of the feasibility of getting the timings of the steps of a pipeline that way and it seems like a complex implementation relative to updateing the base classes. Plus carrying around the times in the base class shouldn't provide too much overhead in the base classes.\r\n\r\nAnother alternative is to just update things like `ForecastingPipeline` so that they store timings of each step in the pipeline. But provides less generality. \r\n\r\n**Additional context**\r\n\r\n","closed_by":null,"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/1526/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/1526/timeline","performed_via_github_app":null,"state_reason":null}