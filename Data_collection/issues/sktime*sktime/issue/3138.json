{"url":"https://api.github.com/repos/sktime/sktime/issues/3138","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/3138/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/3138/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/3138/events","html_url":"https://github.com/sktime/sktime/issues/3138","id":1323256036,"node_id":"I_kwDOCVKAsc5O30jk","number":3138,"title":"[BUG] test error in `RandomShapeletTransform`","user":{"login":"fkiraly","id":7985502,"node_id":"MDQ6VXNlcjc5ODU1MDI=","avatar_url":"https://avatars.githubusercontent.com/u/7985502?v=4","gravatar_id":"","url":"https://api.github.com/users/fkiraly","html_url":"https://github.com/fkiraly","followers_url":"https://api.github.com/users/fkiraly/followers","following_url":"https://api.github.com/users/fkiraly/following{/other_user}","gists_url":"https://api.github.com/users/fkiraly/gists{/gist_id}","starred_url":"https://api.github.com/users/fkiraly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fkiraly/subscriptions","organizations_url":"https://api.github.com/users/fkiraly/orgs","repos_url":"https://api.github.com/users/fkiraly/repos","events_url":"https://api.github.com/users/fkiraly/events{/privacy}","received_events_url":"https://api.github.com/users/fkiraly/received_events","type":"User","site_admin":false},"labels":[{"id":1118163262,"node_id":"MDU6TGFiZWwxMTE4MTYzMjYy","url":"https://api.github.com/repos/sktime/sktime/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"},{"id":3102418261,"node_id":"MDU6TGFiZWwzMTAyNDE4MjYx","url":"https://api.github.com/repos/sktime/sktime/labels/module:classification","name":"module:classification","color":"BEB114","default":false,"description":""},{"id":3105907331,"node_id":"MDU6TGFiZWwzMTA1OTA3MzMx","url":"https://api.github.com/repos/sktime/sktime/labels/module:transformations","name":"module:transformations","color":"0865AF","default":false,"description":""}],"state":"closed","locked":false,"assignee":{"login":"TonyBagnall","id":9594042,"node_id":"MDQ6VXNlcjk1OTQwNDI=","avatar_url":"https://avatars.githubusercontent.com/u/9594042?v=4","gravatar_id":"","url":"https://api.github.com/users/TonyBagnall","html_url":"https://github.com/TonyBagnall","followers_url":"https://api.github.com/users/TonyBagnall/followers","following_url":"https://api.github.com/users/TonyBagnall/following{/other_user}","gists_url":"https://api.github.com/users/TonyBagnall/gists{/gist_id}","starred_url":"https://api.github.com/users/TonyBagnall/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/TonyBagnall/subscriptions","organizations_url":"https://api.github.com/users/TonyBagnall/orgs","repos_url":"https://api.github.com/users/TonyBagnall/repos","events_url":"https://api.github.com/users/TonyBagnall/events{/privacy}","received_events_url":"https://api.github.com/users/TonyBagnall/received_events","type":"User","site_admin":false},"assignees":[{"login":"TonyBagnall","id":9594042,"node_id":"MDQ6VXNlcjk1OTQwNDI=","avatar_url":"https://avatars.githubusercontent.com/u/9594042?v=4","gravatar_id":"","url":"https://api.github.com/users/TonyBagnall","html_url":"https://github.com/TonyBagnall","followers_url":"https://api.github.com/users/TonyBagnall/followers","following_url":"https://api.github.com/users/TonyBagnall/following{/other_user}","gists_url":"https://api.github.com/users/TonyBagnall/gists{/gist_id}","starred_url":"https://api.github.com/users/TonyBagnall/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/TonyBagnall/subscriptions","organizations_url":"https://api.github.com/users/TonyBagnall/orgs","repos_url":"https://api.github.com/users/TonyBagnall/repos","events_url":"https://api.github.com/users/TonyBagnall/events{/privacy}","received_events_url":"https://api.github.com/users/TonyBagnall/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2022-07-30T18:26:27Z","updated_at":"2022-10-11T08:57:32Z","closed_at":"2022-10-11T08:57:32Z","author_association":"COLLABORATOR","active_lock_reason":null,"body":"Update: this is not sporadic but is also failing on `main`.\r\n\r\nUnclear what is causing this, but it started recently, and no changes to the estimator have been made so far. Will temporarily address this by an emergency merge.\r\n\r\n---\r\nSometimes, `RandomShapeletTransform` seems to create an empty list internally.\r\n\r\nTraceback from https://github.com/alan-turing-institute/sktime/runs/7593226866?check_suite_focus=true\r\n\r\n```\r\nself = RandomShapeletTransform(batch_size=20, max_shapelets=5, n_shapelet_samples=50)\r\nX = array([[[1.96618854, 1.33121008, 2.11716292, 2.99250424, 1.23532101,\r\n         1.23533743, 3.0486872 , 2.23690912, 1.        , 2.01203443]]])\r\ny = array([4, 3, 6, 8, 1, 2, 9, 7, 0, 5])\r\n\r\n    def _fit(self, X, y=None):\r\n        \"\"\"Fit the shapelet transform to a specified X and y.\r\n    \r\n        Parameters\r\n        ----------\r\n        X: pandas DataFrame or np.ndarray\r\n            The training input samples.\r\n        y: array-like or list\r\n            The class values for X.\r\n    \r\n        Returns\r\n        -------\r\n        self : RandomShapeletTransform\r\n            This estimator.\r\n        \"\"\"\r\n        # this is a few versions away currently, and heaps dont support the replacement\r\n        warnings.simplefilter(\"ignore\", category=NumbaPendingDeprecationWarning)\r\n    \r\n        self._n_jobs = check_n_jobs(self.n_jobs)\r\n    \r\n        self.classes_, self._class_counts = np.unique(y, return_counts=True)\r\n        self.n_classes = self.classes_.shape[0]\r\n        for index, classVal in enumerate(self.classes_):\r\n            self._class_dictionary[classVal] = index\r\n    \r\n        le = preprocessing.LabelEncoder()\r\n        y = le.fit_transform(y)\r\n    \r\n        self.n_instances, self.n_dims, self.series_length = X.shape\r\n    \r\n        if self.max_shapelets is None:\r\n            self._max_shapelets = min(10 * self.n_instances, 1000)\r\n    \r\n        if self.max_shapelet_length is None:\r\n            self._max_shapelet_length = self.series_length\r\n    \r\n        time_limit = self.time_limit_in_minutes * 60\r\n        start_time = time.time()\r\n        fit_time = 0\r\n    \r\n        max_shapelets_per_class = self._max_shapelets / self.n_classes\r\n        shapelets = [[(-1.0, -1, -1, -1, -1, -1)] for _ in range(self.n_classes)]\r\n        n_shapelets_extracted = 0\r\n    \r\n        if time_limit > 0:\r\n            while (\r\n                fit_time < time_limit\r\n                and n_shapelets_extracted < self.contract_max_n_shapelet_samples\r\n            ):\r\n                candidate_shapelets = Parallel(n_jobs=self._n_jobs)(\r\n                    delayed(self._extract_random_shapelet)(\r\n                        X,\r\n                        y,\r\n                        n_shapelets_extracted + i,\r\n                        shapelets,\r\n                        max_shapelets_per_class,\r\n                    )\r\n                    for i in range(self._batch_size)\r\n                )\r\n    \r\n                for i, heap in enumerate(shapelets):\r\n                    RandomShapeletTransform._merge_shapelets(\r\n                        heap,\r\n                        candidate_shapelets,\r\n                        max_shapelets_per_class,\r\n                        i,\r\n                    )\r\n    \r\n                if self.remove_self_similar:\r\n                    for i, heap in enumerate(shapelets):\r\n                        to_keep = (\r\n                            RandomShapeletTransform._remove_self_similar_shapelets(heap)\r\n                        )\r\n                        shapelets[i] = [n for (n, b) in zip(heap, to_keep) if b]\r\n    \r\n                n_shapelets_extracted += self._batch_size\r\n                fit_time = time.time() - start_time\r\n        else:\r\n            while n_shapelets_extracted < self._n_shapelet_samples:\r\n                n_shapelets_to_extract = (\r\n                    self._batch_size\r\n                    if n_shapelets_extracted + self._batch_size\r\n                    <= self._n_shapelet_samples\r\n                    else self._n_shapelet_samples - n_shapelets_extracted\r\n                )\r\n    \r\n                candidate_shapelets = Parallel(n_jobs=self._n_jobs)(\r\n                    delayed(self._extract_random_shapelet)(\r\n                        X,\r\n                        y,\r\n                        n_shapelets_extracted + i,\r\n                        shapelets,\r\n                        max_shapelets_per_class,\r\n                    )\r\n                    for i in range(n_shapelets_to_extract)\r\n                )\r\n    \r\n                for i, heap in enumerate(shapelets):\r\n                    RandomShapeletTransform._merge_shapelets(\r\n                        heap,\r\n                        candidate_shapelets,\r\n                        max_shapelets_per_class,\r\n                        i,\r\n                    )\r\n    \r\n                if self.remove_self_similar:\r\n                    for i, heap in enumerate(shapelets):\r\n                        to_keep = (\r\n                            RandomShapeletTransform._remove_self_similar_shapelets(heap)\r\n                        )\r\n                        shapelets[i] = [n for (n, b) in zip(heap, to_keep) if b]\r\n    \r\n                n_shapelets_extracted += n_shapelets_to_extract\r\n    \r\n        self.shapelets = [\r\n            (\r\n                s[0],\r\n                s[1],\r\n                s[2],\r\n                s[3],\r\n                s[4],\r\n                self.classes_[s[5]],\r\n                z_normalise_series(X[s[4], s[3], s[2] : s[2] + s[1]]),\r\n            )\r\n            for class_shapelets in shapelets\r\n            for s in class_shapelets\r\n            if s[0] > 0\r\n        ]\r\n        self.shapelets.sort(reverse=True, key=lambda s: (s[0], s[1], s[2], s[3], s[4]))\r\n    \r\n>       to_keep = RandomShapeletTransform._remove_identical_shapelets(self.shapelets)\r\nE       ValueError: cannot compute fingerprint of empty list\r\n\r\nX          = array([[[1.96618854, 1.33121008, 2.11716292, 2.99250424, 1.23532101,\r\n         1.23533743, 3.0486872 , 2.23690912, 1.        , 2.01203443]]])\r\ncandidate_shapelets = [(0.0, 9, 0, 0, 0, 4), (0.0, 6, 1, 0, 0, 4), (0.0, 9, 0, 0, 0, 4), (0.0, 5, 3, 0, 0, 4), (0.0, 9, 0, 0, 0, 4), (0.0, 4, 2, 0, 0, 4), ...]\r\nclassVal   = 3.048687201442344\r\nfit_time   = 0\r\nheap       = [(-1.0, -1, -1, -1, -1, -1)]\r\ni          = 9\r\nindex      = 9\r\nle         = LabelEncoder()\r\nmax_shapelets_per_class = 0.5\r\nn_shapelets_extracted = 50\r\nn_shapelets_to_extract = 10\r\nself       = RandomShapeletTransform(batch_size=20, max_shapelets=5, n_shapelet_samples=50)\r\nshapelets  = [[(-1.0, -1, -1, -1, -1, -1)], [(-1.0, -1, -1, -1, -1, -1)], [(-1.0, -1, -1, -1, -1, -1)], [(-1.0, -1, -1, -1, -1, -1)], [(-1.0, -1, -1, -1, -1, -1)], [(-1.0, -1, -1, -1, -1, -1)], ...]\r\nstart_time = 1659204964.8932788\r\ntime_limit = 0.0\r\nto_keep    = [True]\r\ny          = array([4, 3, 6, 8, 1, 2, 9, 7, 0, 5])\r\n```","closed_by":{"login":"MatthewMiddlehurst","id":25731235,"node_id":"MDQ6VXNlcjI1NzMxMjM1","avatar_url":"https://avatars.githubusercontent.com/u/25731235?v=4","gravatar_id":"","url":"https://api.github.com/users/MatthewMiddlehurst","html_url":"https://github.com/MatthewMiddlehurst","followers_url":"https://api.github.com/users/MatthewMiddlehurst/followers","following_url":"https://api.github.com/users/MatthewMiddlehurst/following{/other_user}","gists_url":"https://api.github.com/users/MatthewMiddlehurst/gists{/gist_id}","starred_url":"https://api.github.com/users/MatthewMiddlehurst/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/MatthewMiddlehurst/subscriptions","organizations_url":"https://api.github.com/users/MatthewMiddlehurst/orgs","repos_url":"https://api.github.com/users/MatthewMiddlehurst/repos","events_url":"https://api.github.com/users/MatthewMiddlehurst/events{/privacy}","received_events_url":"https://api.github.com/users/MatthewMiddlehurst/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/3138/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/3138/timeline","performed_via_github_app":null,"state_reason":"completed"}