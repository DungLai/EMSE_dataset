{"url":"https://api.github.com/repos/sktime/sktime/issues/2665","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/2665/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/2665/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/2665/events","html_url":"https://github.com/sktime/sktime/issues/2665","id":1242026053,"node_id":"I_kwDOCVKAsc5KB9BF","number":2665,"title":"[BUG] StackingForecaster doesn't work with exogenous factors the way normally users expect to feed the data","user":{"login":"indinewton","id":25198189,"node_id":"MDQ6VXNlcjI1MTk4MTg5","avatar_url":"https://avatars.githubusercontent.com/u/25198189?v=4","gravatar_id":"","url":"https://api.github.com/users/indinewton","html_url":"https://github.com/indinewton","followers_url":"https://api.github.com/users/indinewton/followers","following_url":"https://api.github.com/users/indinewton/following{/other_user}","gists_url":"https://api.github.com/users/indinewton/gists{/gist_id}","starred_url":"https://api.github.com/users/indinewton/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/indinewton/subscriptions","organizations_url":"https://api.github.com/users/indinewton/orgs","repos_url":"https://api.github.com/users/indinewton/repos","events_url":"https://api.github.com/users/indinewton/events{/privacy}","received_events_url":"https://api.github.com/users/indinewton/received_events","type":"User","site_admin":false},"labels":[{"id":1118163262,"node_id":"MDU6TGFiZWwxMTE4MTYzMjYy","url":"https://api.github.com/repos/sktime/sktime/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-05-19T16:25:52Z","updated_at":"2022-06-04T08:45:44Z","closed_at":"2022-06-04T08:45:44Z","author_association":"NONE","active_lock_reason":null,"body":"**Describe the bug**\r\n<!--\r\nA clear and concise description of what the bug is.\r\n-->\r\nStackingForecaster throws error during fit() when being used with forecasters which can handle exogenous variables.\r\n\r\n**To Reproduce**\r\n<!--\r\nAdd a Minimal, Complete, and Verifiable example (for more details, see e.g. https://stackoverflow.com/help/mcve\r\n\r\nIf the code is too long, feel free to put it in a public gist and link it in the issue: https://gist.github.com\r\n-->\r\n\r\n```python\r\nfrom sktime.forecasting.compose._stack import StackingForecaster\r\nfrom sktime.forecasting.compose._ensemble import AutoEnsembleForecaster\r\nfrom sktime.forecasting.naive import NaiveForecaster\r\nfrom sktime.forecasting.structural import UnobservedComponents\r\nfrom sktime.forecasting.ets import AutoETS\r\nfrom sktime.datasets import load_airline\r\nimport random\r\n\r\ny = load_airline()\r\n# create multivariate data\r\nr1 = pd.Series([random.randrange(-10,10) for i in range(len(y))])\r\nr2 = pd.Series([random.randrange(-20,20) for i in range(len(y))])\r\nr1.index = r2.index = y.index\r\nX = pd.DataFrame({\"y_1\": (y.copy() * 2) + r1, \"y_2\": y.copy() * 0.5 + r2})\r\ny_train, y_test, X_train, X_pred = temporal_train_test_split(y, X, test_size=12)\r\n\r\nfh = ForecastingHorizon(y_test.index, is_relative=False)\r\n\r\nforecasters = [\r\n    (\"arima\", AutoARIMA(sp=12)),\r\n    (\"ets\", UnobservedComponents(seasonal=12))\r\n]\r\n\r\nfc1 = StackingForecaster(forecasters=forecasters)\r\n\r\nfc1.fit(y=y_train, X=X_train, fh=list(range(1, len(fh)+1)))\r\nfc1.predict(fh=fh, X=X_pred)\r\n```\r\n\r\n**Error returned**\r\n```python\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\n~/local/errata_univariate.py in <module>\r\n     23 fc1 = StackingForecaster(forecasters=forecasters)\r\n     24 \r\n---> 25 fc1.fit(y=y_train, X=X_train, fh=list(range(1, len(fh)+1)))\r\n     26 fc1.predict(fh=fh, X=X_pred)\r\n\r\n~/work/sktime/sktime/forecasting/base/_base.py in fit(self, y, X, fh)\r\n    161         # we call the ordinary _fit if no looping/vectorization needed\r\n    162         if not vectorization_needed:\r\n--> 163             self._fit(y=y_inner, X=X_inner, fh=fh)\r\n    164         else:\r\n    165             # otherwise we call the vectorized version of fit\r\n\r\n~/work/sktime/sktime/forecasting/compose/_stack.py in _fit(self, y, X, fh)\r\n    108 \r\n    109         # fit forecasters on training window\r\n--> 110         self._fit_forecasters(forecasters, y_fcst, fh=fh, X=X)\r\n    111         X_meta = np.column_stack(self._predict_forecasters(fh=fh, X=X_meta))\r\n    112 \r\n\r\n~/work/sktime/sktime/forecasting/base/_meta.py in _fit_forecasters(self, forecasters, y, X, fh)\r\n     66         self.forecasters_ = Parallel(n_jobs=self.n_jobs)(\r\n     67             delayed(_fit_forecaster)(clone(forecaster), y, X, fh)\r\n---> 68             for forecaster in forecasters\r\n     69         )\r\n     70 \r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/joblib/parallel.py in __call__(self, iterable)\r\n   1041             # remaining jobs.\r\n   1042             self._iterating = False\r\n-> 1043             if self.dispatch_one_batch(iterator):\r\n   1044                 self._iterating = self._original_iterator is not None\r\n   1045 \r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/joblib/parallel.py in dispatch_one_batch(self, iterator)\r\n    859                 return False\r\n    860             else:\r\n--> 861                 self._dispatch(tasks)\r\n    862                 return True\r\n    863 \r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/joblib/parallel.py in _dispatch(self, batch)\r\n    777         with self._lock:\r\n    778             job_idx = len(self._jobs)\r\n--> 779             job = self._backend.apply_async(batch, callback=cb)\r\n    780             # A job can complete so quickly than its callback is\r\n    781             # called before we get here, causing self._jobs to\r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/joblib/_parallel_backends.py in apply_async(self, func, callback)\r\n    206     def apply_async(self, func, callback=None):\r\n    207         \"\"\"Schedule a func to be run\"\"\"\r\n--> 208         result = ImmediateResult(func)\r\n    209         if callback:\r\n    210             callback(result)\r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/joblib/_parallel_backends.py in __init__(self, batch)\r\n    570         # Don't delay the application, to avoid keeping the input\r\n    571         # arguments in memory\r\n--> 572         self.results = batch()\r\n    573 \r\n    574     def get(self):\r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/joblib/parallel.py in __call__(self)\r\n    261         with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n    262             return [func(*args, **kwargs)\r\n--> 263                     for func, args, kwargs in self.items]\r\n    264 \r\n    265     def __reduce__(self):\r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/joblib/parallel.py in <listcomp>(.0)\r\n    261         with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n    262             return [func(*args, **kwargs)\r\n--> 263                     for func, args, kwargs in self.items]\r\n    264 \r\n    265     def __reduce__(self):\r\n\r\n~/work/sktime/sktime/forecasting/base/_meta.py in _fit_forecaster(forecaster, y, X, fh)\r\n     62         def _fit_forecaster(forecaster, y, X, fh):\r\n     63             \"\"\"Fit single forecaster.\"\"\"\r\n---> 64             return forecaster.fit(y, X, fh)\r\n     65 \r\n     66         self.forecasters_ = Parallel(n_jobs=self.n_jobs)(\r\n\r\n~/work/sktime/sktime/forecasting/base/_base.py in fit(self, y, X, fh)\r\n    161         # we call the ordinary _fit if no looping/vectorization needed\r\n    162         if not vectorization_needed:\r\n--> 163             self._fit(y=y_inner, X=X_inner, fh=fh)\r\n    164         else:\r\n    165             # otherwise we call the vectorized version of fit\r\n\r\n~/work/sktime/sktime/forecasting/base/adapters/_pmdarima.py in _fit(self, y, X, fh, **fit_params)\r\n     47         \"\"\"\r\n     48         self._forecaster = self._instantiate_model()\r\n---> 49         self._forecaster.fit(y, X=X, **fit_params)\r\n     50         return self\r\n     51 \r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/pmdarima/arima/auto.py in fit(self, y, X, **fit_args)\r\n    218             with_intercept=self.with_intercept,\r\n    219             sarimax_kwargs=sarimax_kwargs,\r\n--> 220             **fit_args)\r\n    221 \r\n    222         return self\r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/pmdarima/arima/auto.py in auto_arima(y, X, start_p, d, start_q, max_p, max_d, max_q, start_P, D, start_Q, max_P, max_D, max_Q, max_order, m, seasonal, stationary, information_criterion, alpha, test, seasonal_test, stepwise, n_jobs, start_params, trend, method, maxiter, offset_test_args, seasonal_test_args, suppress_warnings, error_action, trace, random, random_state, n_fits, return_valid_fits, out_of_sample_size, scoring, scoring_args, with_intercept, sarimax_kwargs, **fit_args)\r\n    507     xx = y.copy()\r\n    508     if X is not None:\r\n--> 509         lm = LinearRegression().fit(X, y)\r\n    510         xx = y - lm.predict(X)\r\n    511 \r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/sklearn/linear_model/_base.py in fit(self, X, y, sample_weight)\r\n    661 \r\n    662         X, y = self._validate_data(\r\n--> 663             X, y, accept_sparse=accept_sparse, y_numeric=True, multi_output=True\r\n    664         )\r\n    665 \r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/sklearn/base.py in _validate_data(self, X, y, reset, validate_separately, **check_params)\r\n    579                 y = check_array(y, **check_y_params)\r\n    580             else:\r\n--> 581                 X, y = check_X_y(X, y, **check_params)\r\n    582             out = X, y\r\n    583 \r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/sklearn/utils/validation.py in check_X_y(X, y, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, ensure_2d, allow_nd, multi_output, ensure_min_samples, ensure_min_features, y_numeric, estimator)\r\n    979     y = _check_y(y, multi_output=multi_output, y_numeric=y_numeric)\r\n    980 \r\n--> 981     check_consistent_length(X, y)\r\n    982 \r\n    983     return X, y\r\n\r\n~/opt/miniconda3/envs/chronos_dev2/lib/python3.7/site-packages/sklearn/utils/validation.py in check_consistent_length(*arrays)\r\n    332         raise ValueError(\r\n    333             \"Found input variables with inconsistent numbers of samples: %r\"\r\n--> 334             % [int(l) for l in lengths]\r\n    335         )\r\n    336 \r\n\r\nValueError: Found input variables with inconsistent numbers of samples: [132, 120]\r\n```\r\n\r\n**Expected behavior**\r\n<!--\r\nA clear and concise description of what you expected to happen.\r\n-->\r\n\r\n**Additional context**\r\n<!--\r\nAdd any other context about the problem here.\r\n-->\r\nError is happening probably because of this line (as commendted) in the code below; source `sktime/sktime/forecasting/compose/_stack.py`:\r\n\r\n**please read the comments with double hash, those were raised by me as question or advice.**\r\n\r\n```python\r\ndef _fit(self, y, X=None, fh=None):\r\n        \"\"\"Fit to training data.\r\n        Parameters\r\n        ----------\r\n        y : pd.Series\r\n            Target time series to which to fit the forecaster.\r\n        fh : int, list or np.array, optional (default=None)\r\n            The forecasters horizon with the steps ahead to to predict.\r\n        X : pd.DataFrame, optional (default=None)\r\n            Exogenous variables are ignored\r\n        Returns\r\n        -------\r\n        self : returns an instance of self.\r\n        \"\"\"\r\n        _, forecasters = self._check_forecasters()\r\n        self.regressor_ = check_regressor(\r\n            regressor=self.regressor, random_state=self.random_state\r\n        )\r\n\r\n        # split training series into training set to fit forecasters and\r\n        # validation set to fit meta-learner\r\n        cv = SingleWindowSplitter(fh=fh.to_relative(self.cutoff))\r\n        train_window, test_window = next(cv.split(y))\r\n        y_fcst = y.iloc[train_window]   ## why call this y_fcst is it is y_train??\r\n        y_meta = y.iloc[test_window].values\r\n        if X is not None:\r\n            X_meta = X.iloc[test_window]    ## X_train should also be created; here only test set is created\r\n        else:\r\n            X_meta = None\r\n\r\n        # fit forecasters on training window\r\n        ## ERROR as index of y_fcst does not match with X, here X_train should be passed\r\n        self._fit_forecasters(forecasters, y_fcst, fh=fh, X=X)     \r\n        ## ISn't it misleading to call this X_meta, as you are actually getting forecast of y, not X.\r\n        X_meta = np.column_stack(self._predict_forecasters(fh=fh, X=X_meta))\r\n\r\n        # fit final regressor on on validation window\r\n        self.regressor_.fit(X_meta, y_meta)    ## same here X_meta should renamed to like y_fcst or y_pred\r\n\r\n        # refit forecasters on entire training series\r\n        self._fit_forecasters(forecasters, y, fh=self.fh, X=X)\r\n\r\n        return self\r\n```\r\n\r\n\r\n**Versions**\r\n<details>\r\n\r\n<!--\r\nPlease run the following code snippet and paste the output here:\r\n \r\nfrom sktime import show_versions; show_versions()\r\n-->\r\n\r\n</details>\r\n\r\n<!-- Thanks for contributing! -->\r\n","closed_by":{"login":"fkiraly","id":7985502,"node_id":"MDQ6VXNlcjc5ODU1MDI=","avatar_url":"https://avatars.githubusercontent.com/u/7985502?v=4","gravatar_id":"","url":"https://api.github.com/users/fkiraly","html_url":"https://github.com/fkiraly","followers_url":"https://api.github.com/users/fkiraly/followers","following_url":"https://api.github.com/users/fkiraly/following{/other_user}","gists_url":"https://api.github.com/users/fkiraly/gists{/gist_id}","starred_url":"https://api.github.com/users/fkiraly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fkiraly/subscriptions","organizations_url":"https://api.github.com/users/fkiraly/orgs","repos_url":"https://api.github.com/users/fkiraly/repos","events_url":"https://api.github.com/users/fkiraly/events{/privacy}","received_events_url":"https://api.github.com/users/fkiraly/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/2665/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/2665/timeline","performed_via_github_app":null,"state_reason":"completed"}