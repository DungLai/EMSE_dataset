{"url":"https://api.github.com/repos/sktime/sktime/issues/2658","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/2658/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/2658/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/2658/events","html_url":"https://github.com/sktime/sktime/issues/2658","id":1239964480,"node_id":"I_kwDOCVKAsc5J6FtA","number":2658,"title":"[BUG] ColumnwiseTransformer for Exogneous Forecast returns error during inverse_transform() call triggered from predict() method in pipeline","user":{"login":"indinewton","id":25198189,"node_id":"MDQ6VXNlcjI1MTk4MTg5","avatar_url":"https://avatars.githubusercontent.com/u/25198189?v=4","gravatar_id":"","url":"https://api.github.com/users/indinewton","html_url":"https://github.com/indinewton","followers_url":"https://api.github.com/users/indinewton/followers","following_url":"https://api.github.com/users/indinewton/following{/other_user}","gists_url":"https://api.github.com/users/indinewton/gists{/gist_id}","starred_url":"https://api.github.com/users/indinewton/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/indinewton/subscriptions","organizations_url":"https://api.github.com/users/indinewton/orgs","repos_url":"https://api.github.com/users/indinewton/repos","events_url":"https://api.github.com/users/indinewton/events{/privacy}","received_events_url":"https://api.github.com/users/indinewton/received_events","type":"User","site_admin":false},"labels":[{"id":1118163262,"node_id":"MDU6TGFiZWwxMTE4MTYzMjYy","url":"https://api.github.com/repos/sktime/sktime/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2022-05-18T13:25:25Z","updated_at":"2022-05-20T12:55:25Z","closed_at":"2022-05-20T12:40:45Z","author_association":"NONE","active_lock_reason":null,"body":"**Describe the bug**\r\n<!--\r\nA clear and concise description of what the bug is.\r\n-->\r\nTypically ColumnwiseTransformer should work regardless whether y is pd.Series or pd.DataFrame. But when tried with different scenario as explained below in \"To Reproduce\" section, it seems during inverse_transform() method call from fitted ColumnwiseTransformer instance - it is looking for column names of y_pred to match exactly as it was fed for y_train. The issue is strictly with how inverse_transform() deals with fitted transformer on Y_pred returned from forecasters. \r\n\r\n**To Reproduce**\r\n<!--\r\nAdd a Minimal, Complete, and Verifiable example (for more details, see e.g. https://stackoverflow.com/help/mcve\r\n\r\nIf the code is too long, feel free to put it in a public gist and link it in the issue: https://gist.github.com\r\n-->\r\n_**Note** that in all the pipeline examples below, error occurs only during predict() call because only predict() calls inverse_transform() method of individual transformers if there are any in the pipeline. Also note that in ForecastingPipeline, the tranformers are applied only on X and not on Y, so inverse_transform method is not called in this case as there is no Transformer for y. But this changes when TransformedTargetForecaster is used in the ForecastingPipeline._\r\n\r\nData preparation for Univariate exogenous forecasting \r\n```python\r\nfrom sktime.datasets import load_airline\r\nfrom sktime.forecasting.base import ForecastingHorizon\r\nfrom sktime.forecasting.model_selection import temporal_train_test_split\r\nfrom sktime.forecasting.compose import TransformedTargetForecaster, ForecastingPipeline\r\nfrom sktime.forecasting.arima import AutoARIMA\r\nfrom sktime.transformations.series.impute import Imputer\r\nfrom sktime.transformations.series.boxcox import LogTransformer\r\nfrom sktime.forecasting.structural import UnobservedComponents\r\nfrom sktime.transformations.series.compose import ColumnwiseTransformer\r\n\r\nimport random\r\nimport pandas as pd\r\n\r\ny = load_airline()\r\n\r\n# create multivariate data\r\nr1 = pd.Series([random.randrange(-10,10) for i in range(len(y))])\r\nr2 = pd.Series([random.randrange(-20,20) for i in range(len(y))])\r\nr1.index = r2.index = y.index\r\nX = pd.DataFrame({\"y_1\": (y.copy() * 2) + r1, \"y_2\": y.copy() * 0.5 + r2})\r\ny_train, y_test, X_train, X_pred = temporal_train_test_split(y, X, test_size=12)\r\n\r\nfh = ForecastingHorizon(y_test.index, is_relative=False)\r\n```\r\n\r\nScenario 1: For a vanilla example of univariate forecasting with exogenous factors\r\n```python\r\npipe1 = ForecastingPipeline(steps=[\r\n    (\"cwt\", ColumnwiseTransformer(Imputer())),\r\n    (\"forecaster\", AutoARIMA(sp=12))\r\n])\r\npipe1.fit(y_train, X=X_train)\r\npipe1.predict(fh=fh, X=X_pred)\r\n```\r\nReturns:\r\n```python\r\n1960-01    412.927673\r\n1960-02    393.912075\r\n1960-03    416.534804\r\n1960-04    459.789576\r\n1960-05    472.009280\r\n1960-06    530.654619\r\n1960-07    624.837383\r\n1960-08    606.336732\r\n1960-09    511.079947\r\n1960-10    464.982139\r\n1960-11    385.299502\r\n1960-12    435.406159\r\nFreq: M, dtype: float64\r\n```\r\n\r\nScenario 2: When AutoARIMA is wrapped under TransformedTargetForecaster while retaining y_train as pd.Series\r\n\r\n```python\r\nforecast_pipe = TransformedTargetForecaster(steps=[\r\n    (\"cwt_y\", ColumnwiseTransformer(LogTransformer())),\r\n    (\"forecaster_y\", AutoARIMA(sp=12))\r\n])\r\n\r\npipe2 = ForecastingPipeline(steps=[\r\n    (\"cwt\", ColumnwiseTransformer(Imputer())),\r\n    (\"forecaster\", forecast_pipe)\r\n])\r\n\r\npipe2.fit(y_train, X=X_train)   # fit works\r\npipe2.predict(fh=fh, X=X_pred)   # this throws error as shown below\r\n```\r\nReturns:\r\n```python\r\n~/work/sktime/sktime/forecasting/base/_base.py in predict(self, fh, X)\r\n    212         # we call the ordinary _predict if no looping/vectorization needed\r\n    213         if not self._is_vectorized:\r\n--> 214             y_pred = self._predict(fh=fh, X=X_inner)\r\n    215         else:\r\n    216             # otherwise we call the vectorized version of predict\r\n\r\n~/work/sktime/sktime/forecasting/compose/_pipeline.py in _predict(self, fh, X)\r\n    271                 X = transformer.transform(X=X)\r\n    272 \r\n--> 273         return forecaster.predict(fh, X)\r\n    274 \r\n    275     def _update(self, y, X=None, update_params=True):\r\n\r\n~/work/sktime/sktime/forecasting/base/_base.py in predict(self, fh, X)\r\n    212         # we call the ordinary _predict if no looping/vectorization needed\r\n    213         if not self._is_vectorized:\r\n--> 214             y_pred = self._predict(fh=fh, X=X_inner)\r\n    215         else:\r\n    216             # otherwise we call the vectorized version of predict\r\n\r\n~/work/sktime/sktime/forecasting/compose/_pipeline.py in _predict(self, fh, X)\r\n    408         y_pred = forecaster.predict(fh=fh, X=X)\r\n    409         # inverse transform y_pred\r\n--> 410         y_pred = self._get_inverse_transform(y_pred, X)\r\n    411         return y_pred\r\n    412 \r\n\r\n~/work/sktime/sktime/forecasting/compose/_pipeline.py in _get_inverse_transform(self, y, X)\r\n     96             skip_trafo = transformer.get_tag(\"skip-inverse-transform\", False)\r\n     97             if not skip_trafo:\r\n---> 98                 y = transformer.inverse_transform(y, X)\r\n     99         return y\r\n    100 \r\n\r\n~/work/sktime/sktime/transformations/base.py in inverse_transform(self, X, y)\r\n    471 \r\n    472         if not isinstance(X_inner, VectorizedDF):\r\n--> 473             Xt = self._inverse_transform(X=X_inner, y=y_inner)\r\n    474         else:\r\n    475             # otherwise we call the vectorized version of predict\r\n\r\n~/work/sktime/sktime/transformations/series/compose.py in _inverse_transform(self, X, y)\r\n    346 \r\n    347         # make sure z contains all columns that the user wants to transform\r\n--> 348         _check_columns(X, selected_columns=self.columns_)\r\n    349 \r\n    350         # iterate over columns that are supposed to be inverse_transformed\r\n\r\n~/work/sktime/sktime/transformations/series/compose.py in _check_columns(z, selected_columns)\r\n    407     difference = z_wanted_keys.difference(z_new_keys)\r\n    408     if len(difference) != 0:\r\n--> 409         raise ValueError(\"Missing columns\" + str(difference) + \"in Z.\")\r\n    410 \r\n    411 \r\n\r\nValueError: Missing columns{'Number of airline passengers'}in Z.\r\n```\r\n\r\nScenario 3: A quick fix is convert y_train to a pd.DataFrame object; and then it works\r\n```python\r\ny_train_2 = pd.DataFrame(y_train)\r\n\r\nforecast_pipe = TransformedTargetForecaster(steps=[\r\n    (\"cwt_y\", ColumnwiseTransformer(LogTransformer())),\r\n    (\"forecaster_y\", AutoARIMA(sp=12))\r\n])\r\n\r\npipe3 = ForecastingPipeline(steps=[\r\n    (\"cwt\", ColumnwiseTransformer(Imputer())),\r\n    (\"forecaster\", forecast_pipe)\r\n])\r\n\r\npipe3.fit(y_train_2, X=X_train)\r\npipe3.predict(fh=fh, X=X_pred)\r\n```\r\n\r\nReturns: y_pred as dataframe output\r\n```python\r\n\tNumber of airline passengers\r\n1960-01\t410.709179\r\n1960-02\t394.710957\r\n1960-03\t412.382843\r\n1960-04\t468.075964\r\n1960-05\t480.335405\r\n1960-06\t549.841338\r\n1960-07\t671.774150\r\n1960-08\t643.227276\r\n1960-09\t531.132775\r\n1960-10\t471.929581\r\n1960-11\t378.512551\r\n1960-12\t434.700619\r\n```\r\n\r\nScenario 4: But even the fix found in scenario 3 does not work with Forecasters which add name for the predictions returned like the way UnobservedComponents returns prediction in series form with name \"predicted_means\" or something like that.\r\n```python\r\nforecast_pipe2 = TransformedTargetForecaster(steps=[\r\n    (\"cwt_y\", ColumnwiseTransformer(LogTransformer())),\r\n    (\"forecaster_y\", UnobservedComponents(seasonal=12))\r\n])\r\n\r\npipe4 = ForecastingPipeline(steps=[\r\n    (\"cwt\", ColumnwiseTransformer(Imputer())),\r\n    (\"forecaster\", forecast_pipe2)\r\n])\r\n\r\npipe4.fit(y_train_2, X=X_train)   # y_train_2 has been defined above in scenario 3 code example\r\n\r\npipe4.predict(fh=fh, X=X_pred)\r\n```\r\nReturns:\r\n```python\r\n~/work/sktime/sktime/forecasting/base/_base.py in predict(self, fh, X)\r\n    212         # we call the ordinary _predict if no looping/vectorization needed\r\n    213         if not self._is_vectorized:\r\n--> 214             y_pred = self._predict(fh=fh, X=X_inner)\r\n    215         else:\r\n    216             # otherwise we call the vectorized version of predict\r\n\r\n~/work/sktime/sktime/forecasting/compose/_pipeline.py in _predict(self, fh, X)\r\n    271                 X = transformer.transform(X=X)\r\n    272 \r\n--> 273         return forecaster.predict(fh, X)\r\n    274 \r\n    275     def _update(self, y, X=None, update_params=True):\r\n\r\n~/work/sktime/sktime/forecasting/base/_base.py in predict(self, fh, X)\r\n    212         # we call the ordinary _predict if no looping/vectorization needed\r\n    213         if not self._is_vectorized:\r\n--> 214             y_pred = self._predict(fh=fh, X=X_inner)\r\n    215         else:\r\n    216             # otherwise we call the vectorized version of predict\r\n\r\n~/work/sktime/sktime/forecasting/compose/_pipeline.py in _predict(self, fh, X)\r\n    408         y_pred = forecaster.predict(fh=fh, X=X)\r\n    409         # inverse transform y_pred\r\n--> 410         y_pred = self._get_inverse_transform(y_pred, X)\r\n    411         return y_pred\r\n    412 \r\n\r\n~/work/sktime/sktime/forecasting/compose/_pipeline.py in _get_inverse_transform(self, y, X)\r\n     96             skip_trafo = transformer.get_tag(\"skip-inverse-transform\", False)\r\n     97             if not skip_trafo:\r\n---> 98                 y = transformer.inverse_transform(y, X)\r\n     99         return y\r\n    100 \r\n\r\n~/work/sktime/sktime/transformations/base.py in inverse_transform(self, X, y)\r\n    471 \r\n    472         if not isinstance(X_inner, VectorizedDF):\r\n--> 473             Xt = self._inverse_transform(X=X_inner, y=y_inner)\r\n    474         else:\r\n    475             # otherwise we call the vectorized version of predict\r\n\r\n~/work/sktime/sktime/transformations/series/compose.py in _inverse_transform(self, X, y)\r\n    346 \r\n    347         # make sure z contains all columns that the user wants to transform\r\n--> 348         _check_columns(X, selected_columns=self.columns_)\r\n    349 \r\n    350         # iterate over columns that are supposed to be inverse_transformed\r\n\r\n~/work/sktime/sktime/transformations/series/compose.py in _check_columns(z, selected_columns)\r\n    407     difference = z_wanted_keys.difference(z_new_keys)\r\n    408     if len(difference) != 0:\r\n--> 409         raise ValueError(\"Missing columns\" + str(difference) + \"in Z.\")\r\n    410 \r\n    411 \r\n\r\nValueError: Missing columns{0}in Z.\r\n```\r\n\r\n**Expected behavior**\r\n<!--\r\nA clear and concise description of what you expected to happen.\r\n-->\r\nFor the erroneous cases, ColumnwiseTransformer should be able to handle it automatically;\r\n\r\n**Additional context**\r\n<!--\r\nAdd any other context about the problem here.\r\n-->\r\nA probable idea to fix the errors would be to look based on index of column instead of names of strings - because during the pipeline calls index of column remains unchanged. But that also means that internally all the pd.Series have to be converted to pd.DataFrame - which I don't think is a huge issue.\r\n\r\nAdditionally, the output should retain names as fed in y_train (if it exists); This should be fixed for UnobservedComponents forecaster object.\r\n\r\n**Versions**\r\n<details>\r\nSystem:\r\n    python: 3.7.13 (default, Mar 28 2022, 07:24:34)  [Clang 12.0.0 ]\r\nexecutable: ./miniconda3/envs/chronos_dev2/bin/python\r\n   machine: Darwin-21.4.0-x86_64-i386-64bit\r\n\r\nPython dependencies:\r\n          pip: 21.2.2\r\n   setuptools: 58.0.4\r\n      sklearn: 1.0.2\r\n       sktime: 0.11.0\r\n  statsmodels: 0.12.1\r\n        numpy: 1.21.5\r\n        scipy: 1.7.3\r\n       pandas: 1.3.5\r\n   matplotlib: 3.5.1\r\n       joblib: 1.1.0\r\n        numba: 0.55.1\r\n     pmdarima: 1.8.5\r\n      tsfresh: None\r\n<!--\r\nPlease run the following code snippet and paste the output here:\r\n \r\nfrom sktime import show_versions; show_versions()\r\n-->\r\n\r\n</details>\r\n\r\n<!-- Thanks for contributing! -->\r\n","closed_by":{"login":"aiwalter","id":29627036,"node_id":"MDQ6VXNlcjI5NjI3MDM2","avatar_url":"https://avatars.githubusercontent.com/u/29627036?v=4","gravatar_id":"","url":"https://api.github.com/users/aiwalter","html_url":"https://github.com/aiwalter","followers_url":"https://api.github.com/users/aiwalter/followers","following_url":"https://api.github.com/users/aiwalter/following{/other_user}","gists_url":"https://api.github.com/users/aiwalter/gists{/gist_id}","starred_url":"https://api.github.com/users/aiwalter/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aiwalter/subscriptions","organizations_url":"https://api.github.com/users/aiwalter/orgs","repos_url":"https://api.github.com/users/aiwalter/repos","events_url":"https://api.github.com/users/aiwalter/events{/privacy}","received_events_url":"https://api.github.com/users/aiwalter/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/2658/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/2658/timeline","performed_via_github_app":null,"state_reason":"completed"}