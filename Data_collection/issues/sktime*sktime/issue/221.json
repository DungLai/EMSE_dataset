{"url":"https://api.github.com/repos/sktime/sktime/issues/221","repository_url":"https://api.github.com/repos/sktime/sktime","labels_url":"https://api.github.com/repos/sktime/sktime/issues/221/labels{/name}","comments_url":"https://api.github.com/repos/sktime/sktime/issues/221/comments","events_url":"https://api.github.com/repos/sktime/sktime/issues/221/events","html_url":"https://github.com/sktime/sktime/issues/221","id":556749509,"node_id":"MDU6SXNzdWU1NTY3NDk1MDk=","number":221,"title":"[BUG] rise.fit fails with \"x contains a constant. Adding a constant with trend='c' is not allowed.\"","user":{"login":"tohinai","id":34362780,"node_id":"MDQ6VXNlcjM0MzYyNzgw","avatar_url":"https://avatars.githubusercontent.com/u/34362780?v=4","gravatar_id":"","url":"https://api.github.com/users/tohinai","html_url":"https://github.com/tohinai","followers_url":"https://api.github.com/users/tohinai/followers","following_url":"https://api.github.com/users/tohinai/following{/other_user}","gists_url":"https://api.github.com/users/tohinai/gists{/gist_id}","starred_url":"https://api.github.com/users/tohinai/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tohinai/subscriptions","organizations_url":"https://api.github.com/users/tohinai/orgs","repos_url":"https://api.github.com/users/tohinai/repos","events_url":"https://api.github.com/users/tohinai/events{/privacy}","received_events_url":"https://api.github.com/users/tohinai/received_events","type":"User","site_admin":false},"labels":[{"id":1118163262,"node_id":"MDU6TGFiZWwxMTE4MTYzMjYy","url":"https://api.github.com/repos/sktime/sktime/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2020-01-29T09:50:34Z","updated_at":"2020-01-30T13:23:50Z","closed_at":"2020-01-30T13:23:50Z","author_association":"NONE","active_lock_reason":null,"body":"**Describe the bug**\r\n<!--\r\nA clear and concise description of what the bug is.\r\n-->\r\nrise.fit fails with error.\r\n**To Reproduce**\r\n<!--\r\nAdd a Minimal, Complete, and Verifiable example (for more details, see e.g. \r\nhttps://stackoverflow.com/help/mcve\r\n\r\nIf the code is too long, feel free to put it in a public gist and link\r\nit in the issue: https://gist.github.com\r\n-->\r\n\r\n```python\r\nfrom sktime.transformers.compose import RowwiseTransformer\r\nfrom sktime.transformers.compose import Tabulariser\r\nfrom sktime.transformers.segment import RandomIntervalSegmenter\r\nfrom sktime.pipeline import Pipeline\r\nfrom sktime.pipeline import FeatureUnion\r\nfrom sktime.classifiers.compose import TimeSeriesForestClassifier\r\nfrom sktime.datasets import load_gunpoint\r\nfrom statsmodels.tsa.stattools import acf\r\nfrom statsmodels.tsa.ar_model import AR\r\nfrom sklearn.preprocessing import FunctionTransformer\r\nfrom sklearn.tree import DecisionTreeClassifier\r\nimport numpy as np\r\n\r\nX_train, y_train = load_gunpoint(split='TRAIN', return_X_y=True)\r\nX_test, y_test = load_gunpoint(split='TEST', return_X_y=True)\r\n\r\ndef ar_coefs(x, maxlag=100):\r\n    x = np.asarray(x).ravel()\r\n    nlags = np.minimum(len(x) - 1, maxlag)\r\n    model = AR(endog=x) \r\n    return model.fit(maxlag=nlags).params.ravel()\r\n\r\ndef acf_coefs(x, maxlag=100):\r\n    x = np.asarray(x).ravel() \r\n    nlags = np.minimum(len(x) - 1, maxlag)\r\n    return acf(x, nlags=nlags).ravel()\r\n\r\ndef powerspectrum(x, **kwargs):\r\n    x = np.asarray(x).ravel()\r\n    fft = np.fft.fft(x)\r\n    ps = fft.real * fft.real + fft.imag * fft.imag\r\n    return ps[:ps.shape[0] // 2].ravel()\r\n\r\nsteps = [\r\n    ('segment', RandomIntervalSegmenter(n_intervals=1, min_length=5)),\r\n    ('transform', FeatureUnion([\r\n        ('ar', RowwiseTransformer(FunctionTransformer(func=ar_coefs, validate=False))),\r\n        ('acf', RowwiseTransformer(FunctionTransformer(func=acf_coefs, validate=False))),\r\n        ('ps', RowwiseTransformer(FunctionTransformer(func=powerspectrum, validate=False)))\r\n    ])),\r\n    ('tabularise', Tabulariser()),\r\n    ('clf', DecisionTreeClassifier())\r\n]\r\nbase_estimator = Pipeline(steps)\r\n\r\nrise = TimeSeriesForestClassifier(base_estimator=base_estimator,\r\n                                  n_estimators=50, \r\n                                  bootstrap=True,\r\n                                  oob_score=True)\r\n\r\nrise.fit(X_train, y_train)\r\nif rise.oob_score:\r\n    print(rise.oob_score_)\r\n\r\n# ---------------------------------------------------------------------------\r\n# ValueError                                Traceback (most recent call last)\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sktime/transformers/compose.py in _apply_rowwise(self, func, X, y)\r\n#     235             Xt = pd.concat([pd.Series(col.apply(func))\r\n# --> 236                             for _, col in X.items()], axis=1)\r\n#     237 \r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sktime/transformers/compose.py in <listcomp>(.0)\r\n#     235             Xt = pd.concat([pd.Series(col.apply(func))\r\n# --> 236                             for _, col in X.items()], axis=1)\r\n#     237 \r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/pandas/core/series.py in apply(self, func, convert_dtype, args, **kwds)\r\n#    4044                 values = self.astype(object).values\r\n# -> 4045                 mapped = lib.map_infer(values, f, convert=convert_dtype)\r\n#    4046 \r\n\r\n# pandas/_libs/lib.pyx in pandas._libs.lib.map_infer()\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sklearn/base.py in fit_transform(self, X, y, **fit_params)\r\n#     552             # fit method of arity 1 (unsupervised transformation)\r\n# --> 553             return self.fit(X, **fit_params).transform(X)\r\n#     554         else:\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sklearn/preprocessing/_function_transformer.py in transform(self, X)\r\n#     152         \"\"\"\r\n# --> 153         return self._transform(X, func=self.func, kw_args=self.kw_args)\r\n#     154 \r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sklearn/preprocessing/_function_transformer.py in _transform(self, X, func, kw_args)\r\n#     178 \r\n# --> 179         return func(X, **(kw_args if kw_args else {}))\r\n#     180 \r\n\r\n# <ipython-input-5-9af4e0007a3b> in ar_coefs(x, maxlag)\r\n#      20     model = AR(endog=x)\r\n# ---> 21     return model.fit(maxlag=nlags).params.ravel()\r\n#      22 \r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/statsmodels/tsa/ar_model.py in fit(self, maxlag, method, ic, trend, transparams, start_params, solver, maxiter, full_output, disp, callback, **kwargs)\r\n#     546         # make lagged RHS\r\n# --> 547         X = self._stackX(k_ar, trend)  # sets self.k_trend\r\n#     548         k_trend = self.k_trend\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/statsmodels/tsa/ar_model.py in _stackX(self, k_ar, trend)\r\n#     390         if k_trend:\r\n# --> 391             X = add_trend(X, prepend=True, trend=trend, has_constant=\"raise\")\r\n#     392         self.k_trend = k_trend\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/statsmodels/tsa/tsatools.py in add_trend(x, trend, prepend, has_constant)\r\n#     107                       \"trend='{0}' is not allowed.\".format(trend)\r\n# --> 108                 raise ValueError(msg)\r\n#     109             elif has_constant == 'skip':\r\n\r\n# ValueError: x contains a constant. Adding a constant with trend='c' is not allowed.\r\n\r\n# During handling of the above exception, another exception occurred:\r\n\r\n# ValueError                                Traceback (most recent call last)\r\n# <ipython-input-5-9af4e0007a3b> in <module>\r\n#      49                                   oob_score=True)\r\n#      50 \r\n# ---> 51 rise.fit(X_train, y_train)\r\n#      52 if rise.oob_score:\r\n#      53     print(rise.oob_score_)\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sktime/classifiers/compose/ensemble.py in fit(self, X, y, sample_weight)\r\n#     354                     t, self, X, y, sample_weight, i, len(trees),\r\n#     355                     verbose=self.verbose, class_weight=self.class_weight)\r\n# --> 356                 for i, t in enumerate(trees))\r\n#     357 \r\n#     358             # Collect newly grown trees\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/parallel.py in __call__(self, iterable)\r\n#    1002             # remaining jobs.\r\n#    1003             self._iterating = False\r\n# -> 1004             if self.dispatch_one_batch(iterator):\r\n#    1005                 self._iterating = self._original_iterator is not None\r\n#    1006 \r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/parallel.py in dispatch_one_batch(self, iterator)\r\n#     833                 return False\r\n#     834             else:\r\n# --> 835                 self._dispatch(tasks)\r\n#     836                 return True\r\n#     837 \r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/parallel.py in _dispatch(self, batch)\r\n#     752         with self._lock:\r\n#     753             job_idx = len(self._jobs)\r\n# --> 754             job = self._backend.apply_async(batch, callback=cb)\r\n#     755             # A job can complete so quickly than its callback is\r\n#     756             # called before we get here, causing self._jobs to\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/_parallel_backends.py in apply_async(self, func, callback)\r\n#     207     def apply_async(self, func, callback=None):\r\n#     208         \"\"\"Schedule a func to be run\"\"\"\r\n# --> 209         result = ImmediateResult(func)\r\n#     210         if callback:\r\n#     211             callback(result)\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/_parallel_backends.py in __init__(self, batch)\r\n#     588         # Don't delay the application, to avoid keeping the input\r\n#     589         # arguments in memory\r\n# --> 590         self.results = batch()\r\n#     591 \r\n#     592     def get(self):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/parallel.py in __call__(self)\r\n#     254         with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n#     255             return [func(*args, **kwargs)\r\n# --> 256                     for func, args, kwargs in self.items]\r\n#     257 \r\n#     258     def __len__(self):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/parallel.py in <listcomp>(.0)\r\n#     254         with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n#     255             return [func(*args, **kwargs)\r\n# --> 256                     for func, args, kwargs in self.items]\r\n#     257 \r\n#     258     def __len__(self):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sktime/classifiers/compose/ensemble.py in _parallel_build_trees(tree, forest, X, y, sample_weight, tree_idx, n_trees, verbose, class_weight)\r\n#     494         fit_params = {f'{estimator}__sample_weight': curr_sample_weight,\r\n#     495                       f'{estimator}__check_input': True}\r\n# --> 496         tree.fit(X, y, **fit_params)\r\n#     497 \r\n#     498     else:\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sklearn/pipeline.py in fit(self, X, y, **fit_params)\r\n#     350             This estimator\r\n#     351         \"\"\"\r\n# --> 352         Xt, fit_params = self._fit(X, y, **fit_params)\r\n#     353         with _print_elapsed_time('Pipeline',\r\n#     354                                  self._log_message(len(self.steps) - 1)):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sklearn/pipeline.py in _fit(self, X, y, **fit_params)\r\n#     315                 message_clsname='Pipeline',\r\n#     316                 message=self._log_message(step_idx),\r\n# --> 317                 **fit_params_steps[name])\r\n#     318             # Replace the transformer of the step with the fitted\r\n#     319             # transformer. This is necessary when loading the transformer\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/memory.py in __call__(self, *args, **kwargs)\r\n#     353 \r\n#     354     def __call__(self, *args, **kwargs):\r\n# --> 355         return self.func(*args, **kwargs)\r\n#     356 \r\n#     357     def call_and_shelve(self, *args, **kwargs):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sklearn/pipeline.py in _fit_transform_one(transformer, X, y, weight, message_clsname, message, **fit_params)\r\n#     714     with _print_elapsed_time(message_clsname, message):\r\n#     715         if hasattr(transformer, 'fit_transform'):\r\n# --> 716             res = transformer.fit_transform(X, y, **fit_params)\r\n#     717         else:\r\n#     718             res = transformer.fit(X, y, **fit_params).transform(X)\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sktime/pipeline.py in fit_transform(self, X, y, **fit_params)\r\n#     182             delayed(_fit_transform_one)(trans, X, y, weight,\r\n#     183                                         **fit_params)\r\n# --> 184             for name, trans, weight in self._iter())\r\n#     185 \r\n#     186         if not result:\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/parallel.py in __call__(self, iterable)\r\n#    1002             # remaining jobs.\r\n#    1003             self._iterating = False\r\n# -> 1004             if self.dispatch_one_batch(iterator):\r\n#    1005                 self._iterating = self._original_iterator is not None\r\n#    1006 \r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/parallel.py in dispatch_one_batch(self, iterator)\r\n#     833                 return False\r\n#     834             else:\r\n# --> 835                 self._dispatch(tasks)\r\n#     836                 return True\r\n#     837 \r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/parallel.py in _dispatch(self, batch)\r\n#     752         with self._lock:\r\n#     753             job_idx = len(self._jobs)\r\n# --> 754             job = self._backend.apply_async(batch, callback=cb)\r\n#     755             # A job can complete so quickly than its callback is\r\n#     756             # called before we get here, causing self._jobs to\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/_parallel_backends.py in apply_async(self, func, callback)\r\n#     207     def apply_async(self, func, callback=None):\r\n#     208         \"\"\"Schedule a func to be run\"\"\"\r\n# --> 209         result = ImmediateResult(func)\r\n#     210         if callback:\r\n#     211             callback(result)\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/_parallel_backends.py in __init__(self, batch)\r\n#     588         # Don't delay the application, to avoid keeping the input\r\n#     589         # arguments in memory\r\n# --> 590         self.results = batch()\r\n#     591 \r\n#     592     def get(self):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/parallel.py in __call__(self)\r\n#     254         with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n#     255             return [func(*args, **kwargs)\r\n# --> 256                     for func, args, kwargs in self.items]\r\n#     257 \r\n#     258     def __len__(self):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/joblib/parallel.py in <listcomp>(.0)\r\n#     254         with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n#     255             return [func(*args, **kwargs)\r\n# --> 256                     for func, args, kwargs in self.items]\r\n#     257 \r\n#     258     def __len__(self):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sklearn/pipeline.py in _fit_transform_one(transformer, X, y, weight, message_clsname, message, **fit_params)\r\n#     714     with _print_elapsed_time(message_clsname, message):\r\n#     715         if hasattr(transformer, 'fit_transform'):\r\n# --> 716             res = transformer.fit_transform(X, y, **fit_params)\r\n#     717         else:\r\n#     718             res = transformer.fit(X, y, **fit_params).transform(X)\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sktime/transformers/base.py in fit_transform(self, X, y, **fit_params)\r\n#      40             return self.fit(X, **fit_params).transform(X)\r\n#      41         # fit method of arity 2 (supervised transformation)\r\n# ---> 42         return self.fit(X, y, **fit_params).transform(X)\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sktime/transformers/compose.py in transform(self, X, y)\r\n#     201         \"\"\"\r\n#     202         func = self.transformer.fit_transform\r\n# --> 203         return self._apply_rowwise(func, X, y)\r\n#     204 \r\n#     205     def inverse_transform(self, X, y=None):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sktime/transformers/compose.py in _apply_rowwise(self, func, X, y)\r\n#     244                 for row in col:  # loop over rows in each column\r\n#     245                     row_2d = pd.DataFrame(row)  # convert into 2d dataframe\r\n# --> 246                     row_t = func(row_2d).ravel()  # apply transform\r\n#     247                     rows_t.append(row_t)  # append transformed rows\r\n#     248                 cols_t.append(rows_t)  # append transformed columns\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sklearn/base.py in fit_transform(self, X, y, **fit_params)\r\n#     551         if y is None:\r\n#     552             # fit method of arity 1 (unsupervised transformation)\r\n# --> 553             return self.fit(X, **fit_params).transform(X)\r\n#     554         else:\r\n#     555             # fit method of arity 2 (supervised transformation)\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sklearn/preprocessing/_function_transformer.py in transform(self, X)\r\n#     151             Transformed input.\r\n#     152         \"\"\"\r\n# --> 153         return self._transform(X, func=self.func, kw_args=self.kw_args)\r\n#     154 \r\n#     155     def inverse_transform(self, X):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/sklearn/preprocessing/_function_transformer.py in _transform(self, X, func, kw_args)\r\n#     177             func = _identity\r\n#     178 \r\n# --> 179         return func(X, **(kw_args if kw_args else {}))\r\n#     180 \r\n#     181     def _more_tags(self):\r\n\r\n# <ipython-input-5-9af4e0007a3b> in ar_coefs(x, maxlag)\r\n#      19     nlags = np.minimum(len(x) - 1, maxlag)\r\n#      20     model = AR(endog=x)\r\n# ---> 21     return model.fit(maxlag=nlags).params.ravel()\r\n#      22 \r\n#      23 def acf_coefs(x, maxlag=100):\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/statsmodels/tsa/ar_model.py in fit(self, maxlag, method, ic, trend, transparams, start_params, solver, maxiter, full_output, disp, callback, **kwargs)\r\n#     545         Y = endog[k_ar:, :]\r\n#     546         # make lagged RHS\r\n# --> 547         X = self._stackX(k_ar, trend)  # sets self.k_trend\r\n#     548         k_trend = self.k_trend\r\n#     549         self.exog_names = util.make_lag_names(self.endog_names, k_ar, k_trend)\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/statsmodels/tsa/ar_model.py in _stackX(self, k_ar, trend)\r\n#     389         k_trend = util.get_trendorder(trend)\r\n#     390         if k_trend:\r\n# --> 391             X = add_trend(X, prepend=True, trend=trend, has_constant=\"raise\")\r\n#     392         self.k_trend = k_trend\r\n#     393         return X\r\n\r\n# ~/anaconda3/envs/sktime/lib/python3.7/site-packages/statsmodels/tsa/tsatools.py in add_trend(x, trend, prepend, has_constant)\r\n#     106                 msg = \"x contains a constant. Adding a constant with \" \\\r\n#     107                       \"trend='{0}' is not allowed.\".format(trend)\r\n# --> 108                 raise ValueError(msg)\r\n#     109             elif has_constant == 'skip':\r\n#     110                 columns = columns[1:]\r\n\r\n# ValueError: x contains a constant. Adding a constant with trend='c' is not allowed.\r\n```\r\n\r\n**Expected behavior**\r\n<!--\r\nA clear and concise description of what you expected to happen.\r\n-->\r\nrun without error\r\n\r\n\r\n**Additional context**\r\n<!--\r\nAdd any other context about the problem here.\r\n-->\r\n\r\n**Versions**\r\n<details>\r\n\r\nLinux-5.3.0-26-generic-x86_64-with-debian-buster-sid\r\nPython 3.7.6 (default, Jan  8 2020, 19:59:22) \r\n[GCC 7.3.0]\r\nNumPy 1.18.1\r\nSciPy 1.3.2\r\nsktime 0.3.1\r\n\r\n<!--\r\nPlease run the following snippet and paste the output here.\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"NumPy\", numpy.__version__)\r\nimport scipy; print(\"SciPy\", scipy.__version__)\r\nimport sktime; print(\"sktime\", sktime.__version__)\r\n-->\r\n\r\n</details>\r\n\r\n<!-- Thanks for contributing! -->\r\n","closed_by":{"login":"mloning","id":21020482,"node_id":"MDQ6VXNlcjIxMDIwNDgy","avatar_url":"https://avatars.githubusercontent.com/u/21020482?v=4","gravatar_id":"","url":"https://api.github.com/users/mloning","html_url":"https://github.com/mloning","followers_url":"https://api.github.com/users/mloning/followers","following_url":"https://api.github.com/users/mloning/following{/other_user}","gists_url":"https://api.github.com/users/mloning/gists{/gist_id}","starred_url":"https://api.github.com/users/mloning/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mloning/subscriptions","organizations_url":"https://api.github.com/users/mloning/orgs","repos_url":"https://api.github.com/users/mloning/repos","events_url":"https://api.github.com/users/mloning/events{/privacy}","received_events_url":"https://api.github.com/users/mloning/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sktime/sktime/issues/221/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sktime/sktime/issues/221/timeline","performed_via_github_app":null,"state_reason":"completed"}