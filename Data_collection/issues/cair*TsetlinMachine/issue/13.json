{"url":"https://api.github.com/repos/cair/TsetlinMachine/issues/13","repository_url":"https://api.github.com/repos/cair/TsetlinMachine","labels_url":"https://api.github.com/repos/cair/TsetlinMachine/issues/13/labels{/name}","comments_url":"https://api.github.com/repos/cair/TsetlinMachine/issues/13/comments","events_url":"https://api.github.com/repos/cair/TsetlinMachine/issues/13/events","html_url":"https://github.com/cair/TsetlinMachine/issues/13","id":968129397,"node_id":"MDU6SXNzdWU5NjgxMjkzOTc=","number":13,"title":"Confusion about type 1 feedback","user":{"login":"apaz-cli","id":47389403,"node_id":"MDQ6VXNlcjQ3Mzg5NDAz","avatar_url":"https://avatars.githubusercontent.com/u/47389403?v=4","gravatar_id":"","url":"https://api.github.com/users/apaz-cli","html_url":"https://github.com/apaz-cli","followers_url":"https://api.github.com/users/apaz-cli/followers","following_url":"https://api.github.com/users/apaz-cli/following{/other_user}","gists_url":"https://api.github.com/users/apaz-cli/gists{/gist_id}","starred_url":"https://api.github.com/users/apaz-cli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apaz-cli/subscriptions","organizations_url":"https://api.github.com/users/apaz-cli/orgs","repos_url":"https://api.github.com/users/apaz-cli/repos","events_url":"https://api.github.com/users/apaz-cli/events{/privacy}","received_events_url":"https://api.github.com/users/apaz-cli/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-08-12T06:02:32Z","updated_at":"2022-08-07T10:52:15Z","closed_at":"2022-08-07T10:52:15Z","author_association":"NONE","active_lock_reason":null,"body":"In an attempt to understand, and perhaps try some things out, I implemented a much faster TM in C++. Problem is, it doesn't work. I thought that I implemented it exactly as the paper described, but obviously not.\r\n\r\nThe first thing that I did was implement the Type 1 feedback table.\r\n\r\n```c\r\nstatic inline float\r\nt1feedback_table(bool clause, bool literal, bool include) {\r\n    static constexpr float type1rewards[] = {(1 / S), ((S - 1) / S)};\r\n    bool NA = literal | !clause | !include;\r\n    return type1rewards[(clause & literal)] * NA;\r\n}\r\n\r\nstatic inline TsetlinAutomaton\r\nt1feedback_is_penalty(bool clause, bool literal, bool include) {\r\n    TsetlinAutomaton options[] = {(TsetlinAutomaton)1, (TsetlinAutomaton)-1};\r\n    return options[((clause & literal) ^ include)];\r\n}\r\n\r\n// Takes in previous state and returns the next state\r\ninline TsetlinAutomaton\r\ncalc_t1_feedback(TsetlinAutomaton prev_state, bool clause_output, bool literal, bool include) {\r\n    // Sample from the table. Reward is +1, penalty is -1, and no change is 0.\r\n    TsetlinAutomaton t1_reward = rand_bernoulli(t1feedback_table(clause_output, literal, include)) *\r\n                                                     t1feedback_is_penalty(clause_output, literal, include);\r\n\r\n    // If the automaton is positive, a reward adds, and a penalty subtracts.\r\n    // If the automaton is negative, a reward subtracts, and a penalty adds.\r\n    static constexpr TsetlinAutomaton direction[] = {(TsetlinAutomaton)-1,\r\n                                                                               (TsetlinAutomaton)1};\r\n    t1_reward *= direction[include];\r\n\r\n    // Apply the feedback to the current state and return the new state.\r\n    return saturated_add(prev_state, t1_reward);\r\n}\r\n```\r\n\r\nThe implementation above is what the paper does, as I interpreted it. Doing it this way is also a whole lot faster than the reference implementations. However, something is clearly wrong, because it's not working. So I looked into the reference implementations.\r\n\r\nTo illustrate my confusion with the section of the code, I have created the following image.\r\n![Tsetlin T1 Training Highlighted](https://user-images.githubusercontent.com/47389403/129143103-3084936e-ab85-40b9-ad91-825a141328e4.png)\r\n\r\nThe first part, circled in red, makes perfect sense to me. It does not depend on the literal, so the literal is not checked. The current state is also not checked, because subtracting is a reward when excluding, and a penalty when including.\r\n\r\nThe second part, circled in green, I'm not sure what's going on. I can definitely see many of the same patterns, but I don't think it matches the table. Indeed you're checking the literal, but I'm not sure how you can get around checking whether the automaton is including or excluding. I thought that NAs had to be dealt with.\r\n\r\nThanks,\r\napaz","closed_by":{"login":"olegranmo","id":4214416,"node_id":"MDQ6VXNlcjQyMTQ0MTY=","avatar_url":"https://avatars.githubusercontent.com/u/4214416?v=4","gravatar_id":"","url":"https://api.github.com/users/olegranmo","html_url":"https://github.com/olegranmo","followers_url":"https://api.github.com/users/olegranmo/followers","following_url":"https://api.github.com/users/olegranmo/following{/other_user}","gists_url":"https://api.github.com/users/olegranmo/gists{/gist_id}","starred_url":"https://api.github.com/users/olegranmo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/olegranmo/subscriptions","organizations_url":"https://api.github.com/users/olegranmo/orgs","repos_url":"https://api.github.com/users/olegranmo/repos","events_url":"https://api.github.com/users/olegranmo/events{/privacy}","received_events_url":"https://api.github.com/users/olegranmo/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/cair/TsetlinMachine/issues/13/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/cair/TsetlinMachine/issues/13/timeline","performed_via_github_app":null,"state_reason":"completed"}