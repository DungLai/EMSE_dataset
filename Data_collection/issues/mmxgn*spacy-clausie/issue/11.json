{"url":"https://api.github.com/repos/mmxgn/spacy-clausie/issues/11","repository_url":"https://api.github.com/repos/mmxgn/spacy-clausie","labels_url":"https://api.github.com/repos/mmxgn/spacy-clausie/issues/11/labels{/name}","comments_url":"https://api.github.com/repos/mmxgn/spacy-clausie/issues/11/comments","events_url":"https://api.github.com/repos/mmxgn/spacy-clausie/issues/11/events","html_url":"https://github.com/mmxgn/spacy-clausie/issues/11","id":1105989428,"node_id":"I_kwDOCPViBs5B7A80","number":11,"title":"[Not an issue] For anyone looking for a Spacy3 compatible Clausie pipe","user":{"login":"skewwhiff","id":3540024,"node_id":"MDQ6VXNlcjM1NDAwMjQ=","avatar_url":"https://avatars.githubusercontent.com/u/3540024?v=4","gravatar_id":"","url":"https://api.github.com/users/skewwhiff","html_url":"https://github.com/skewwhiff","followers_url":"https://api.github.com/users/skewwhiff/followers","following_url":"https://api.github.com/users/skewwhiff/following{/other_user}","gists_url":"https://api.github.com/users/skewwhiff/gists{/gist_id}","starred_url":"https://api.github.com/users/skewwhiff/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/skewwhiff/subscriptions","organizations_url":"https://api.github.com/users/skewwhiff/orgs","repos_url":"https://api.github.com/users/skewwhiff/repos","events_url":"https://api.github.com/users/skewwhiff/events{/privacy}","received_events_url":"https://api.github.com/users/skewwhiff/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2022-01-17T15:22:44Z","updated_at":"2022-01-17T16:10:42Z","closed_at":"2022-01-17T16:09:47Z","author_association":"NONE","active_lock_reason":null,"body":"I rewrote some parts of this module so it's compatible with Spacy 3.0+ (Tested against V3.1.2) Requires Spacy 3.0+ and lemminflect\r\n\r\n```python\r\nimport spacy\r\nfrom spacy.language import Language\r\nimport lemminflect\r\nimport logging\r\nimport typing\r\n\r\nfrom spacy.tokens import Span, Doc\r\nfrom spacy.matcher import Matcher\r\nfrom lemminflect import getInflection\r\n\r\nlogging.basicConfig(level=logging.INFO)\r\n\r\n# DO NOT SET MANUALLY\r\nMOD_CONSERVATIVE = False\r\n\r\nDoc.set_extension(\"clauses\", default=[], force=True)\r\nSpan.set_extension(\"clauses\", default=[], force=True)\r\n\r\ndictionary = {\r\n    \"non_ext_copular\": \"\"\"die walk\"\"\".split(),\r\n    \"ext_copular\": \"\"\"act\r\nappear\r\nbe\r\nbecome\r\ncome\r\ncome out\r\nend up\r\nget\r\ngo\r\ngrow\r\nfall\r\nfeel\r\nkeep\r\nleave\r\nlook\r\nprove\r\nremain\r\nseem\r\nsmell\r\nsound\r\nstay\r\ntaste\r\nturn\r\nturn up\r\nwind up\r\nlive\r\ncome\r\ngo\r\nstand\r\nlie\r\nlove\r\ndo\r\ntry\"\"\".split(),\r\n    \"complex_transitive\": \"\"\"\r\nbring\r\ncatch\r\ndrive\r\nget\r\nkeep\r\nlay\r\nlead\r\nplace\r\nput\r\nset\r\nsit\r\nshow\r\nstand\r\nslip\r\ntake\"\"\".split(),\r\n    \"adverbs_ignore\": \"\"\"so\r\nthen\r\nthus\r\nwhy\r\nas\r\neven\"\"\".split(),\r\n    \"adverbs_include\": \"\"\"\r\nhardly\r\nbarely\r\nscarcely\r\nseldom\r\nrarely\"\"\".split(),\r\n}\r\n\r\n\r\nclass Clause:\r\n    def __init__(\r\n        self,\r\n        subject: typing.Optional[Span] = None,\r\n        verb: typing.Optional[Span] = None,\r\n        indirect_object: typing.Optional[Span] = None,\r\n        direct_object: typing.Optional[Span] = None,\r\n        complement: typing.Optional[Span] = None,\r\n        adverbials: typing.List[Span] = None,\r\n    ):\r\n        \"\"\"\r\n        Parameters\r\n        ----------\r\n        subject : Span\r\n            Subject.\r\n        verb : Span\r\n            Verb.\r\n        indirect_object : Span, optional\r\n            Indirect object, The default is None.\r\n        direct_object : Span, optional\r\n            Direct object. The default is None.\r\n        complement : Span, optional\r\n            Complement. The default is None.\r\n        adverbials : list, optional\r\n            List of adverbials. The default is [].\r\n        Returns\r\n        -------\r\n        None.\r\n        \"\"\"\r\n        if adverbials is None:\r\n            adverbials = []\r\n\r\n        self.subject = subject\r\n        self.verb = verb\r\n        self.indirect_object = indirect_object\r\n        self.direct_object = direct_object\r\n        self.complement = complement\r\n        self.adverbials = adverbials\r\n\r\n        self.doc = self.subject.doc\r\n\r\n        self.type = self._get_clause_type()\r\n\r\n    def _get_clause_type(self):\r\n        has_verb = self.verb is not None\r\n        has_complement = self.complement is not None\r\n        has_adverbial = len(self.adverbials) > 0\r\n        has_ext_copular_verb = (\r\n            has_verb and self.verb.root.lemma_ in dictionary[\"ext_copular\"]\r\n        )\r\n        has_non_ext_copular_verb = (\r\n            has_verb and self.verb.root.lemma_ in dictionary[\"non_ext_copular\"]\r\n        )\r\n        conservative = MOD_CONSERVATIVE\r\n        has_direct_object = self.direct_object is not None\r\n        has_indirect_object = self.indirect_object is not None\r\n        has_object = has_direct_object or has_indirect_object\r\n        complex_transitive = (\r\n            has_verb and self.verb.root.lemma_ in dictionary[\"complex_transitive\"]\r\n        )\r\n\r\n        clause_type = \"undefined\"\r\n\r\n        if not has_verb:\r\n            clause_type = \"SVC\"\r\n            return clause_type\r\n\r\n        if has_object:\r\n            if has_direct_object and has_indirect_object:\r\n                clause_type = \"SVOO\"\r\n            elif has_complement:\r\n                clause_type = \"SVOC\"\r\n            elif not has_adverbial or not has_direct_object:\r\n                clause_type = \"SVO\"\r\n            elif complex_transitive or conservative:\r\n                clause_type = \"SVOA\"\r\n            else:\r\n                clause_type = \"SVO\"\r\n        else:\r\n            if has_complement:\r\n                clause_type = \"SVC\"\r\n            elif not has_adverbial or has_non_ext_copular_verb:\r\n                clause_type = \"SV\"\r\n            elif has_ext_copular_verb or conservative:\r\n                clause_type = \"SVA\"\r\n            else:\r\n                clause_type = \"SV\"\r\n\r\n        return clause_type\r\n\r\n    def __repr__(self):\r\n        return \"<{}, {}, {}, {}, {}, {}, {}>\".format(\r\n            self.type,\r\n            self.subject,\r\n            self.verb,\r\n            self.indirect_object,\r\n            self.direct_object,\r\n            self.complement,\r\n            self.adverbials,\r\n        )\r\n\r\n    def to_propositions(\r\n        self, as_text: bool = False, inflect: str or None = \"VBD\", capitalize: bool = False\r\n    ):\r\n\r\n        if inflect and not as_text:\r\n            logging.warning(\"`inflect' argument is ignored when `as_text==False'. To suppress this warning call `to_propositions' with the argument `inflect=None'\")\r\n        if capitalize and not as_text:\r\n            logging.warning(\"`capitalize' argument is ignored when `as_text==False'. To suppress this warning call `to_propositions' with the argument `capitalize=False\")\r\n\r\n        propositions = []\r\n\r\n        subjects = extract_ccs_from_token_at_root(self.subject)\r\n        direct_objects = extract_ccs_from_token_at_root(self.direct_object)\r\n        indirect_objects = extract_ccs_from_token_at_root(self.indirect_object)\r\n        complements = extract_ccs_from_token_at_root(self.complement)\r\n        verbs = [self.verb] if self.verb else []\r\n\r\n        for subj in subjects:\r\n            if complements and not verbs:\r\n                for c in complements:\r\n                    propositions.append((subj, \"is\", c))\r\n                propositions.append((subj, \"is\") + tuple(complements))\r\n\r\n            for verb in verbs:\r\n                prop = [subj, verb]\r\n                if self.type in [\"SV\", \"SVA\"]:\r\n                    if self.adverbials:\r\n                        for a in self.adverbials:\r\n                            propositions.append(tuple(prop + [a]))\r\n                        propositions.append(tuple(prop + self.adverbials))\r\n                    else:\r\n                        propositions.append(tuple(prop))\r\n\r\n                elif self.type == \"SVOO\":\r\n                    for iobj in indirect_objects:\r\n                        for dobj in direct_objects:\r\n                            propositions.append((subj, verb, iobj, dobj))\r\n                elif self.type == \"SVO\":\r\n                    for obj in direct_objects + indirect_objects:\r\n                        propositions.append((subj, verb, obj))\r\n                        for a in self.adverbials:\r\n                            propositions.append((subj, verb, obj, a))\r\n                elif self.type == \"SVOA\":\r\n                    for obj in direct_objects:\r\n                        if self.adverbials:\r\n                            for a in self.adverbials:\r\n                                propositions.append(tuple(prop + [obj, a]))\r\n                            propositions.append(tuple(prop + [obj] + self.adverbials))\r\n\r\n                elif self.type == \"SVOC\":\r\n                    for obj in indirect_objects + direct_objects:\r\n                        if complements:\r\n                            for c in complements:\r\n                                propositions.append(tuple(prop + [obj, c]))\r\n                            propositions.append(tuple(prop + [obj] + complements))\r\n                elif self.type == \"SVC\":\r\n                    if complements:\r\n                        for c in complements:\r\n                            propositions.append(tuple(prop + [c]))\r\n                        propositions.append(tuple(prop + complements))\r\n\r\n        # Remove doubles\r\n        propositions = list(set(propositions))\r\n\r\n        if as_text:\r\n            return _convert_clauses_to_text(\r\n                propositions, inflect=inflect, capitalize=capitalize\r\n            )\r\n\r\n        return propositions\r\n\r\n\r\ndef inflect_token(token, inflect):\r\n    if (\r\n        inflect\r\n        and token.pos_ == \"VERB\"\r\n        and \"AUX\" not in [tt.pos_ for tt in token.lefts]\r\n        # t is not preceded by an auxiliary verb (e.g. `the birds were ailing`)\r\n        and token.dep_ != \"pcomp\"\r\n    ):  # t `dreamed of becoming a dancer`\r\n        return str(token._.inflect(inflect))\r\n    else:\r\n        return str(token)\r\n\r\n\r\ndef _convert_clauses_to_text(propositions, inflect, capitalize):\r\n    proposition_texts = []\r\n    for proposition in propositions:\r\n        span_texts = []\r\n        for span in proposition:\r\n\r\n            token_texts = []\r\n            for token in span:\r\n                token_texts.append(inflect_token(token, inflect))\r\n\r\n            span_texts.append(\" \".join(token_texts))\r\n        proposition_texts.append(\" \".join(span_texts))\r\n\r\n    if capitalize:  # Capitalize and add a full stop.\r\n        proposition_texts = [text.capitalize() + \".\" for text in proposition_texts]\r\n\r\n    return proposition_texts\r\n\r\n\r\ndef _get_verb_matches(span):\r\n    # 1. Find verb phrases in the span\r\n    # (see mdmjsh answer here: https://stackoverflow.com/questions/47856247/extract-verb-phrases-using-spacy)\r\n\r\n    verb_matcher = Matcher(span.vocab)\r\n    verb_matcher.add(\r\n        \"Auxiliary verb phrase aux-verb\", [[{\"POS\": \"AUX\"}, {\"POS\": \"VERB\"}]]\r\n    )\r\n    verb_matcher.add(\"Auxiliary verb phrase\", [[{\"POS\": \"AUX\"}]])\r\n    verb_matcher.add(\"Verb phrase\", [[{\"POS\": \"VERB\"}]])\r\n\r\n    return verb_matcher(span)\r\n\r\n\r\ndef _get_verb_chunks(span):\r\n    matches = _get_verb_matches(span)\r\n\r\n    # Filter matches (e.g. do not have both \"has won\" and \"won\" in verbs)\r\n    verb_chunks = []\r\n    for match in [span[start:end] for _, start, end in matches]:\r\n        if match.root not in [vp.root for vp in verb_chunks]:\r\n            verb_chunks.append(match)\r\n    return verb_chunks\r\n\r\n\r\ndef _get_subject(verb):\r\n    for c in verb.root.children:\r\n        if c.dep_ in [\"nsubj\", \"nsubjpass\"]:\r\n            subject = extract_span_from_entity(c)\r\n            return subject\r\n\r\n    root = verb.root\r\n    while root.dep_ in [\"conj\", \"cc\", \"advcl\", \"acl\", \"ccomp\", \"ROOT\"]:\r\n        for c in root.children:\r\n            if c.dep_ in [\"nsubj\", \"nsubjpass\"]:\r\n                subject = extract_span_from_entity(c)\r\n                return subject\r\n\r\n            if c.dep_ in [\"acl\", \"advcl\"]:\r\n                subject = find_verb_subject(c)\r\n                return extract_span_from_entity(subject) if subject else None\r\n\r\n        # Break cycles\r\n        if root == verb.root.head:\r\n            break\r\n        else:\r\n            root = verb.root.head\r\n\r\n    for c in root.children:\r\n        if c.dep_ in [\"nsubj\", \"nsubj:pass\", \"nsubjpass\"]:\r\n            subject = extract_span_from_entity(c)\r\n            return subject\r\n    return None\r\n\r\n\r\ndef _find_matching_child(root, allowed_types):\r\n    for c in root.children:\r\n        if c.dep_ in allowed_types:\r\n            return extract_span_from_entity(c)\r\n    return None\r\n\r\n\r\ndef extract_clauses(span):\r\n    clauses = []\r\n\r\n    verb_chunks = _get_verb_chunks(span)\r\n    for verb in verb_chunks:\r\n\r\n        subject = _get_subject(verb)\r\n        if not subject:\r\n            continue\r\n\r\n        # Check if there are phrases of the form, \"AE, a scientist of ...\"\r\n        # If so, add a new clause of the form:\r\n        # <AE, is, a scientist>\r\n        for c in subject.root.children:\r\n            if c.dep_ == \"appos\":\r\n                complement = extract_span_from_entity(c)\r\n                clause = Clause(subject=subject, complement=complement)\r\n                clauses.append(clause)\r\n\r\n        indirect_object = _find_matching_child(verb.root, [\"dative\"])\r\n        direct_object = _find_matching_child(verb.root, [\"dobj\"])\r\n        complement = _find_matching_child(\r\n            verb.root, [\"ccomp\", \"acomp\", \"xcomp\", \"attr\"]\r\n        )\r\n        adverbials = [\r\n            extract_span_from_entity(c)\r\n            for c in verb.root.children\r\n            if c.dep_ in (\"prep\", \"advmod\", \"agent\")\r\n        ]\r\n\r\n        clause = Clause(\r\n            subject=subject,\r\n            verb=verb,\r\n            indirect_object=indirect_object,\r\n            direct_object=direct_object,\r\n            complement=complement,\r\n            adverbials=adverbials,\r\n        )\r\n        clauses.append(clause)\r\n    return clauses\r\n\r\n\r\ndef extract_span_from_entity(token):\r\n    ent_subtree = sorted([c for c in token.subtree], key=lambda x: x.i)\r\n    return Span(token.doc, start=ent_subtree[0].i, end=ent_subtree[-1].i + 1)\r\n\r\n\r\ndef extract_span_from_entity_no_cc(token):\r\n    ent_subtree = sorted(\r\n        [token] + [c for c in token.children if c.dep_ not in [\"cc\", \"conj\", \"prep\"]],\r\n        key=lambda x: x.i,\r\n    )\r\n    return Span(token.doc, start=ent_subtree[0].i, end=ent_subtree[-1].i + 1)\r\n\r\n\r\ndef extract_ccs_from_entity(token):\r\n    entities = [extract_span_from_entity_no_cc(token)]\r\n    for c in token.children:\r\n        if c.dep_ in [\"conj\", \"cc\"]:\r\n            entities += extract_ccs_from_entity(c)\r\n    return entities\r\n\r\n\r\ndef extract_ccs_from_token_at_root(span):\r\n    if span is None:\r\n        return []\r\n    else:\r\n        return extract_ccs_from_token(span.root)\r\n\r\n\r\ndef extract_ccs_from_token(token):\r\n    if token.pos_ in [\"NOUN\", \"PROPN\", \"ADJ\"]:\r\n        children = sorted(\r\n            [token]\r\n            + [\r\n                c\r\n                for c in token.children\r\n                if c.dep_ in [\"advmod\", \"amod\", \"det\", \"poss\", \"compound\"]\r\n            ],\r\n            key=lambda x: x.i,\r\n        )\r\n        entities = [Span(token.doc, start=children[0].i, end=children[-1].i + 1)]\r\n    else:\r\n        entities = [Span(token.doc, start=token.i, end=token.i + 1)]\r\n    for c in token.children:\r\n        if c.dep_ == \"conj\":\r\n            entities += extract_ccs_from_token(c)\r\n    return entities\r\n\r\n\r\ndef find_verb_subject(v):\r\n    \"\"\"\r\n    Returns the nsubj, nsubjpass of the verb. If it does not exist and the root is a head,\r\n    find the subject of that verb instead.\r\n    \"\"\"\r\n    if v.dep_ in [\"nsubj\", \"nsubjpass\", \"nsubj:pass\"]:\r\n        return v\r\n    # guard against infinite recursion on root token\r\n    elif v.dep_ in [\"advcl\", \"acl\"] and v.head.dep_ != \"ROOT\":\r\n        return find_verb_subject(v.head)\r\n\r\n    for c in v.children:\r\n        if c.dep_ in [\"nsubj\", \"nsubjpass\", \"nsubj:pass\"]:\r\n            return c\r\n        elif c.dep_ in [\"advcl\", \"acl\"] and v.head.dep_ != \"ROOT\":\r\n            return find_verb_subject(v.head)\r\n        \r\n        \r\n@Language.component(\"clausie\")\r\ndef extract_clauses_doc(doc):\r\n    for sent in doc.sents:\r\n        clauses = extract_clauses(sent)\r\n        sent._.clauses = clauses\r\n        doc._.clauses += clauses\r\n    return doc\r\n```\r\nMinimal example to invoke this component:\r\n```python\r\nimport spacy\r\nnlp = spacy.load(\"en\")\r\nclausie = nlp.add_pipe(\"clausie\", name=\"clausie\", last=True)\r\nfor clause in doc._.clauses:\r\n    print(clause.to_propositions(as_text=True))\r\n```","closed_by":{"login":"mmxgn","id":349290,"node_id":"MDQ6VXNlcjM0OTI5MA==","avatar_url":"https://avatars.githubusercontent.com/u/349290?v=4","gravatar_id":"","url":"https://api.github.com/users/mmxgn","html_url":"https://github.com/mmxgn","followers_url":"https://api.github.com/users/mmxgn/followers","following_url":"https://api.github.com/users/mmxgn/following{/other_user}","gists_url":"https://api.github.com/users/mmxgn/gists{/gist_id}","starred_url":"https://api.github.com/users/mmxgn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mmxgn/subscriptions","organizations_url":"https://api.github.com/users/mmxgn/orgs","repos_url":"https://api.github.com/users/mmxgn/repos","events_url":"https://api.github.com/users/mmxgn/events{/privacy}","received_events_url":"https://api.github.com/users/mmxgn/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/mmxgn/spacy-clausie/issues/11/reactions","total_count":2,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":2,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/mmxgn/spacy-clausie/issues/11/timeline","performed_via_github_app":null,"state_reason":"completed"}