[{"url":"https://api.github.com/repos/lsdefine/attention-is-all-you-need-keras/issues/comments/500589176","html_url":"https://github.com/lsdefine/attention-is-all-you-need-keras/issues/26#issuecomment-500589176","issue_url":"https://api.github.com/repos/lsdefine/attention-is-all-you-need-keras/issues/26","id":500589176,"node_id":"MDEyOklzc3VlQ29tbWVudDUwMDU4OTE3Ng==","user":{"login":"thomasyue","id":43042527,"node_id":"MDQ6VXNlcjQzMDQyNTI3","avatar_url":"https://avatars.githubusercontent.com/u/43042527?v=4","gravatar_id":"","url":"https://api.github.com/users/thomasyue","html_url":"https://github.com/thomasyue","followers_url":"https://api.github.com/users/thomasyue/followers","following_url":"https://api.github.com/users/thomasyue/following{/other_user}","gists_url":"https://api.github.com/users/thomasyue/gists{/gist_id}","starred_url":"https://api.github.com/users/thomasyue/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/thomasyue/subscriptions","organizations_url":"https://api.github.com/users/thomasyue/orgs","repos_url":"https://api.github.com/users/thomasyue/repos","events_url":"https://api.github.com/users/thomasyue/events{/privacy}","received_events_url":"https://api.github.com/users/thomasyue/received_events","type":"User","site_admin":false},"created_at":"2019-06-10T20:49:59Z","updated_at":"2019-06-10T20:49:59Z","author_association":"NONE","body":"code is as follow\r\n\r\n```\r\nmax_features = 2885\r\nembed_size = 300\r\nmax_len = 57\r\nd_emb = embed_size\r\n\r\nimport random, os, sys\r\nimport numpy as np\r\nfrom keras.models import *\r\nfrom keras.layers import *\r\nfrom keras.callbacks import *\r\nfrom keras.initializers import *\r\nimport tensorflow as tf\r\nfrom keras.engine.topology import Layer\r\n\r\n\r\nkeras.backend.clear_session()\r\nclass LayerNormalization(Layer):\r\n    def __init__(self, eps=1e-6, **kwargs):\r\n        self.eps = eps\r\n        super(LayerNormalization, self).__init__(**kwargs)\r\n    def build(self, input_shape):\r\n        self.gamma = self.add_weight(name='gamma', shape=input_shape[-1:],\r\n                                     initializer=Ones(), trainable=True)\r\n        self.beta = self.add_weight(name='beta', shape=input_shape[-1:],\r\n                                    initializer=Zeros(), trainable=True)\r\n        super(LayerNormalization, self).build(input_shape)\r\n    def call(self, x):\r\n        mean = K.mean(x, axis=-1, keepdims=True)\r\n        std = K.std(x, axis=-1, keepdims=True)\r\n        return self.gamma * (x - mean) / (std + self.eps) + self.beta\r\n    def compute_output_shape(self, input_shape):\r\n        return input_shape\r\n\r\nclass ScaledDotProductAttention():\r\n    def __init__(self, attn_dropout=0.1):\r\n        self.dropout = Dropout(attn_dropout)\r\n    def __call__(self, q, k, v, mask):   # mask_k or mask_qk\r\n        temper = tf.sqrt(tf.cast(tf.shape(k)[-1], dtype='float32'))\r\n        attn = Lambda(lambda x:K.batch_dot(x[0],x[1],axes=[2,2])/temper)([q, k])  # shape=(batch, q, k)\r\n        if mask is not None:\r\n            mmask = Lambda(lambda x:(-1e+9)*(1.-K.cast(x, 'float32')))(mask)\r\n            attn = Add()([attn, mmask])\r\n        attn = Activation('softmax')(attn)\r\n        attn = self.dropout(attn)\r\n        output = Lambda(lambda x:K.batch_dot(x[0], x[1]))([attn, v])\r\n        return output, attn\r\n\r\nclass MultiHeadAttention():\r\n    # mode 0 - big martixes, faster; mode 1 - more clear implementation\r\n    def __init__(self, n_head, d_model, dropout, mode=0):\r\n        self.mode = mode\r\n        self.n_head = n_head\r\n        self.d_k = self.d_v = d_k = d_v = d_model // n_head\r\n        self.dropout = dropout\r\n        if mode == 0:\r\n            self.qs_layer = Dense(n_head*d_k, use_bias=False)\r\n            self.ks_layer = Dense(n_head*d_k, use_bias=False)\r\n            self.vs_layer = Dense(n_head*d_v, use_bias=False)\r\n        elif mode == 1:\r\n            self.qs_layers = []\r\n            self.ks_layers = []\r\n            self.vs_layers = []\r\n            for _ in range(n_head):\r\n                self.qs_layers.append(TimeDistributed(Dense(d_k, use_bias=False)))\r\n                self.ks_layers.append(TimeDistributed(Dense(d_k, use_bias=False)))\r\n                self.vs_layers.append(TimeDistributed(Dense(d_v, use_bias=False)))\r\n        self.attention = ScaledDotProductAttention()\r\n        self.w_o = TimeDistributed(Dense(d_model))\r\n\r\n    def __call__(self, q, k, v, mask=None):\r\n        d_k, d_v = self.d_k, self.d_v\r\n        n_head = self.n_head\r\n\r\n        if self.mode == 0:\r\n            qs = self.qs_layer(q)  # [batch_size, len_q, n_head*d_k]\r\n            ks = self.ks_layer(k)\r\n            vs = self.vs_layer(v)\r\n\r\n            def reshape1(x):\r\n                s = tf.shape(x)   # [batch_size, len_q, n_head * d_k]\r\n                x = tf.reshape(x, [s[0], s[1], n_head, s[2]//n_head])\r\n                x = tf.transpose(x, [2, 0, 1, 3])  \r\n                x = tf.reshape(x, [-1, s[1], s[2]//n_head])  # [n_head * batch_size, len_q, d_k]\r\n                return x\r\n            qs = Lambda(reshape1)(qs)\r\n            ks = Lambda(reshape1)(ks)\r\n            vs = Lambda(reshape1)(vs)\r\n\r\n            if mask is not None:\r\n                mask = Lambda(lambda x:K.repeat_elements(x, n_head, 0))(mask)\r\n            head, attn = self.attention(qs, ks, vs, mask=mask)  \r\n\r\n            def reshape2(x):\r\n                s = tf.shape(x)   # [n_head * batch_size, len_v, d_v]\r\n                x = tf.reshape(x, [n_head, -1, s[1], s[2]]) \r\n                x = tf.transpose(x, [1, 2, 0, 3])\r\n                x = tf.reshape(x, [-1, s[1], n_head*d_v])  # [batch_size, len_v, n_head * d_v]\r\n                return x\r\n            head = Lambda(reshape2)(head)\r\n        elif self.mode == 1:\r\n            heads = []; attns = []\r\n            for i in range(n_head):\r\n                qs = self.qs_layers[i](q)   \r\n                ks = self.ks_layers[i](k) \r\n                vs = self.vs_layers[i](v) \r\n                head, attn = self.attention(qs, ks, vs, mask)\r\n                heads.append(head); attns.append(attn)\r\n            head = Concatenate()(heads) if n_head > 1 else heads[0]\r\n            attn = Concatenate()(attns) if n_head > 1 else attns[0]\r\n\r\n        outputs = self.w_o(head)\r\n        outputs = Dropout(self.dropout)(outputs)\r\n        return outputs, attn\r\n\r\nclass PositionwiseFeedForward():\r\n    def __init__(self, d_hid, d_inner_hid, dropout=0.1):\r\n        self.w_1 = Conv1D(d_inner_hid, 1, activation='relu')\r\n        self.w_2 = Conv1D(d_hid, 1)\r\n        self.layer_norm = LayerNormalization()\r\n        self.dropout = Dropout(dropout)\r\n    def __call__(self, x):\r\n        output = self.w_1(x) \r\n        output = self.w_2(output)\r\n        output = self.dropout(output)\r\n        output = Add()([output, x])\r\n        return self.layer_norm(output)\r\n\r\nclass EncoderLayer():\r\n    def __init__(self, d_model, d_inner_hid, n_head, dropout=0.1):\r\n        self.self_att_layer = MultiHeadAttention(n_head, d_model, dropout=dropout)\r\n        self.pos_ffn_layer  = PositionwiseFeedForward(d_model, d_inner_hid, dropout=dropout)\r\n        self.norm_layer = LayerNormalization()\r\n    def __call__(self, enc_input, mask=None):\r\n        output, slf_attn = self.self_att_layer(enc_input, enc_input, enc_input, mask=mask)\r\n        output = self.norm_layer(Add()([enc_input, output]))\r\n        output = self.pos_ffn_layer(output)\r\n        return output, slf_attn\r\n\r\nclass DecoderLayer():\r\n    def __init__(self, d_model, d_inner_hid, n_head, dropout=0.1):\r\n        self.self_att_layer = MultiHeadAttention(n_head, d_model, dropout=dropout)\r\n        self.enc_att_layer  = MultiHeadAttention(n_head, d_model, dropout=dropout)\r\n        self.pos_ffn_layer  = PositionwiseFeedForward(d_model, d_inner_hid, dropout=dropout)\r\n        self.norm_layer1 = LayerNormalization()\r\n        self.norm_layer2 = LayerNormalization()\r\n    def __call__(self, dec_input, enc_output, self_mask=None, enc_mask=None, dec_last_state=None):\r\n        if dec_last_state is None: dec_last_state = dec_input\r\n        output, slf_attn = self.self_att_layer(dec_input, dec_last_state, dec_last_state, mask=self_mask)\r\n        x = self.norm_layer1(Add()([dec_input, output]))\r\n        output, enc_attn = self.enc_att_layer(x, enc_output, enc_output, mask=enc_mask)\r\n        x = self.norm_layer2(Add()([x, output]))\r\n        output = self.pos_ffn_layer(x)\r\n        return output, slf_attn, enc_attn\r\n\r\ndef GetPosEncodingMatrix(max_len, d_emb):\r\n    pos_enc = np.array([\r\n        [pos / np.power(10000, 2 * (j // 2) / d_emb) for j in range(d_emb)] \r\n        if pos != 0 else np.zeros(d_emb) \r\n            for pos in range(max_len)\r\n            ])\r\n    pos_enc[1:, 0::2] = np.sin(pos_enc[1:, 0::2]) # dim 2i\r\n    pos_enc[1:, 1::2] = np.cos(pos_enc[1:, 1::2]) # dim 2i+1\r\n    return pos_enc\r\n\r\ndef GetPadMask(q, k):\r\n    ones = K.expand_dims(K.ones_like(q, 'float32'), -1)\r\n    mask = K.cast(K.expand_dims(K.not_equal(k, 0), 1), 'float32')\r\n    mask = K.batch_dot(ones, mask, axes=[2,1])\r\n    return mask\r\n\r\ndef GetSubMask(s):\r\n    len_s = tf.shape(s)[1]\r\n    bs = tf.shape(s)[:1]\r\n    mask = K.cumsum(tf.eye(len_s, batch_shape=bs), 1)\r\n    return mask\r\n\r\nclass Encoder():\r\n    def __init__(self, d_model, d_inner_hid, n_head, layers=6, dropout=0.1):\r\n        self.layers = [EncoderLayer(d_model, d_inner_hid, n_head, dropout) for _ in range(layers)]\r\n    def __call__(self, src_emb, src_seq, return_att=False, active_layers=999):\r\n        if return_att: atts = []\r\n        mask = Lambda(lambda x:K.cast(K.greater(x, 0), 'float32'))(src_seq)\r\n        x = src_emb\t\t\r\n        for enc_layer in self.layers[:active_layers]:\r\n            x, att = enc_layer(x, mask)\r\n            if return_att: atts.append(att)\r\n        return (x, atts) if return_att else x\r\n    \r\nclass Decoder():\r\n    def __init__(self, d_model, d_inner_hid, n_head, layers=6, dropout=0.1):\r\n        self.layers = [DecoderLayer(d_model, d_inner_hid, n_head, dropout) for _ in range(layers)]\r\n        \r\n    def __call__(self, tgt_emb, tgt_seq, src_seq, enc_output, return_att=False, active_layers=999):\r\n        x = tgt_emb\r\n        self_pad_mask = Lambda(lambda x:GetPadMask(x, x))(tgt_seq)\r\n        self_sub_mask = Lambda(GetSubMask)(tgt_seq)\r\n        self_mask = Lambda(lambda x:K.minimum(x[0], x[1]))([self_pad_mask, self_sub_mask])\r\n        enc_mask = Lambda(lambda x:GetPadMask(x[0], x[1]))([tgt_seq, src_seq])\r\n        if return_att: self_atts, enc_atts = [], []\r\n        for dec_layer in self.layers[:active_layers]:\r\n            x, self_att, enc_att = dec_layer(x, enc_output, self_mask, enc_mask)\r\n            if return_att: \r\n                self_atts.append(self_att)\r\n                enc_atts.append(enc_att)\r\n        return (x, self_atts, enc_atts) if return_att else x\r\n\r\nclass Transformer():\r\n    def __init__(self, len_limit, embedding_matrix, d_model=embed_size, \\\r\n              d_inner_hid=512, n_head=4, d_k=64, d_v=64, layers=2, dropout=0.1, \\\r\n              share_word_emb=False, **kwargs):\r\n        self.name = 'Transformer'\r\n        self.len_limit = len_limit\r\n        self.src_loc_info = True\r\n        self.d_model = d_model\r\n        self.layers = layers\r\n        self.decode_model = None\r\n        d_emb = d_model\r\n        \r\n\r\n        pos_emb = Embedding(len_limit, d_emb, trainable=False, \\\r\n                            weights=[GetPosEncodingMatrix(len_limit, d_emb)])\r\n\r\n        self.i_word_emb = Embedding(max_features, d_emb, weights=[embedding_matrix])\r\n        if share_word_emb: \r\n            self.o_word_emb = i_word_emb\r\n        else: self.o_word_emb = Embedding(max_features, d_emb, weights=[embedding_matrix])\r\n        \r\n        self.encoder = Encoder(d_model, d_inner_hid, n_head, layers, dropout)\r\n        self.decoder = Decoder(d_model, d_inner_hid, n_head, layers, dropout)\r\n        self.target_layer = TimeDistributed(Dense(avg_size, use_bias=False))\r\n        \r\n        \r\n    def get_pos_seq(self, x):\r\n        mask = K.cast(K.not_equal(x, 0), 'int32')\r\n        pos = K.cumsum(K.ones_like(x, 'int32'), 1)\r\n        return pos * mask\r\n\r\n    def compile(self, active_layers=999):\r\n        src_seq_input = Input(shape=(avg_size,))\r\n        tgt_seq_input = Input(shape=(avg_size,))\r\n        \r\n        \r\n        src_seq = src_seq_input\r\n        tgt_seq  = Lambda(lambda x:x[:,:-1])(tgt_seq_input)\r\n        \r\n        src_emb = self.i_word_emb(src_seq)\r\n        tgt_emb = self.o_word_emb(tgt_seq)\r\n        \r\n#         if self.pos_emb: \r\n#             src_emb = add_layer([src_emb, self.pos_emb(src_seq)])\r\n#             tgt_emb = add_layer([tgt_emb, self.pos_emb(tgt_seq)])\r\n\r\n#         src_emb = self.emb_dropout(src_emb)\r\n        \r\n        \r\n        src_pos = Lambda(self.get_pos_seq)(src_seq)\r\n\r\n\r\n        enc_output = self.encoder(src_emb, src_seq, active_layers=active_layers)\r\n        dec_output = self.decoder(tgt_emb, tgt_seq, src_seq, enc_output, active_layers=active_layers)\r\n        final_output = self.target_layer(dec_output)\r\n        \r\n        adadelta = optimizers.Adadelta(lr=1, rho=0.95, epsilon=None, decay=0.0)\r\n        self.model = Model([src_seq_input, tgt_seq_input], final_output)\r\n        self.model.compile(loss='mse', optimizer=adadelta)\r\n```","reactions":{"url":"https://api.github.com/repos/lsdefine/attention-is-all-you-need-keras/issues/comments/500589176/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"thomasyue","id":43042527,"node_id":"MDQ6VXNlcjQzMDQyNTI3","avatar_url":"https://avatars.githubusercontent.com/u/43042527?v=4","gravatar_id":"","url":"https://api.github.com/users/thomasyue","html_url":"https://github.com/thomasyue","followers_url":"https://api.github.com/users/thomasyue/followers","following_url":"https://api.github.com/users/thomasyue/following{/other_user}","gists_url":"https://api.github.com/users/thomasyue/gists{/gist_id}","starred_url":"https://api.github.com/users/thomasyue/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/thomasyue/subscriptions","organizations_url":"https://api.github.com/users/thomasyue/orgs","repos_url":"https://api.github.com/users/thomasyue/repos","events_url":"https://api.github.com/users/thomasyue/events{/privacy}","received_events_url":"https://api.github.com/users/thomasyue/received_events","type":"User","site_admin":false}},{"id":2410990081,"node_id":"MDExOkNsb3NlZEV2ZW50MjQxMDk5MDA4MQ==","url":"https://api.github.com/repos/lsdefine/attention-is-all-you-need-keras/issues/events/2410990081","actor":{"login":"thomasyue","id":43042527,"node_id":"MDQ6VXNlcjQzMDQyNTI3","avatar_url":"https://avatars.githubusercontent.com/u/43042527?v=4","gravatar_id":"","url":"https://api.github.com/users/thomasyue","html_url":"https://github.com/thomasyue","followers_url":"https://api.github.com/users/thomasyue/followers","following_url":"https://api.github.com/users/thomasyue/following{/other_user}","gists_url":"https://api.github.com/users/thomasyue/gists{/gist_id}","starred_url":"https://api.github.com/users/thomasyue/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/thomasyue/subscriptions","organizations_url":"https://api.github.com/users/thomasyue/orgs","repos_url":"https://api.github.com/users/thomasyue/repos","events_url":"https://api.github.com/users/thomasyue/events{/privacy}","received_events_url":"https://api.github.com/users/thomasyue/received_events","type":"User","site_admin":false},"event":"closed","commit_id":null,"commit_url":null,"created_at":"2019-06-13T15:20:25Z","state_reason":null,"performed_via_github_app":null}]