[{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/635882207","html_url":"https://github.com/ahmetgunduz/Real-time-GesRec/issues/69#issuecomment-635882207","issue_url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/69","id":635882207,"node_id":"MDEyOklzc3VlQ29tbWVudDYzNTg4MjIwNw==","user":{"login":"ahmetgunduz","id":16335853,"node_id":"MDQ6VXNlcjE2MzM1ODUz","avatar_url":"https://avatars.githubusercontent.com/u/16335853?v=4","gravatar_id":"","url":"https://api.github.com/users/ahmetgunduz","html_url":"https://github.com/ahmetgunduz","followers_url":"https://api.github.com/users/ahmetgunduz/followers","following_url":"https://api.github.com/users/ahmetgunduz/following{/other_user}","gists_url":"https://api.github.com/users/ahmetgunduz/gists{/gist_id}","starred_url":"https://api.github.com/users/ahmetgunduz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ahmetgunduz/subscriptions","organizations_url":"https://api.github.com/users/ahmetgunduz/orgs","repos_url":"https://api.github.com/users/ahmetgunduz/repos","events_url":"https://api.github.com/users/ahmetgunduz/events{/privacy}","received_events_url":"https://api.github.com/users/ahmetgunduz/received_events","type":"User","site_admin":false},"created_at":"2020-05-29T09:48:02Z","updated_at":"2020-05-29T09:48:09Z","author_association":"OWNER","body":"can you try to load the images using PILLOW library?","reactions":{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/635882207/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"ahmetgunduz","id":16335853,"node_id":"MDQ6VXNlcjE2MzM1ODUz","avatar_url":"https://avatars.githubusercontent.com/u/16335853?v=4","gravatar_id":"","url":"https://api.github.com/users/ahmetgunduz","html_url":"https://github.com/ahmetgunduz","followers_url":"https://api.github.com/users/ahmetgunduz/followers","following_url":"https://api.github.com/users/ahmetgunduz/following{/other_user}","gists_url":"https://api.github.com/users/ahmetgunduz/gists{/gist_id}","starred_url":"https://api.github.com/users/ahmetgunduz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ahmetgunduz/subscriptions","organizations_url":"https://api.github.com/users/ahmetgunduz/orgs","repos_url":"https://api.github.com/users/ahmetgunduz/repos","events_url":"https://api.github.com/users/ahmetgunduz/events{/privacy}","received_events_url":"https://api.github.com/users/ahmetgunduz/received_events","type":"User","site_admin":false}},{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/635885516","html_url":"https://github.com/ahmetgunduz/Real-time-GesRec/issues/69#issuecomment-635885516","issue_url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/69","id":635885516,"node_id":"MDEyOklzc3VlQ29tbWVudDYzNTg4NTUxNg==","user":{"login":"niuwenju","id":37408618,"node_id":"MDQ6VXNlcjM3NDA4NjE4","avatar_url":"https://avatars.githubusercontent.com/u/37408618?v=4","gravatar_id":"","url":"https://api.github.com/users/niuwenju","html_url":"https://github.com/niuwenju","followers_url":"https://api.github.com/users/niuwenju/followers","following_url":"https://api.github.com/users/niuwenju/following{/other_user}","gists_url":"https://api.github.com/users/niuwenju/gists{/gist_id}","starred_url":"https://api.github.com/users/niuwenju/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/niuwenju/subscriptions","organizations_url":"https://api.github.com/users/niuwenju/orgs","repos_url":"https://api.github.com/users/niuwenju/repos","events_url":"https://api.github.com/users/niuwenju/events{/privacy}","received_events_url":"https://api.github.com/users/niuwenju/received_events","type":"User","site_admin":false},"created_at":"2020-05-29T09:55:40Z","updated_at":"2020-05-29T09:55:40Z","author_association":"NONE","body":"i have converted the frame from opencv to pillow use this script\r\n\r\n```\r\nfrom PIL import Image\r\nimport cv2\r\n\r\ncur_frame = Image.fromarray(cv2.cvtColor(frame,cv2.COLOR_BGR2RGB))\r\ncur_frame = cur_frame.convert('RGB')\r\n```","reactions":{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/635885516/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"niuwenju","id":37408618,"node_id":"MDQ6VXNlcjM3NDA4NjE4","avatar_url":"https://avatars.githubusercontent.com/u/37408618?v=4","gravatar_id":"","url":"https://api.github.com/users/niuwenju","html_url":"https://github.com/niuwenju","followers_url":"https://api.github.com/users/niuwenju/followers","following_url":"https://api.github.com/users/niuwenju/following{/other_user}","gists_url":"https://api.github.com/users/niuwenju/gists{/gist_id}","starred_url":"https://api.github.com/users/niuwenju/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/niuwenju/subscriptions","organizations_url":"https://api.github.com/users/niuwenju/orgs","repos_url":"https://api.github.com/users/niuwenju/repos","events_url":"https://api.github.com/users/niuwenju/events{/privacy}","received_events_url":"https://api.github.com/users/niuwenju/received_events","type":"User","site_admin":false}},{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/635886428","html_url":"https://github.com/ahmetgunduz/Real-time-GesRec/issues/69#issuecomment-635886428","issue_url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/69","id":635886428,"node_id":"MDEyOklzc3VlQ29tbWVudDYzNTg4NjQyOA==","user":{"login":"ahmetgunduz","id":16335853,"node_id":"MDQ6VXNlcjE2MzM1ODUz","avatar_url":"https://avatars.githubusercontent.com/u/16335853?v=4","gravatar_id":"","url":"https://api.github.com/users/ahmetgunduz","html_url":"https://github.com/ahmetgunduz","followers_url":"https://api.github.com/users/ahmetgunduz/followers","following_url":"https://api.github.com/users/ahmetgunduz/following{/other_user}","gists_url":"https://api.github.com/users/ahmetgunduz/gists{/gist_id}","starred_url":"https://api.github.com/users/ahmetgunduz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ahmetgunduz/subscriptions","organizations_url":"https://api.github.com/users/ahmetgunduz/orgs","repos_url":"https://api.github.com/users/ahmetgunduz/repos","events_url":"https://api.github.com/users/ahmetgunduz/events{/privacy}","received_events_url":"https://api.github.com/users/ahmetgunduz/received_events","type":"User","site_admin":false},"created_at":"2020-05-29T09:57:50Z","updated_at":"2020-05-29T09:57:50Z","author_association":"OWNER","body":"Aha sorry my bad!. I think there must be something wrong in the image feeding. I would debug and double check that image loaded is the same way as in the training and testing.  ","reactions":{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/635886428/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"ahmetgunduz","id":16335853,"node_id":"MDQ6VXNlcjE2MzM1ODUz","avatar_url":"https://avatars.githubusercontent.com/u/16335853?v=4","gravatar_id":"","url":"https://api.github.com/users/ahmetgunduz","html_url":"https://github.com/ahmetgunduz","followers_url":"https://api.github.com/users/ahmetgunduz/followers","following_url":"https://api.github.com/users/ahmetgunduz/following{/other_user}","gists_url":"https://api.github.com/users/ahmetgunduz/gists{/gist_id}","starred_url":"https://api.github.com/users/ahmetgunduz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ahmetgunduz/subscriptions","organizations_url":"https://api.github.com/users/ahmetgunduz/orgs","repos_url":"https://api.github.com/users/ahmetgunduz/repos","events_url":"https://api.github.com/users/ahmetgunduz/events{/privacy}","received_events_url":"https://api.github.com/users/ahmetgunduz/received_events","type":"User","site_admin":false}},{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/636479130","html_url":"https://github.com/ahmetgunduz/Real-time-GesRec/issues/69#issuecomment-636479130","issue_url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/69","id":636479130,"node_id":"MDEyOklzc3VlQ29tbWVudDYzNjQ3OTEzMA==","user":{"login":"wlzxzq","id":38395886,"node_id":"MDQ6VXNlcjM4Mzk1ODg2","avatar_url":"https://avatars.githubusercontent.com/u/38395886?v=4","gravatar_id":"","url":"https://api.github.com/users/wlzxzq","html_url":"https://github.com/wlzxzq","followers_url":"https://api.github.com/users/wlzxzq/followers","following_url":"https://api.github.com/users/wlzxzq/following{/other_user}","gists_url":"https://api.github.com/users/wlzxzq/gists{/gist_id}","starred_url":"https://api.github.com/users/wlzxzq/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/wlzxzq/subscriptions","organizations_url":"https://api.github.com/users/wlzxzq/orgs","repos_url":"https://api.github.com/users/wlzxzq/repos","events_url":"https://api.github.com/users/wlzxzq/events{/privacy}","received_events_url":"https://api.github.com/users/wlzxzq/received_events","type":"User","site_admin":false},"created_at":"2020-05-31T14:31:38Z","updated_at":"2020-05-31T14:31:38Z","author_association":"NONE","body":"> Hi,i have retrain the model into RGB,and have successfully tested with images(with test dataset),but when i test with video,prediction_det is alway 0.there is my script for video\r\n> \r\n> ```\r\n> import os\r\n> import glob\r\n> import json\r\n> import pandas as pd\r\n> import numpy as np\r\n> import csv\r\n> import torch\r\n> import time\r\n> from torch.autograd import Variable\r\n> from PIL import Image\r\n> import cv2\r\n> from torch.nn import functional as F\r\n> \r\n> from opts import parse_opts_online\r\n> from model import generate_model\r\n> from mean import get_mean, get_std\r\n> from spatial_transforms import *\r\n> from temporal_transforms import *\r\n> from target_transforms import ClassLabel\r\n> from dataset import get_online_data\r\n> from utils import  AverageMeter, LevenshteinDistance, Queue\r\n> \r\n> import pdb\r\n> import numpy as np\r\n> import datetime\r\n> \r\n> \r\n> def weighting_func(x):\r\n>     return (1 / (1 + np.exp(-0.2 * (x - 9))))\r\n> \r\n> \r\n> opt = parse_opts_online()\r\n> \r\n> \r\n> def load_models(opt):\r\n>     opt.resume_path = opt.resume_path_det\r\n>     opt.pretrain_path = opt.pretrain_path_det\r\n>     opt.sample_duration = opt.sample_duration_det\r\n>     opt.model = opt.model_det\r\n>     opt.model_depth = opt.model_depth_det\r\n>     opt.width_mult = opt.width_mult_det\r\n>     opt.modality = opt.modality_det\r\n>     opt.resnet_shortcut = opt.resnet_shortcut_det\r\n>     opt.n_classes = opt.n_classes_det\r\n>     opt.n_finetune_classes = opt.n_finetune_classes_det\r\n> \r\n>     if opt.root_path != '':\r\n>         opt.video_path = os.path.join(opt.root_path, opt.video_path)\r\n>         opt.annotation_path = os.path.join(opt.root_path, opt.annotation_path)\r\n>         opt.result_path = os.path.join(opt.root_path, opt.result_path)\r\n>         if opt.resume_path:\r\n>             opt.resume_path = os.path.join(opt.root_path, opt.resume_path)\r\n>         if opt.pretrain_path:\r\n>             opt.pretrain_path = os.path.join(opt.root_path, opt.pretrain_path)\r\n> \r\n>     opt.scales = [opt.initial_scale]\r\n>     for i in range(1, opt.n_scales):\r\n>         opt.scales.append(opt.scales[-1] * opt.scale_step)\r\n>     opt.arch = '{}'.format(opt.model)\r\n>     opt.mean = get_mean(opt.norm_value)\r\n>     opt.std = get_std(opt.norm_value)\r\n> \r\n>     print(opt)\r\n>     with open(os.path.join(opt.result_path, 'opts_det.json'), 'w') as opt_file:\r\n>         json.dump(vars(opt), opt_file)\r\n> \r\n>     torch.manual_seed(opt.manual_seed)\r\n> \r\n>     detector, parameters = generate_model(opt)\r\n>     detector = detector.cuda()\r\n>     if opt.resume_path:\r\n>         opt.resume_path = os.path.join(opt.root_path, opt.resume_path)\r\n>         print('loading checkpoint {}'.format(opt.resume_path))\r\n>         checkpoint = torch.load(opt.resume_path)\r\n> \r\n>         detector.load_state_dict(checkpoint['state_dict'])\r\n> \r\n>     print('Model 1 \\n', detector)\r\n>     pytorch_total_params = sum(p.numel() for p in detector.parameters() if\r\n>                                p.requires_grad)\r\n>     print(\"Total number of trainable parameters: \", pytorch_total_params)\r\n> \r\n>     opt.resume_path = opt.resume_path_clf\r\n>     opt.pretrain_path = opt.pretrain_path_clf\r\n>     opt.sample_duration = opt.sample_duration_clf\r\n>     opt.model = opt.model_clf\r\n>     opt.model_depth = opt.model_depth_clf\r\n>     opt.width_mult = opt.width_mult_clf\r\n>     opt.modality = opt.modality_clf\r\n>     opt.resnet_shortcut = opt.resnet_shortcut_clf\r\n>     opt.n_classes = opt.n_classes_clf\r\n>     opt.n_finetune_classes = opt.n_finetune_classes_clf\r\n>     if opt.root_path != '':\r\n>         opt.video_path = os.path.join(opt.root_path, opt.video_path)\r\n>         opt.annotation_path = os.path.join(opt.root_path, opt.annotation_path)\r\n>         opt.result_path = os.path.join(opt.root_path, opt.result_path)\r\n>         if opt.resume_path:\r\n>             opt.resume_path = os.path.join(opt.root_path, opt.resume_path)\r\n>         if opt.pretrain_path:\r\n>             opt.pretrain_path = os.path.join(opt.root_path, opt.pretrain_path)\r\n> \r\n>     opt.scales = [opt.initial_scale]\r\n>     for i in range(1, opt.n_scales):\r\n>         opt.scales.append(opt.scales[-1] * opt.scale_step)\r\n>     opt.arch = '{}'.format(opt.model)\r\n>     opt.mean = get_mean(opt.norm_value)\r\n>     opt.std = get_std(opt.norm_value)\r\n> \r\n>     print(opt)\r\n>     with open(os.path.join(opt.result_path, 'opts_clf.json'), 'w') as opt_file:\r\n>         json.dump(vars(opt), opt_file)\r\n> \r\n>     torch.manual_seed(opt.manual_seed)\r\n>     classifier, parameters = generate_model(opt)\r\n>     classifier = classifier.cuda()\r\n>     if opt.resume_path:\r\n>         print('loading checkpoint {}'.format(opt.resume_path))\r\n>         checkpoint = torch.load(opt.resume_path)\r\n> \r\n>         classifier.load_state_dict(checkpoint['state_dict'])\r\n> \r\n>     print('Model 2 \\n', classifier)\r\n>     pytorch_total_params = sum(p.numel() for p in classifier.parameters() if\r\n>                                p.requires_grad)\r\n>     print(\"Total number of trainable parameters: \", pytorch_total_params)\r\n> \r\n>     return detector, classifier\r\n> \r\n> \r\n> detector, classifier = load_models(opt)\r\n> \r\n> if opt.no_mean_norm and not opt.std_norm:\r\n>     norm_method = Normalize([0, 0, 0], [1, 1, 1])\r\n> elif not opt.std_norm:\r\n>     norm_method = Normalize(opt.mean, [1, 1, 1])\r\n> else:\r\n>     norm_method = Normalize(opt.mean, opt.std)\r\n> \r\n> spatial_transform = Compose([\r\n>     Scale(112),\r\n>     CenterCrop(112),\r\n>     ToTensor(opt.norm_value), norm_method\r\n> ])\r\n> \r\n> opt.sample_duration = max(opt.sample_duration_clf, opt.sample_duration_det)\r\n> fps = \"\"\r\n> cap = cv2.VideoCapture('rgb7.mp4')\r\n> num_frame = 0\r\n> clip = []\r\n> while cap.isOpened():\r\n>     \r\n>     ret, frame = cap.read()\r\n>     print(\"num_frame\",num_frame)\r\n>     if num_frame == 0:\r\n>         cur_frame = Image.fromarray(cv2.cvtColor(frame,cv2.COLOR_BGR2RGB))\r\n>         cur_frame = cur_frame.convert('RGB')\r\n>         for i in range(opt.sample_duration):\r\n>             clip.append(cur_frame)\r\n>         clip = [spatial_transform(img) for img in clip]\r\n>     num_frame += 1\r\n>     active_index = 0\r\n>     passive_count = 0\r\n>     active = False\r\n>     prev_active = False\r\n>     finished_prediction = None\r\n>     pre_predict = False\r\n> \r\n>     cum_sum = np.zeros(opt.n_classes_clf, )\r\n>     clf_selected_queue = np.zeros(opt.n_classes_clf, )\r\n>     det_selected_queue = np.zeros(opt.n_classes_det, )\r\n>     myqueue_det = Queue(opt.det_queue_size, n_classes=opt.n_classes_det)\r\n>     myqueue_clf = Queue(opt.clf_queue_size, n_classes=opt.n_classes_clf)\r\n>     clip.pop(0)\r\n>     _frame = Image.fromarray(cv2.cvtColor(frame,cv2.COLOR_BGR2RGB))\r\n>     _frame = cur_frame.convert('RGB')\r\n>     _frame = spatial_transform(_frame)\r\n>     clip.append(_frame)\r\n>     im_dim = clip[0].size()[-2:]\r\n>     try:\r\n>         test_data = torch.cat(clip, 0).view((opt.sample_duration, -1) + im_dim).permute(1, 0, 2, 3)\r\n>     except Exception as e:\r\n>         pdb.set_trace()\r\n>         raise e\r\n>     test_data = (test_data,0)\r\n>     test_loader = torch.utils.data.DataLoader(\r\n>         test_data,\r\n>         batch_size=opt.batch_size,\r\n>         shuffle=False,\r\n>         num_workers=opt.n_threads,\r\n>         pin_memory=True)\r\n> \r\n>     results = []\r\n>     prev_best1 = opt.n_classes_clf\r\n>     dataset_len = len(test_loader.dataset)\r\n>     num_i = 0\r\n>     for i, (inputs) in enumerate(test_loader):\r\n>         if num_i == 0:\r\n>             ground_truth_array = np.zeros(opt.n_classes_clf + 1, )\r\n>             t2 = time.time()\r\n>             with torch.no_grad():\r\n>                 inputs = Variable(inputs)\r\n>                 print(\"*****************\",inputs.size())\r\n>                 if opt.modality_det == 'RGB':\r\n>                     inputs_det = inputs[:, :, -opt.sample_duration_det:, :, :]\r\n>                 elif opt.modality_det == 'Depth':\r\n>                     inputs_det = inputs[:, -1, -opt.sample_duration_det:, :, :].unsqueeze(1)\r\n>                 elif opt.modality_det == 'RGB-D':\r\n>                     inputs_det = inputs[:, :, -opt.sample_duration_det:, :, :]\r\n> \r\n>                 outputs_det = detector(inputs_det)\r\n>                 outputs_det = F.softmax(outputs_det, dim=1)\r\n>                 outputs_det = outputs_det.cpu().numpy()[0].reshape(-1, )\r\n> \r\n>                 myqueue_det.enqueue(outputs_det.tolist())\r\n> \r\n>                 if opt.det_strategy == 'raw':\r\n>                     det_selected_queue = outputs_det\r\n>                 elif opt.det_strategy == 'median':\r\n>                     det_selected_queue = myqueue_det.median\r\n>                 elif opt.det_strategy == 'ma':\r\n>                     det_selected_queue = myqueue_det.ma\r\n>                 elif opt.det_strategy == 'ewma':\r\n>                     det_selected_queue = myqueue_det.ewma\r\n> \r\n>                 prediction_det = np.argmax(det_selected_queue)\r\n>                 prob_det = det_selected_queue[prediction_det]\r\n>                 print(\"prediction_det:\",prediction_det)\r\n>                 \r\n>                 if prediction_det == 1:\r\n>                     if opt.modality_clf == 'RGB':\r\n>                         inputs_clf = inputs[:, :, :, :, :]\r\n>                     elif opt.modality_clf == 'Depth':\r\n>                         inputs_clf = inputs[:, -1, :, :, :].unsqueeze(1)\r\n>                     elif opt.modality_clf == 'RGB-D':\r\n>                         inputs_clf = inputs[:, :, :, :, :]\r\n>                     inputs_clf = torch.Tensor(inputs_clf.numpy()[:,:,::2,:,:])\r\n>                     outputs_clf = classifier(inputs_clf)\r\n>                     outputs_clf = F.softmax(outputs_clf, dim=1)\r\n>                     outputs_clf = outputs_clf.cpu().numpy()[0].reshape(-1, )\r\n> \r\n>                     myqueue_clf.enqueue(outputs_clf.tolist())\r\n>                     passive_count = 0\r\n> \r\n>                     if opt.clf_strategy == 'raw':\r\n>                         clf_selected_queue = outputs_clf\r\n>                     elif opt.clf_strategy == 'median':\r\n>                         clf_selected_queue = myqueue_clf.median\r\n>                     elif opt.clf_strategy == 'ma':\r\n>                         clf_selected_queue = myqueue_clf.ma\r\n>                     elif opt.clf_strategy == 'ewma':\r\n>                         clf_selected_queue = myqueue_clf.ewma\r\n> \r\n>                 else:\r\n>                     outputs_clf = np.zeros(opt.n_classes_clf, )\r\n>                     # Push the probabilities to queue\r\n>                     myqueue_clf.enqueue(outputs_clf.tolist())\r\n>                     passive_count += 1\r\n>             \r\n>             if passive_count >= opt.det_counter or i == (dataset_len -2):\r\n>                 active = False\r\n>             else:\r\n>                 active = True\r\n> \r\n>             if active:\r\n>                 active_index += 1\r\n>                 cum_sum = ((cum_sum * (active_index - 1)) + (\r\n>                             weighting_func(active_index) * clf_selected_queue)) / active_index  # Weighted Aproach\r\n> \r\n>                 best2, best1 = tuple(cum_sum.argsort()[-2:][::1])\r\n>                 if float(cum_sum[best1] - cum_sum[best2]) > opt.clf_threshold_pre:\r\n>                     finished_prediction = True\r\n>                     pre_predict = True\r\n> \r\n>             else:\r\n>                 active_index = 0\r\n> \r\n>             if active == False and prev_active == True:\r\n>                 finished_prediction = True\r\n>             elif active == True and prev_active == False:\r\n>                 finished_prediction = False\r\n> \r\n> \r\n>             if finished_prediction == True:\r\n>                 best2, best1 = tuple(cum_sum.argsort()[-2:][::1])\r\n>                 if cum_sum[best1] > opt.clf_threshold_final:\r\n>                     if pre_predict == True:\r\n>                         if best1 != prev_best1:\r\n>                             if cum_sum[best1] > opt.clf_threshold_final:\r\n>                                 results.append(((i * opt.stride_len) + opt.sample_duration_clf, best1))\r\n>                                 print('Early Detected - class : {} with prob : {} at frame {}'.format(best1, cum_sum[best1],\r\n>                                                                                                       (\r\n>                                                                                                                   i * opt.stride_len) + opt.sample_duration_clf))\r\n>                     else:\r\n>                         if cum_sum[best1] > opt.clf_threshold_final:\r\n>                             if best1 == prev_best1:\r\n>                                 if cum_sum[best1] > 5:\r\n>                                     results.append(((i * opt.stride_len) + opt.sample_duration_clf, best1))\r\n>                                     print('Late Detected - class : {} with prob : {} at frame {}'.format(best1,\r\n>                                                                                                          cum_sum[best1], (\r\n>                                                                                                                      i * opt.stride_len) + opt.sample_duration_clf))\r\n>                             else:\r\n>                                 results.append(((i * opt.stride_len) + opt.sample_duration_clf, best1))\r\n> \r\n>                                 print('Late Detected - class : {} with prob : {} at frame {}'.format(best1, cum_sum[best1],\r\n>                                                                                                      (\r\n>                                                                                                                  i * opt.stride_len) + opt.sample_duration_clf))\r\n> \r\n>                     finished_prediction = False\r\n>                     prev_best1 = best1\r\n> \r\n>                 cum_sum = np.zeros(opt.n_classes_clf, )\r\n>             \r\n>             if active == False and prev_active == True:\r\n>                 pre_predict = False\r\n> \r\n>             prev_active = active\r\n>             num_i += 1\r\n>             elapsedTime = time.time() - t2\r\n>             fps2 = \"(Playback) {:.1f} FPS\".format(1/elapsedTime)\r\n>             t1 = time.time()\r\n>             break\r\n>         else:\r\n>             break\r\n>     elapsedTime = time.time() - t1\r\n>     fps1 = \"(Playback) {:.1f} FPS\".format(1/elapsedTime)\r\n>     if len(results) != 0:\r\n>         predicted = np.array(results)[:, 1]\r\n>     else:\r\n>         predicted = []\r\n>     print('predicted classes: \\t', predicted)\r\n>     cv2.putText(frame, fps, (0, 15), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (38, 0, 255), 1, cv2.LINE_AA)\r\n>     cv2.imshow(\"Result\", frame)\r\n>     if cv2.waitKey(1)&0xFF == ord('q'):\r\n>         break\r\n>     #elapsedTime = time.time() - t1\r\n>     #fps = \"(Playback) {:.1f} FPS\".format(1/elapsedTime)\r\n> cv2.destroyAllWindows()\r\n> ```\r\n> \r\n> and the result is:\r\n> ***************** torch.Size([1, 3, 32, 112, 112])\r\n> **prediction_det: 0 predicted classes: []**\r\n> num_frame 437\r\n您好，能加您QQ，想问下您如何跑起来的么","reactions":{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/636479130/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"wlzxzq","id":38395886,"node_id":"MDQ6VXNlcjM4Mzk1ODg2","avatar_url":"https://avatars.githubusercontent.com/u/38395886?v=4","gravatar_id":"","url":"https://api.github.com/users/wlzxzq","html_url":"https://github.com/wlzxzq","followers_url":"https://api.github.com/users/wlzxzq/followers","following_url":"https://api.github.com/users/wlzxzq/following{/other_user}","gists_url":"https://api.github.com/users/wlzxzq/gists{/gist_id}","starred_url":"https://api.github.com/users/wlzxzq/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/wlzxzq/subscriptions","organizations_url":"https://api.github.com/users/wlzxzq/orgs","repos_url":"https://api.github.com/users/wlzxzq/repos","events_url":"https://api.github.com/users/wlzxzq/events{/privacy}","received_events_url":"https://api.github.com/users/wlzxzq/received_events","type":"User","site_admin":false}},{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/636761652","html_url":"https://github.com/ahmetgunduz/Real-time-GesRec/issues/69#issuecomment-636761652","issue_url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/69","id":636761652,"node_id":"MDEyOklzc3VlQ29tbWVudDYzNjc2MTY1Mg==","user":{"login":"niuwenju","id":37408618,"node_id":"MDQ6VXNlcjM3NDA4NjE4","avatar_url":"https://avatars.githubusercontent.com/u/37408618?v=4","gravatar_id":"","url":"https://api.github.com/users/niuwenju","html_url":"https://github.com/niuwenju","followers_url":"https://api.github.com/users/niuwenju/followers","following_url":"https://api.github.com/users/niuwenju/following{/other_user}","gists_url":"https://api.github.com/users/niuwenju/gists{/gist_id}","starred_url":"https://api.github.com/users/niuwenju/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/niuwenju/subscriptions","organizations_url":"https://api.github.com/users/niuwenju/orgs","repos_url":"https://api.github.com/users/niuwenju/repos","events_url":"https://api.github.com/users/niuwenju/events{/privacy}","received_events_url":"https://api.github.com/users/niuwenju/received_events","type":"User","site_admin":false},"created_at":"2020-06-01T10:14:11Z","updated_at":"2020-06-01T10:33:00Z","author_association":"NONE","body":"Hi, i have updated the script as follows\r\n\r\n```\r\nimport os\r\nimport glob\r\nimport json\r\nimport pandas as pd\r\nimport numpy as np\r\nimport csv\r\nimport torch\r\nimport time\r\nfrom torch.autograd import Variable\r\nfrom PIL import Image\r\nimport cv2\r\nfrom torch.nn import functional as F\r\n\r\nfrom opts import parse_opts_online\r\nfrom model import generate_model\r\nfrom mean import get_mean, get_std\r\nfrom spatial_transforms import *\r\nfrom temporal_transforms import *\r\nfrom target_transforms import ClassLabel\r\nfrom dataset import get_online_data\r\nfrom utils import  AverageMeter, LevenshteinDistance, Queue\r\n\r\nimport pdb\r\nimport numpy as np\r\nimport datetime\r\n\r\n\r\ndef weighting_func(x):\r\n    return (1 / (1 + np.exp(-0.2 * (x - 9))))\r\n\r\n\r\nopt = parse_opts_online()\r\n\r\n\r\ndef load_models(opt):\r\n    opt.resume_path = opt.resume_path_det\r\n    opt.pretrain_path = opt.pretrain_path_det\r\n    opt.sample_duration = opt.sample_duration_det\r\n    opt.model = opt.model_det\r\n    opt.model_depth = opt.model_depth_det\r\n    opt.width_mult = opt.width_mult_det\r\n    opt.modality = opt.modality_det\r\n    opt.resnet_shortcut = opt.resnet_shortcut_det\r\n    opt.n_classes = opt.n_classes_det\r\n    opt.n_finetune_classes = opt.n_finetune_classes_det\r\n\r\n    if opt.root_path != '':\r\n        opt.video_path = os.path.join(opt.root_path, opt.video_path)\r\n        opt.annotation_path = os.path.join(opt.root_path, opt.annotation_path)\r\n        opt.result_path = os.path.join(opt.root_path, opt.result_path)\r\n        if opt.resume_path:\r\n            opt.resume_path = os.path.join(opt.root_path, opt.resume_path)\r\n        if opt.pretrain_path:\r\n            opt.pretrain_path = os.path.join(opt.root_path, opt.pretrain_path)\r\n\r\n    opt.scales = [opt.initial_scale]\r\n    for i in range(1, opt.n_scales):\r\n        opt.scales.append(opt.scales[-1] * opt.scale_step)\r\n    opt.arch = '{}'.format(opt.model)\r\n    opt.mean = get_mean(opt.norm_value)\r\n    opt.std = get_std(opt.norm_value)\r\n\r\n    print(opt)\r\n    with open(os.path.join(opt.result_path, 'opts_det.json'), 'w') as opt_file:\r\n        json.dump(vars(opt), opt_file)\r\n\r\n    torch.manual_seed(opt.manual_seed)\r\n\r\n    detector, parameters = generate_model(opt)\r\n    detector = detector.cuda()\r\n    if opt.resume_path:\r\n        opt.resume_path = os.path.join(opt.root_path, opt.resume_path)\r\n        print('loading checkpoint {}'.format(opt.resume_path))\r\n        checkpoint = torch.load(opt.resume_path)\r\n        #assert opt.arch == checkpoint['arch']\r\n\r\n        detector.load_state_dict(checkpoint['state_dict'])\r\n\r\n    print('Model 1 \\n', detector)\r\n    pytorch_total_params = sum(p.numel() for p in detector.parameters() if\r\n                               p.requires_grad)\r\n    print(\"Total number of trainable parameters: \", pytorch_total_params)\r\n\r\n    opt.resume_path = opt.resume_path_clf\r\n    opt.pretrain_path = opt.pretrain_path_clf\r\n    opt.sample_duration = opt.sample_duration_clf\r\n    opt.model = opt.model_clf\r\n    opt.model_depth = opt.model_depth_clf\r\n    opt.width_mult = opt.width_mult_clf\r\n    opt.modality = opt.modality_clf\r\n    opt.resnet_shortcut = opt.resnet_shortcut_clf\r\n    opt.n_classes = opt.n_classes_clf\r\n    opt.n_finetune_classes = opt.n_finetune_classes_clf\r\n    if opt.root_path != '':\r\n        opt.video_path = os.path.join(opt.root_path, opt.video_path)\r\n        opt.annotation_path = os.path.join(opt.root_path, opt.annotation_path)\r\n        opt.result_path = os.path.join(opt.root_path, opt.result_path)\r\n        if opt.resume_path:\r\n            opt.resume_path = os.path.join(opt.root_path, opt.resume_path)\r\n        if opt.pretrain_path:\r\n            opt.pretrain_path = os.path.join(opt.root_path, opt.pretrain_path)\r\n\r\n    opt.scales = [opt.initial_scale]\r\n    for i in range(1, opt.n_scales):\r\n        opt.scales.append(opt.scales[-1] * opt.scale_step)\r\n    opt.arch = '{}'.format(opt.model)\r\n    opt.mean = get_mean(opt.norm_value)\r\n    opt.std = get_std(opt.norm_value)\r\n\r\n    print(opt)\r\n    with open(os.path.join(opt.result_path, 'opts_clf.json'), 'w') as opt_file:\r\n        json.dump(vars(opt), opt_file)\r\n\r\n    torch.manual_seed(opt.manual_seed)\r\n    classifier, parameters = generate_model(opt)\r\n    classifier = classifier.cuda()\r\n    if opt.resume_path:\r\n        print('loading checkpoint {}'.format(opt.resume_path))\r\n        checkpoint = torch.load(opt.resume_path)\r\n#        assert opt.arch == checkpoint['arch']\r\n\r\n        classifier.load_state_dict(checkpoint['state_dict'])\r\n\r\n    print('Model 2 \\n', classifier)\r\n    pytorch_total_params = sum(p.numel() for p in classifier.parameters() if\r\n                               p.requires_grad)\r\n    print(\"Total number of trainable parameters: \", pytorch_total_params)\r\n\r\n    return detector, classifier\r\n\r\n\r\ndetector, classifier = load_models(opt)\r\n\r\nif opt.no_mean_norm and not opt.std_norm:\r\n    norm_method = Normalize([0, 0, 0], [1, 1, 1])\r\nelif not opt.std_norm:\r\n    norm_method = Normalize(opt.mean, [1, 1, 1])\r\nelse:\r\n    norm_method = Normalize(opt.mean, opt.std)\r\n\r\nspatial_transform = Compose([\r\n    Scale(112),\r\n    CenterCrop(112),\r\n    ToTensor(opt.norm_value), norm_method\r\n])\r\n\r\n#target_transform = ClassLabel()\r\nopt.sample_duration = max(opt.sample_duration_clf, opt.sample_duration_det)\r\n#cur_frame = np.array([[[0 for j in range(240)] for i in range(320) ] for z in range(4)])\r\n#cur_frame = Image.fromarray(cv2.cvtColor(cur_frame,cv2.COLOR_BGR2RGB))\r\n#cur_frame = cur_frame.convert('RGB')\r\n#test_data = [cur_frame * opt.sample_duration]\r\nfps = \"\"\r\ncap = cv2.VideoCapture('rgb7.avi')\r\nnum_frame = 0\r\nclip = []\r\nactive_index = 0\r\npassive_count = 0\r\nactive = False\r\nprev_active = False\r\nfinished_prediction = None\r\npre_predict = False\r\n\r\ncum_sum = np.zeros(opt.n_classes_clf, )\r\nclf_selected_queue = np.zeros(opt.n_classes_clf, )\r\ndet_selected_queue = np.zeros(opt.n_classes_det, )\r\nmyqueue_det = Queue(opt.det_queue_size, n_classes=opt.n_classes_det)\r\nmyqueue_clf = Queue(opt.clf_queue_size, n_classes=opt.n_classes_clf)\r\nresults = []\r\nprev_best1 = opt.n_classes_clf\r\nspatial_transform.randomize_parameters()\r\nwhile cap.isOpened():\r\n    t1 = time.time()\r\n    ret, frame = cap.read()\r\n    #print(\"num_frame\",num_frame)\r\n    if num_frame == 0:\r\n        #name = str(time.time())\r\n        #cv2.imwrite('cur.jpg',frame)\r\n        cur_frame = Image.fromarray(cv2.cvtColor(frame,cv2.COLOR_BGR2RGB))\r\n        cur_frame = cur_frame.convert('RGB')\r\n        #cur_frame = Image.open('cur.jpg')\r\n        for i in range(opt.sample_duration):\r\n            clip.append(cur_frame)\r\n        #spatial_transform.randomize_parameters()\r\n        clip = [spatial_transform(img) for img in clip]\r\n    #num_frame += 1\r\n    #videoidx += 1\r\n\r\n\r\n    #print('[{}/{}]============'.format(videoidx, len(test_paths)))\r\n    #print(path)\r\n\r\n    #temporal_transform = TemporalRandomCrop(opt.sample_duration, opt.downsample)\r\n    #test_data = get_online_data(\r\n     #   opt, spatial_transform, None, target_transform)\r\n    clip.pop(0)\r\n    #name = str(time.time())\r\n    #cv2.imwrite('cur.jpg',frame)\r\n    _frame = Image.fromarray(cv2.cvtColor(frame,cv2.COLOR_BGR2RGB))\r\n    _frame = _frame.convert('RGB')\r\n    #_frame = Image.open('cur.jpg')\r\n    _frame = spatial_transform(_frame)\r\n    clip.append(_frame)\r\n    #test_data = [spatial_transform(img) for img in test_data]\r\n    im_dim = clip[0].size()[-2:]\r\n    #print(test_data[0].size())\r\n    #print(im_dim)\r\n    #print(test_data[0].size)\r\n    try:\r\n        test_data = torch.cat(clip, 0).view((opt.sample_duration, -1) + im_dim).permute(1, 0, 2, 3)\r\n    except Exception as e:\r\n        pdb.set_trace()\r\n        raise e\r\n    #print(test_data.size())\r\n    test_data = (test_data,num_frame)\r\n    num_frame += 1\r\n    test_loader = torch.utils.data.DataLoader(\r\n        test_data,\r\n        batch_size=opt.batch_size,\r\n        shuffle=False,\r\n        num_workers=opt.n_threads,\r\n        pin_memory=True)\r\n\r\n\r\n    dataset_len = len(test_loader.dataset)\r\n    #t1 = time.time()\r\n    num_i = 0\r\n    #curr = test_loader.__iter__()\r\n    #print(curr.size)\r\n    for i, (inputs) in enumerate(test_loader):\r\n        if num_i == 0:\r\n        #if not opt.no_cuda:\r\n            #targets = targets.cuda()\r\n            ground_truth_array = np.zeros(opt.n_classes_clf + 1, )\r\n            #t2 = time.time()\r\n            with torch.no_grad():\r\n                inputs = Variable(inputs)\r\n                print(\"image feeding size of det\",inputs.size())\r\n                #targets = Variable(targets)\r\n                #t1 = time.time()\r\n                if opt.modality_det == 'RGB':\r\n                    inputs_det = inputs[:, :, -opt.sample_duration_det:, :, :]\r\n                elif opt.modality_det == 'Depth':\r\n                    inputs_det = inputs[:, -1, -opt.sample_duration_det:, :, :].unsqueeze(1)\r\n                elif opt.modality_det == 'RGB-D':\r\n                    inputs_det = inputs[:, :, -opt.sample_duration_det:, :, :]\r\n\r\n                outputs_det = detector(inputs_det)\r\n                #print(\"outputs_det1\",outputs_det)\r\n                outputs_det = F.softmax(outputs_det, dim=1)\r\n                #print(\"outputs_det2\",outputs_det)\r\n                outputs_det = outputs_det.cpu().numpy()[0].reshape(-1, )\r\n                #print(\"outputs_det3\",outputs_det)\r\n                # enqueue the probabilities to the detector queue\r\n                myqueue_det.enqueue(outputs_det.tolist())\r\n\r\n                if opt.det_strategy == 'raw':\r\n                    det_selected_queue = outputs_det\r\n                elif opt.det_strategy == 'median':\r\n                    det_selected_queue = myqueue_det.median\r\n                elif opt.det_strategy == 'ma':\r\n                    det_selected_queue = myqueue_det.ma\r\n                elif opt.det_strategy == 'ewma':\r\n                    det_selected_queue = myqueue_det.ewma\r\n                print(\"det_selected_queue:\",det_selected_queue)\r\n                prediction_det = np.argmax(det_selected_queue)\r\n                #print(\"prediction_det:\",prediction_det)\r\n                prob_det = det_selected_queue[prediction_det]\r\n                #print(\"prediction_det:\",prediction_det)\r\n                \r\n                #### State of the detector is checked here as detector act as a switch for the classifier\r\n                if prediction_det == 1:\r\n                    if opt.modality_clf == 'RGB':\r\n                        inputs_clf = inputs[:, :, :, :, :]\r\n                    elif opt.modality_clf == 'Depth':\r\n                        inputs_clf = inputs[:, -1, :, :, :].unsqueeze(1)\r\n                    elif opt.modality_clf == 'RGB-D':\r\n                        inputs_clf = inputs[:, :, :, :, :]\r\n                    inputs_clf = torch.Tensor(inputs_clf.numpy()[:,:,::1,:,:])\r\n                    outputs_clf = classifier(inputs_clf)\r\n                    outputs_clf = F.softmax(outputs_clf, dim=1)\r\n                    outputs_clf = outputs_clf.cpu().numpy()[0].reshape(-1, )\r\n                    #print(\"outputs_clf1:\",outputs_clf)\r\n                    # Push the probabilities to queue\r\n                    myqueue_clf.enqueue(outputs_clf.tolist())\r\n                    passive_count = 0\r\n\r\n                    if opt.clf_strategy == 'raw':\r\n                        clf_selected_queue = outputs_clf\r\n                    elif opt.clf_strategy == 'median':\r\n                        clf_selected_queue = myqueue_clf.median\r\n                    elif opt.clf_strategy == 'ma':\r\n                        clf_selected_queue = myqueue_clf.ma\r\n                    elif opt.clf_strategy == 'ewma':\r\n                        clf_selected_queue = myqueue_clf.ewma\r\n\r\n                else:\r\n                    outputs_clf = np.zeros(opt.n_classes_clf, )\r\n                    # Push the probabilities to queue\r\n                    myqueue_clf.enqueue(outputs_clf.tolist())\r\n                    passive_count += 1\r\n            #t1 = time.time()\r\n            \r\n            #if passive_count >= opt.det_counter or i == (dataset_len -2):\r\n            if passive_count >= opt.det_counter:\r\n                active = False\r\n            else:\r\n                active = True\r\n\r\n            # one of the following line need to be commented !!!!\r\n            if active:\r\n                active_index += 1\r\n                cum_sum = ((cum_sum * (active_index - 1)) + (\r\n                            weighting_func(active_index) * clf_selected_queue)) / active_index  # Weighted Aproach\r\n                # cum_sum = ((cum_sum * (x-1)) + (1.0 * clf_selected_queue))/x #Not Weighting Aproach\r\n                #print(\"cum_sum:\",cum_sum)\r\n                #print(\"***********\",cum_sum[best1],cum_sum[best2])\r\n                best2, best1 = tuple(cum_sum.argsort()[-2:][::1])\r\n                #print(\"***********\",cum_sum[best1],cum_sum[best2])\r\n                if float(cum_sum[best1] - cum_sum[best2]) > opt.clf_threshold_pre:\r\n                    finished_prediction = True\r\n                    pre_predict = True\r\n\r\n            else:\r\n                active_index = 0\r\n            #print(\"finished_prediction1:\",finished_prediction)\r\n            if active == False and prev_active == True:\r\n                finished_prediction = True\r\n            elif active == True and prev_active == False:\r\n                finished_prediction = False\r\n\r\n            #print(\"finished_prediction2:\",finished_prediction)\r\n            if finished_prediction == True:\r\n                best2, best1 = tuple(cum_sum.argsort()[-2:][::1])\r\n                if cum_sum[best1] > opt.clf_threshold_final:\r\n                    if pre_predict == True:\r\n                        if best1 != prev_best1:\r\n                            if cum_sum[best1] > opt.clf_threshold_final:\r\n                                results.append(((i * opt.stride_len) + opt.sample_duration_clf, best1))\r\n                                print('Early Detected - class : {} with prob : {} at frame {}'.format(best1, cum_sum[best1],\r\n                                                                                                      (\r\n                                                                                                                  i * opt.stride_len) + opt.sample_duration_clf))\r\n                    else:\r\n                        if cum_sum[best1] > opt.clf_threshold_final:\r\n                            if best1 == prev_best1:\r\n                                if cum_sum[best1] > 5:\r\n                                    results.append(((i * opt.stride_len) + opt.sample_duration_clf, best1))\r\n                                    print('Late Detected - class : {} with prob : {} at frame {}'.format(best1,\r\n                                                                                                         cum_sum[best1], (\r\n                                                                                                                     i * opt.stride_len) + opt.sample_duration_clf))\r\n                            else:\r\n                                results.append(((i * opt.stride_len) + opt.sample_duration_clf, best1))\r\n\r\n                                print('Late Detected - class : {} with prob : {} at frame {}'.format(best1, cum_sum[best1],\r\n                                                                                                     (\r\n                                                                                                                 i * opt.stride_len) + opt.sample_duration_clf))\r\n\r\n                    finished_prediction = False\r\n                    prev_best1 = best1\r\n\r\n                cum_sum = np.zeros(opt.n_classes_clf, )\r\n            \r\n            if active == False and prev_active == True:\r\n                pre_predict = False\r\n\r\n            prev_active = active\r\n            #print(\"iter:\",num_i)\r\n            num_i += 1\r\n            #elapsedTime = time.time() - t2\r\n            #fps2 = \"(Playback) {:.1f} FPS\".format(1/elapsedTime)\r\n            #t1 = time.time()\r\n            break\r\n        else:\r\n            #print(\"break\")\r\n            break\r\n    elapsedTime = time.time() - t1\r\n    fps = \"(Playback) {:.1f} FPS\".format(1/elapsedTime)\r\n\r\n    if len(results) != 0:\r\n        predicted = np.array(results)[:, 1]\r\n    else:\r\n        predicted = []\r\n\r\n    print('predicted classes: \\t', predicted)\r\n\r\n    cv2.putText(frame, fps, (0, 15), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (38, 0, 255), 1, cv2.LINE_AA)\r\n    #cv2.imshow(\"Result\", frame)\r\n\r\n    if cv2.waitKey(1)&0xFF == ord('q'):\r\n        break\r\ncv2.destroyAllWindows()\r\n```\r\nbut there is also some errors \r\n\r\n_image feeding size of det torch.Size([1, 3, 32, 112, 112])\r\ndet_selected_queue: [0. 0.]\r\npredicted classes: \t []\r\nimage feeding size of det torch.Size([1, 3, 32, 112, 112])\r\ndet_selected_queue: [0.02838171 0.46882075]\r\npredicted classes: \t []\r\nimage feeding size of det torch.Size([1, 3, 32, 112, 112])\r\ndet_selected_queue: [0.05956098 0.93730575]\r\npredicted classes: \t []_\r\n\r\nthe det output is alway 1,but when i test with online_test.py and use the same model, i got this\r\n\r\n_det_selected_queue [0.96007147 0.0399285 ]\r\ndet_selected_queue [0.90416661 0.09583338]\r\ndet_selected_queue [0.45004896 0.54995105]\r\ndet_selected_queue [0.02988628 0.97011372]\r\ndet_selected_queue [0.00114013 0.99885988]_\r\nso there is must be something wrong in the image feeding.\r\nbut i cant figure it out... and the point is it can successfully classify...\r\n\r\n","reactions":{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/636761652/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"niuwenju","id":37408618,"node_id":"MDQ6VXNlcjM3NDA4NjE4","avatar_url":"https://avatars.githubusercontent.com/u/37408618?v=4","gravatar_id":"","url":"https://api.github.com/users/niuwenju","html_url":"https://github.com/niuwenju","followers_url":"https://api.github.com/users/niuwenju/followers","following_url":"https://api.github.com/users/niuwenju/following{/other_user}","gists_url":"https://api.github.com/users/niuwenju/gists{/gist_id}","starred_url":"https://api.github.com/users/niuwenju/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/niuwenju/subscriptions","organizations_url":"https://api.github.com/users/niuwenju/orgs","repos_url":"https://api.github.com/users/niuwenju/repos","events_url":"https://api.github.com/users/niuwenju/events{/privacy}","received_events_url":"https://api.github.com/users/niuwenju/received_events","type":"User","site_admin":false}},{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/637319854","html_url":"https://github.com/ahmetgunduz/Real-time-GesRec/issues/69#issuecomment-637319854","issue_url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/69","id":637319854,"node_id":"MDEyOklzc3VlQ29tbWVudDYzNzMxOTg1NA==","user":{"login":"niuwenju","id":37408618,"node_id":"MDQ6VXNlcjM3NDA4NjE4","avatar_url":"https://avatars.githubusercontent.com/u/37408618?v=4","gravatar_id":"","url":"https://api.github.com/users/niuwenju","html_url":"https://github.com/niuwenju","followers_url":"https://api.github.com/users/niuwenju/followers","following_url":"https://api.github.com/users/niuwenju/following{/other_user}","gists_url":"https://api.github.com/users/niuwenju/gists{/gist_id}","starred_url":"https://api.github.com/users/niuwenju/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/niuwenju/subscriptions","organizations_url":"https://api.github.com/users/niuwenju/orgs","repos_url":"https://api.github.com/users/niuwenju/repos","events_url":"https://api.github.com/users/niuwenju/events{/privacy}","received_events_url":"https://api.github.com/users/niuwenju/received_events","type":"User","site_admin":false},"created_at":"2020-06-02T06:49:05Z","updated_at":"2020-06-02T06:51:22Z","author_association":"NONE","body":"Hi @ahmetgunduz ,i have solved this problem by adding \r\n**detector.eval()\r\nclassifier.eval()**\r\nbefore using them. \r\nThanks for your sharing!","reactions":{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/637319854/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"niuwenju","id":37408618,"node_id":"MDQ6VXNlcjM3NDA4NjE4","avatar_url":"https://avatars.githubusercontent.com/u/37408618?v=4","gravatar_id":"","url":"https://api.github.com/users/niuwenju","html_url":"https://github.com/niuwenju","followers_url":"https://api.github.com/users/niuwenju/followers","following_url":"https://api.github.com/users/niuwenju/following{/other_user}","gists_url":"https://api.github.com/users/niuwenju/gists{/gist_id}","starred_url":"https://api.github.com/users/niuwenju/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/niuwenju/subscriptions","organizations_url":"https://api.github.com/users/niuwenju/orgs","repos_url":"https://api.github.com/users/niuwenju/repos","events_url":"https://api.github.com/users/niuwenju/events{/privacy}","received_events_url":"https://api.github.com/users/niuwenju/received_events","type":"User","site_admin":false}},{"id":3396123638,"node_id":"MDE0Ok1lbnRpb25lZEV2ZW50MzM5NjEyMzYzOA==","url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/events/3396123638","actor":{"login":"ahmetgunduz","id":16335853,"node_id":"MDQ6VXNlcjE2MzM1ODUz","avatar_url":"https://avatars.githubusercontent.com/u/16335853?v=4","gravatar_id":"","url":"https://api.github.com/users/ahmetgunduz","html_url":"https://github.com/ahmetgunduz","followers_url":"https://api.github.com/users/ahmetgunduz/followers","following_url":"https://api.github.com/users/ahmetgunduz/following{/other_user}","gists_url":"https://api.github.com/users/ahmetgunduz/gists{/gist_id}","starred_url":"https://api.github.com/users/ahmetgunduz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ahmetgunduz/subscriptions","organizations_url":"https://api.github.com/users/ahmetgunduz/orgs","repos_url":"https://api.github.com/users/ahmetgunduz/repos","events_url":"https://api.github.com/users/ahmetgunduz/events{/privacy}","received_events_url":"https://api.github.com/users/ahmetgunduz/received_events","type":"User","site_admin":false},"event":"mentioned","commit_id":null,"commit_url":null,"created_at":"2020-06-02T06:51:22Z","performed_via_github_app":null},{"id":3396123640,"node_id":"MDE1OlN1YnNjcmliZWRFdmVudDMzOTYxMjM2NDA=","url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/events/3396123640","actor":{"login":"ahmetgunduz","id":16335853,"node_id":"MDQ6VXNlcjE2MzM1ODUz","avatar_url":"https://avatars.githubusercontent.com/u/16335853?v=4","gravatar_id":"","url":"https://api.github.com/users/ahmetgunduz","html_url":"https://github.com/ahmetgunduz","followers_url":"https://api.github.com/users/ahmetgunduz/followers","following_url":"https://api.github.com/users/ahmetgunduz/following{/other_user}","gists_url":"https://api.github.com/users/ahmetgunduz/gists{/gist_id}","starred_url":"https://api.github.com/users/ahmetgunduz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ahmetgunduz/subscriptions","organizations_url":"https://api.github.com/users/ahmetgunduz/orgs","repos_url":"https://api.github.com/users/ahmetgunduz/repos","events_url":"https://api.github.com/users/ahmetgunduz/events{/privacy}","received_events_url":"https://api.github.com/users/ahmetgunduz/received_events","type":"User","site_admin":false},"event":"subscribed","commit_id":null,"commit_url":null,"created_at":"2020-06-02T06:51:22Z","performed_via_github_app":null},{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/637469890","html_url":"https://github.com/ahmetgunduz/Real-time-GesRec/issues/69#issuecomment-637469890","issue_url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/69","id":637469890,"node_id":"MDEyOklzc3VlQ29tbWVudDYzNzQ2OTg5MA==","user":{"login":"ahmetgunduz","id":16335853,"node_id":"MDQ6VXNlcjE2MzM1ODUz","avatar_url":"https://avatars.githubusercontent.com/u/16335853?v=4","gravatar_id":"","url":"https://api.github.com/users/ahmetgunduz","html_url":"https://github.com/ahmetgunduz","followers_url":"https://api.github.com/users/ahmetgunduz/followers","following_url":"https://api.github.com/users/ahmetgunduz/following{/other_user}","gists_url":"https://api.github.com/users/ahmetgunduz/gists{/gist_id}","starred_url":"https://api.github.com/users/ahmetgunduz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ahmetgunduz/subscriptions","organizations_url":"https://api.github.com/users/ahmetgunduz/orgs","repos_url":"https://api.github.com/users/ahmetgunduz/repos","events_url":"https://api.github.com/users/ahmetgunduz/events{/privacy}","received_events_url":"https://api.github.com/users/ahmetgunduz/received_events","type":"User","site_admin":false},"created_at":"2020-06-02T11:15:48Z","updated_at":"2020-06-02T11:15:48Z","author_association":"OWNER","body":"@niuwenju, that is great. Would yo mind to create a pull request for this?  Many request are coming for this. \r\nBest,\r\n","reactions":{"url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/comments/637469890/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"ahmetgunduz","id":16335853,"node_id":"MDQ6VXNlcjE2MzM1ODUz","avatar_url":"https://avatars.githubusercontent.com/u/16335853?v=4","gravatar_id":"","url":"https://api.github.com/users/ahmetgunduz","html_url":"https://github.com/ahmetgunduz","followers_url":"https://api.github.com/users/ahmetgunduz/followers","following_url":"https://api.github.com/users/ahmetgunduz/following{/other_user}","gists_url":"https://api.github.com/users/ahmetgunduz/gists{/gist_id}","starred_url":"https://api.github.com/users/ahmetgunduz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ahmetgunduz/subscriptions","organizations_url":"https://api.github.com/users/ahmetgunduz/orgs","repos_url":"https://api.github.com/users/ahmetgunduz/repos","events_url":"https://api.github.com/users/ahmetgunduz/events{/privacy}","received_events_url":"https://api.github.com/users/ahmetgunduz/received_events","type":"User","site_admin":false}},{"id":3397150080,"node_id":"MDE0Ok1lbnRpb25lZEV2ZW50MzM5NzE1MDA4MA==","url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/events/3397150080","actor":{"login":"niuwenju","id":37408618,"node_id":"MDQ6VXNlcjM3NDA4NjE4","avatar_url":"https://avatars.githubusercontent.com/u/37408618?v=4","gravatar_id":"","url":"https://api.github.com/users/niuwenju","html_url":"https://github.com/niuwenju","followers_url":"https://api.github.com/users/niuwenju/followers","following_url":"https://api.github.com/users/niuwenju/following{/other_user}","gists_url":"https://api.github.com/users/niuwenju/gists{/gist_id}","starred_url":"https://api.github.com/users/niuwenju/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/niuwenju/subscriptions","organizations_url":"https://api.github.com/users/niuwenju/orgs","repos_url":"https://api.github.com/users/niuwenju/repos","events_url":"https://api.github.com/users/niuwenju/events{/privacy}","received_events_url":"https://api.github.com/users/niuwenju/received_events","type":"User","site_admin":false},"event":"mentioned","commit_id":null,"commit_url":null,"created_at":"2020-06-02T11:15:48Z","performed_via_github_app":null},{"id":3397150082,"node_id":"MDE1OlN1YnNjcmliZWRFdmVudDMzOTcxNTAwODI=","url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/events/3397150082","actor":{"login":"niuwenju","id":37408618,"node_id":"MDQ6VXNlcjM3NDA4NjE4","avatar_url":"https://avatars.githubusercontent.com/u/37408618?v=4","gravatar_id":"","url":"https://api.github.com/users/niuwenju","html_url":"https://github.com/niuwenju","followers_url":"https://api.github.com/users/niuwenju/followers","following_url":"https://api.github.com/users/niuwenju/following{/other_user}","gists_url":"https://api.github.com/users/niuwenju/gists{/gist_id}","starred_url":"https://api.github.com/users/niuwenju/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/niuwenju/subscriptions","organizations_url":"https://api.github.com/users/niuwenju/orgs","repos_url":"https://api.github.com/users/niuwenju/repos","events_url":"https://api.github.com/users/niuwenju/events{/privacy}","received_events_url":"https://api.github.com/users/niuwenju/received_events","type":"User","site_admin":false},"event":"subscribed","commit_id":null,"commit_url":null,"created_at":"2020-06-02T11:15:48Z","performed_via_github_app":null},{"id":3397150294,"node_id":"MDExOkNsb3NlZEV2ZW50MzM5NzE1MDI5NA==","url":"https://api.github.com/repos/ahmetgunduz/Real-time-GesRec/issues/events/3397150294","actor":{"login":"ahmetgunduz","id":16335853,"node_id":"MDQ6VXNlcjE2MzM1ODUz","avatar_url":"https://avatars.githubusercontent.com/u/16335853?v=4","gravatar_id":"","url":"https://api.github.com/users/ahmetgunduz","html_url":"https://github.com/ahmetgunduz","followers_url":"https://api.github.com/users/ahmetgunduz/followers","following_url":"https://api.github.com/users/ahmetgunduz/following{/other_user}","gists_url":"https://api.github.com/users/ahmetgunduz/gists{/gist_id}","starred_url":"https://api.github.com/users/ahmetgunduz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ahmetgunduz/subscriptions","organizations_url":"https://api.github.com/users/ahmetgunduz/orgs","repos_url":"https://api.github.com/users/ahmetgunduz/repos","events_url":"https://api.github.com/users/ahmetgunduz/events{/privacy}","received_events_url":"https://api.github.com/users/ahmetgunduz/received_events","type":"User","site_admin":false},"event":"closed","commit_id":null,"commit_url":null,"created_at":"2020-06-02T11:15:52Z","state_reason":null,"performed_via_github_app":null}]