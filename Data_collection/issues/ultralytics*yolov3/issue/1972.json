{"url":"https://api.github.com/repos/ultralytics/yolov3/issues/1972","repository_url":"https://api.github.com/repos/ultralytics/yolov3","labels_url":"https://api.github.com/repos/ultralytics/yolov3/issues/1972/labels{/name}","comments_url":"https://api.github.com/repos/ultralytics/yolov3/issues/1972/comments","events_url":"https://api.github.com/repos/ultralytics/yolov3/issues/1972/events","html_url":"https://github.com/ultralytics/yolov3/issues/1972","id":1380214049,"node_id":"I_kwDOCLZQgM5SRGUh","number":1972,"title":"Customize source code of validation ","user":{"login":"juhonkang","id":67153600,"node_id":"MDQ6VXNlcjY3MTUzNjAw","avatar_url":"https://avatars.githubusercontent.com/u/67153600?v=4","gravatar_id":"","url":"https://api.github.com/users/juhonkang","html_url":"https://github.com/juhonkang","followers_url":"https://api.github.com/users/juhonkang/followers","following_url":"https://api.github.com/users/juhonkang/following{/other_user}","gists_url":"https://api.github.com/users/juhonkang/gists{/gist_id}","starred_url":"https://api.github.com/users/juhonkang/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/juhonkang/subscriptions","organizations_url":"https://api.github.com/users/juhonkang/orgs","repos_url":"https://api.github.com/users/juhonkang/repos","events_url":"https://api.github.com/users/juhonkang/events{/privacy}","received_events_url":"https://api.github.com/users/juhonkang/received_events","type":"User","site_admin":false},"labels":[{"id":1035696376,"node_id":"MDU6TGFiZWwxMDM1Njk2Mzc2","url":"https://api.github.com/repos/ultralytics/yolov3/labels/question","name":"question","color":"d876e3","default":true,"description":"Further information is requested"},{"id":1890885613,"node_id":"MDU6TGFiZWwxODkwODg1NjEz","url":"https://api.github.com/repos/ultralytics/yolov3/labels/Stale","name":"Stale","color":"ededed","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2022-09-21T02:19:52Z","updated_at":"2022-10-28T00:17:21Z","closed_at":"2022-10-28T00:17:20Z","author_association":"NONE","active_lock_reason":null,"body":"### Search before asking\r\n\r\n- [X] I have searched the YOLOv3 [issues](https://github.com/ultralytics/yolov3/issues) and [discussions](https://github.com/ultralytics/yolov3/discussions) and found no similar questions.\r\n\r\n\r\n### Question\r\n\r\nI have used the code below to load the model and want to write a function to get the map and map50 from it. How can I do that?\r\n\r\n### Additional\r\n\r\n`%cd /content/yolov3\r\n\r\nimport torch\r\n\r\nfrom utils.general import check_requirements, intersect_dicts, set_logging\r\nweights='/content/drive/MyDrive/Ongoing_Project/YOLOv3_Imagenette/best_tiny_350.pt'\r\n\r\nmodel = torch.hub.load(\"ultralytics/yolov3\", \"yolov3_tiny\", pretrained=False, classes=20, force_reload=True)\r\nckpt = torch.load(weights)  # load\r\ncsd = ckpt['model'].float().state_dict()  # checkpoint state_dict as FP32\r\ncsd = intersect_dicts(csd, model.state_dict(), exclude=['anchors'])  # intersect\r\nmodel.load_state_dict(csd, strict=False)  # load\r\n\r\nfor i, m in enumerate(model.modules()):\r\n    print(i, m)\r\n`\r\n\r\ndef _validate(self, val_loader, model, verbose=False, training = False, compute_loss = True,\r\n                  augment=False,half=False, save_hybrid=False, conf_thres=0.001, iou_thres=0.6, \r\n                  single_cls=False, model_only=False, plots=False, nc=10):\r\n        '''\r\n        Validate the performance on validation set\r\n        :param val_loader:\r\n        :param model:\r\n        :param verbose:\r\n        :return:\r\n        '''\r\n        device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\r\n\r\n        iouv = torch.linspace(0.5, 0.95, 10).to(device)  # iou vector for mAP@0.5:0.95\r\n        niou = iouv.numel()\r\n        \r\n        device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\r\n        model.to(device)\r\n        loss = torch.zeros(3, device=device)\r\n        for batch_i, (im, targets, paths, shapes) in enumerate(val_loader):\r\n            \r\n            im = im.to(device, non_blocking=True)\r\n            targets = targets.to(device)\r\n            \r\n            im = im.half() if half else im.float()  # uint8 to fp16/32\r\n            im /= 255  # 0 - 255 to 0.0 - 1.0\r\n            nb, _, height, width = im.shape  # batch size, channels, height, width\r\n\r\n            # Inference\r\n            out, train_out = model(im) if training else model(im, augment=augment, val=True)  # inference, loss outputs\r\n            # out, train_out = model(im) \r\n\r\n            # print(out.shape)\r\n            # print(len(train_out))\r\n            # Loss\r\n            # if compute_loss:\r\n            #     loss += compute_loss([x.float() for x in train_out], targets)[1]  # box, obj, cls\r\n\r\n            # NMS\r\n            targets[:, 2:] *= torch.Tensor([width, height, width, height]).to(device)  # to pixels\r\n            lb = [targets[targets[:, 0] == i, 1:] for i in range(nb)] if save_hybrid else []  # for autolabelling\r\n            \r\n            out = non_max_suppression(out, conf_thres, iou_thres, labels=lb, multi_label=True, agnostic=single_cls)\r\n            \r\n            seen = 0\r\n            confusion_matrix = ConfusionMatrix(nc=10)\r\n            names = {k: v for k, v in enumerate(model.names if hasattr(model, 'names') else model.module.names)}\r\n            # class_map = coco80_to_coco91_class() if is_coco else list(range(1000))\r\n            s = ('%20s' + '%11s' * 6) % ('Class', 'Images', 'Labels', 'P', 'R', 'mAP@.5', 'mAP@.5:.95')\r\n            dt, p, r, f1, mp, mr, map50, map = [0.0, 0.0, 0.0], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0\r\n            loss = torch.zeros(3, device=device)\r\n            jdict, stats, ap, ap_class = [], [], [], []\r\n            # Metrics\r\n            for si, pred in enumerate(out):\r\n                labels = targets[targets[:, 0] == si, 1:]\r\n                nl = len(labels)\r\n                tcls = labels[:, 0].tolist() if nl else []  # target class\r\n                path, shape = Path(paths[si]), shapes[si][0]\r\n                seen += 1\r\n\r\n                if len(pred) == 0:\r\n                    if nl:\r\n                        stats.append((torch.zeros(0, niou, dtype=torch.bool), torch.Tensor(), torch.Tensor(), tcls))\r\n                    continue\r\n\r\n                # Predictions\r\n                if single_cls:\r\n                    pred[:, 5] = 0\r\n                predn = pred.clone()\r\n                scale_coords(im[si].shape[1:], predn[:, :4], shape, shapes[si][1])  # native-space pred\r\n\r\n                # Evaluate\r\n                if nl:\r\n                    tbox = xywh2xyxy(labels[:, 1:5])  # target boxes\r\n                    scale_coords(im[si].shape[1:], tbox, shape, shapes[si][1])  # native-space labels\r\n                    labelsn = torch.cat((labels[:, 0:1], tbox), 1)  # native-space labels\r\n                    correct = process_batch(predn, labelsn, iouv)\r\n                    if plots:\r\n                        confusion_matrix.process_batch(predn, labelsn)\r\n                else:\r\n                    correct = torch.zeros(pred.shape[0], niou, dtype=torch.bool)\r\n                stats.append((correct.cpu(), pred[:, 4].cpu(), pred[:, 5].cpu(), tcls))  # (correct, conf, pcls, tcls)\r\n\r\n\r\n        # Compute metrics\r\n        stats = [np.concatenate(x, 0) for x in zip(*stats)]  # to numpy\r\n        if len(stats) and stats[0].any():\r\n            p, r, ap, f1, ap_class = ap_per_class(*stats, names=names)\r\n            ap50, ap = ap[:, 0], ap.mean(1)  # AP@0.5, AP@0.5:0.95\r\n            \r\n            mp, mr, map50, map = p.mean(), r.mean(), ap50.mean(), ap.mean()\r\n            nt = np.bincount(stats[3].astype(np.int64), minlength=nc)  # number of targets per class\r\n        else:\r\n            nt = torch.zeros(1)\r\n\r\n        # Print results\r\n        pf = '%20s' + '%11i' * 2 + '%11.3g' * 4  # print format\r\n        LOGGER.info(pf % ('all', seen, nt.sum(), mp, mr, map50, map))\r\n\r\n\r\n        # Return results\r\n        model.float()  # for training\r\n        \r\n        maps = np.zeros(nc) + map\r\n        for i, c in enumerate(ap_class):\r\n            maps[c] = ap[i]\r\n        # map50, map,\r\n        \r\n        \r\n        if self.acc_metric == 'acc1':\r\n            return map\r\n        elif self.acc_metric == 'acc5':\r\n            return map50\r\n        else:\r\n            raise NotImplementedError\r\n\r\n`\r\n","closed_by":{"login":"github-actions[bot]","id":41898282,"node_id":"MDM6Qm90NDE4OTgyODI=","avatar_url":"https://avatars.githubusercontent.com/in/15368?v=4","gravatar_id":"","url":"https://api.github.com/users/github-actions%5Bbot%5D","html_url":"https://github.com/apps/github-actions","followers_url":"https://api.github.com/users/github-actions%5Bbot%5D/followers","following_url":"https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/github-actions%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/github-actions%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/github-actions%5Bbot%5D/repos","events_url":"https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/github-actions%5Bbot%5D/received_events","type":"Bot","site_admin":false},"reactions":{"url":"https://api.github.com/repos/ultralytics/yolov3/issues/1972/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/ultralytics/yolov3/issues/1972/timeline","performed_via_github_app":null,"state_reason":"not_planned"}