{"url":"https://api.github.com/repos/ultralytics/yolov3/issues/1657","repository_url":"https://api.github.com/repos/ultralytics/yolov3","labels_url":"https://api.github.com/repos/ultralytics/yolov3/issues/1657/labels{/name}","comments_url":"https://api.github.com/repos/ultralytics/yolov3/issues/1657/comments","events_url":"https://api.github.com/repos/ultralytics/yolov3/issues/1657/events","html_url":"https://github.com/ultralytics/yolov3/issues/1657","id":784670570,"node_id":"MDU6SXNzdWU3ODQ2NzA1NzA=","number":1657,"title":"Yolo Objective Loss Convergence for custom model","user":{"login":"vsuriya93","id":7788805,"node_id":"MDQ6VXNlcjc3ODg4MDU=","avatar_url":"https://avatars.githubusercontent.com/u/7788805?v=4","gravatar_id":"","url":"https://api.github.com/users/vsuriya93","html_url":"https://github.com/vsuriya93","followers_url":"https://api.github.com/users/vsuriya93/followers","following_url":"https://api.github.com/users/vsuriya93/following{/other_user}","gists_url":"https://api.github.com/users/vsuriya93/gists{/gist_id}","starred_url":"https://api.github.com/users/vsuriya93/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vsuriya93/subscriptions","organizations_url":"https://api.github.com/users/vsuriya93/orgs","repos_url":"https://api.github.com/users/vsuriya93/repos","events_url":"https://api.github.com/users/vsuriya93/events{/privacy}","received_events_url":"https://api.github.com/users/vsuriya93/received_events","type":"User","site_admin":false},"labels":[{"id":1035696376,"node_id":"MDU6TGFiZWwxMDM1Njk2Mzc2","url":"https://api.github.com/repos/ultralytics/yolov3/labels/question","name":"question","color":"d876e3","default":true,"description":"Further information is requested"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2021-01-12T23:33:05Z","updated_at":"2021-01-13T05:29:48Z","closed_at":"2021-01-13T05:29:48Z","author_association":"NONE","active_lock_reason":null,"body":"## ‚ùîQuestion\r\nHi -  Thank you for the awesome repo. I am currently working on a smaller version of the tiny-YOLO model. I am first trying to overfit on coco128 data to validate the implementation. Currently running into the following issues\r\n\r\n- Confidence of all predictions is ~0.5. On debugging, I find the objective loss does not decrease after a certain point and the BCE value is .69 which is same as all predictions have prior-sigmoid value to be 0. I have also tuned pos_weight parameter [1,2,5] and this seems to have no effect even after running for 200, 400 and 1000 epochs\r\n- Regarding bbox loss, I don't see MSELoss being used in the repo. Can you please help point to the relevant link? It does only GIoU Loss.\r\n\r\n```\r\nclass ConvBatchNormAct(nn.Module):\r\n    def __init__(self,in_dim=3,filters=32,stride=2,padding=1,bias=False,kernel=(3,3)):\r\n        super(ConvBatchNormAct,self).__init__()\r\n        self.conv = nn.Conv2d(in_dim,filters,kernel,stride=stride,padding=padding,bias=bias)\r\n        self.bn = nn.BatchNorm2d(filters,momentum=0.03, eps=1E-4)\r\n        self.act = nn.LeakyReLU()\r\n    \r\n    def forward(self,x):\r\n        x = self.conv(x)\r\n        x = self.bn(x)\r\n        x = self.act(x)\r\n        return x\r\n\r\nclass FeatureConcat(nn.Module):\r\n    def __init__(self,index):\r\n        super(FeatureConcat,self).__init__()\r\n        self.index = index\r\n    \r\n    def forward(self,x,outputs):\r\n        return outputs[self.index]\r\n\r\nfrom custom_layers import YOLOLayer # from yolo_repo\r\n\r\nclass Net(nn.Module):\r\n    def __init__(self):\r\n        super(Net,self).__init__()\r\n        self.layers = nn.ModuleList()\r\n        self.layers.append(ConvBatchNormAct(3,32,2,1,False,(3,3)))\r\n        self.layers.append(ConvBatchNormAct(32,64,2,1,False,(3,3)))\r\n        self.layers.append(ConvBatchNormAct(64,128,2,1,False,(3,3)))\r\n        self.layers.append(ConvBatchNormAct(128,256,2,1,False,(3,3)))\r\n        self.layers.append(ConvBatchNormAct(256,255,2,1,False,(3,3)))\r\n        anchor_vec_1 = [ [116,90], [156,198],  [373,326]]\r\n        strides = 32\r\n        yolo_1 = YOLOLayer(anchors=anchor_vec_1,  # anchor list\r\n                                nc=80,  # number of classes\r\n                                img_size= (512,512),  # (416, 416)\r\n                                yolo_index=0,  # 0, 1, 2...\r\n                                layers=[],  # output layers\r\n                                stride=strides)\r\n        self.layers.append(yolo_1)\r\n        self.layers.append(FeatureConcat(index=-3))\r\n        self.layers.append(nn.Upsample(scale_factor=2))\r\n        self.layers.append(ConvBatchNormAct(256,255,2,1,False,(3,3)))\r\n        anchor_vec_2 = [[30,61], [62,45], [59,119]]\r\n        strides = 16\r\n        yolo_2 = YOLOLayer(anchors=anchor_vec_2,  # anchor list\r\n                                nc=80,  # number of classes\r\n                                img_size= (512,512),  # (416, 416)\r\n                                yolo_index=1,  # 0, 1, 2...\r\n                                layers=[],  # output layers\r\n                                stride=strides)\r\n        self.layers.append(yolo_2)\r\n        self.layers.append(FeatureConcat(index=-3))\r\n        self.layers.append(nn.Upsample(scale_factor=2))\r\n        self.layers.append(ConvBatchNormAct(256,255,2,1,False,(3,3)))\r\n        anchor_vec_3 = [[10,13], [16,30],  [33,23]]\r\n        strides = 8\r\n        yolo_3 = YOLOLayer(anchors=anchor_vec_3,  # anchor list\r\n                                nc=80,  # number of classes\r\n                                img_size= (512,512),  # (416, 416)\r\n                                yolo_index=2,  # 0, 1, 2...\r\n                                layers=[],  # output layers\r\n                                stride=8)\r\n        self.layers.append(yolo_3)\r\n        \r\n        self.yolo_layers  = None\r\n        self.module_list = list(self.layers)\r\n        \r\n        \r\n        \r\n    def forward(self, x):\r\n        out_cache = []\r\n        yolo_out = []\r\n        for l in self.layers:\r\n            name = l.__class__.__name__\r\n            if name=='FeatureConcat':\r\n                x = l(x,out_cache)\r\n            elif name=='YOLOLayer':\r\n                x = l(x,None) # ASFF = False\r\n                yolo_out.append(x)\r\n            else:\r\n                x = l(x)\r\n            out_cache.append(x)\r\n            \r\n        if self.training:\r\n            return yolo_out\r\n\r\n        return x\r\n    \r\ndef get_yolo_layers(model):\r\n        return [i for i, m in enumerate(model.module_list) if m.__class__.__name__ == 'YOLOLayer']\r\n        \r\nnet = Net()\r\nnet.module_list = list(net.module_list)\r\nnet.yolo_layers = get_yolo_layers(net)\r\nsummary(net,input_size=(3,512,512),device='cpu',batch_size=10)\r\n```\r\n\r\nAnd this is my model training code\r\n\r\n```\r\ndef train(model):\r\n    path = 'data/coco128/images/train2017/'\r\n    train_loader = LoadImages(path,img_size=512)\r\n    model.train()\r\n    dataloader = torch.utils.data.DataLoader(train_loader,\r\n                                             batch_size=16,\r\n                                             shuffle= False,\r\n                                             collate_fn=train_loader.collate_fn)\r\n    \r\n    pg0, pg1, pg2 = [], [], []  # optimizer parameter groups\r\n    for k, v in dict(model.named_parameters()).items():\r\n        if '.bias' in k:\r\n            pg2 += [v]  # biases\r\n        elif 'Conv2d.weight' in k:\r\n            pg1 += [v]  # apply weight_decay\r\n        else:\r\n            pg0 += [v]  # all else\r\n\r\n    optimizer = optim.Adam(pg0, lr=0.01)\r\n    #model.load_state_dict(torch.load('./checkpoint/mini.pt'))\r\n    scheduler = torch.optim.lr_scheduler.CyclicLR(optimizer,base_lr=0.001, max_lr=0.1,cycle_momentum=False)\r\n    \r\n    best = 100\r\n    \r\n    for epoch in range(500):\r\n        avg = 0\r\n        c = 0\r\n        for i, (imgs,targets) in enumerate(dataloader):\r\n                imgs = imgs.float() / 255.0 \r\n                imgs = imgs.to(device)\r\n                targets = targets.to(device)\r\n                pred = model(imgs)\r\n                loss, loss_items = compute_loss(pred, targets, model)\r\n                #return pred, targets, model \r\n                loss = loss * (16/64.)\r\n                loss.backward()\r\n                optimizer.step()\r\n                optimizer.zero_grad()\r\n                c+=1.0\r\n                avg+=loss\r\n                scheduler.step()\r\n        if avg/c < best:\r\n            best = avg\r\n            torch.save(model.state_dict(), './checkpoint/mini.pt')\r\n            print (\"Saved\")\r\n        print (epoch,avg/c,loss_items)\r\n\r\ntrain(net)\r\n```\r\n\r\n\r\nI am using the implementations of yolov3 repo for computing loss. Have made changes only to the dataset (to coco128) and to model training using cyclicLR with Adam for training.\r\n","closed_by":{"login":"vsuriya93","id":7788805,"node_id":"MDQ6VXNlcjc3ODg4MDU=","avatar_url":"https://avatars.githubusercontent.com/u/7788805?v=4","gravatar_id":"","url":"https://api.github.com/users/vsuriya93","html_url":"https://github.com/vsuriya93","followers_url":"https://api.github.com/users/vsuriya93/followers","following_url":"https://api.github.com/users/vsuriya93/following{/other_user}","gists_url":"https://api.github.com/users/vsuriya93/gists{/gist_id}","starred_url":"https://api.github.com/users/vsuriya93/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vsuriya93/subscriptions","organizations_url":"https://api.github.com/users/vsuriya93/orgs","repos_url":"https://api.github.com/users/vsuriya93/repos","events_url":"https://api.github.com/users/vsuriya93/events{/privacy}","received_events_url":"https://api.github.com/users/vsuriya93/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/ultralytics/yolov3/issues/1657/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/ultralytics/yolov3/issues/1657/timeline","performed_via_github_app":null,"state_reason":"completed"}