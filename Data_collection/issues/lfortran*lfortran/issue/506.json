{"url":"https://api.github.com/repos/lfortran/lfortran/issues/506","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/506/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/506/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/506/events","html_url":"https://github.com/lfortran/lfortran/issues/506","id":1338780949,"node_id":"I_kwDOCpMuHc5PzC0V","number":506,"title":"Simplify passing arguments to Subroutine/FunctionCall","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T09:58:02Z","updated_at":"2022-08-15T09:58:02Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/657\n\nHere is how:\n```diff\ndiff --git a/grammar/ASR.asdl b/grammar/ASR.asdl\nindex 9d9135960..f34d3a46e 100644\n--- a/grammar/ASR.asdl\n+++ b/grammar/ASR.asdl\n@@ -184,7 +184,7 @@ stmt\n     | Select(expr test, case_stmt* body, stmt* default)\n     | Stop(expr? code)\n     | Assert(expr test, expr? msg)\n-    | SubroutineCall(symbol name, symbol? original_name, expr* args, expr? dt)\n+    | SubroutineCall(symbol name, symbol? original_name, call_arg* args, expr? dt)\n     | Where(expr test, stmt* body, stmt* orelse)\n     | WhileLoop(expr test, stmt* body)\n     | Nullify(symbol* vars)\n@@ -200,8 +200,8 @@ expr\n     | NamedExpr(expr target, expr value, ttype type)\n     | Compare(expr left, cmpop op, expr right, ttype type, expr? value, expr? overloaded)\n     | IfExp(expr test, expr body, expr orelse, ttype type)\n-    | FunctionCall(symbol name, symbol? original_name, expr* args,\n-            keyword* keywords, ttype type, expr? value, expr? dt)\n+    | FunctionCall(symbol name, symbol? original_name,\n+            call_arg* args, ttype type, expr? value, expr? dt)\n     | DerivedTypeConstructor(symbol dt_sym, expr* args, ttype type)\n     | ConstantArray(expr* args, ttype type)\n     | ImpliedDoLoop(expr* values, expr var, expr start, expr end,\n@@ -271,7 +271,7 @@ attribute_arg = (identifier arg)\n \n arg = (identifier arg)\n \n-keyword = (identifier? arg, expr value)\n+call_arg = (expr? value)\n \n tbind = Bind(string lang, string name)\n \n```\nAll arguments (including optional) will be always specified at the call site. If the optional argument is not present, then the `call_arg::value` will be \"nullptr\", otherwise it will be the value of the argument.\n\nKeyword arguments are resolved, and just the value is passed. The position of the argument is significant, and corresponds to the position of the argument in the declaration. The length of `args` is always equal to the length of the arguments in the definition.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/506/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/506/timeline","performed_via_github_app":null,"state_reason":null}