{"url":"https://api.github.com/repos/lfortran/lfortran/issues/1059","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/1059/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/1059/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/1059/events","html_url":"https://github.com/lfortran/lfortran/issues/1059","id":1473896092,"node_id":"I_kwDOCpMuHc5X2d6c","number":1059,"title":"Redesign how to handle global/parent scope variables","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-12-03T10:27:22Z","updated_at":"2022-12-08T09:24:22Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"## Current State\r\n\r\nCurrently we have an ASR pass that determines which variables are being accessed from the parent scope, and hands over this information to the LLVM backend in forms of internal compiler data structures (not via ASR). The LLVM backend then uses this information to create global structs with the correct context to handle the access to parent scope variables.\r\n\r\nThis has two issues:\r\n\r\n1. handing over information separately from ASR is not a clean design; all the information should be passed as ASR; The justification in this case is that the ASR pass is only used by the backend, to help it figure out some information. But that means the ASR is badly designed: it should be designed in such a way so that the backend only needs a single pass to generate correct code.\r\n\r\n2. It makes the backend more complex.\r\n\r\n## Better Design\r\n\r\nFirst, we will add a new member to Function called \"capture\", which will store all parent scope variables that the function accesses, to make this explicit.\r\n\r\nThen we will create two ASR passes, which implement this feature in two different ways, each has pros and cons, and the backend or user can choose.\r\n\r\n### ASR pass global context\r\n\r\nThis ASR pass would do the equivalent of what we currently do in the backend, but it would do it at the ASR level explicitly. So it would promote all captured variables into global structs at ASR level. The backends would then not need to do anything special; the only feature they would need is to access a global function, but nothing else (no worry about nested scopes).\r\n\r\nThis pass doesn't require access to all the source code.\r\n\r\nAn example from minpack:\r\n\r\n```diff\r\n--- a/examples/example_primes.f90\r\n+++ b/examples/example_primes.f90\r\n@@ -5,6 +5,8 @@ public dp\r\n \r\n integer, parameter :: dp=kind(0d0)\r\n \r\n+! here we will create a \"global\" module variable to handle the \"expr\" handover\r\n+\r\n end module\r\n \r\n module find_fit_module\r\n@@ -47,8 +49,7 @@ n = size(pars)\r\n allocate(wa(m*n + 5*n + m))\r\n call lmdif1(fcn, m, n, pars, fvec, tol, info, iwa, wa, size(wa))\r\n if (info /= 1) stop \"failed to converge\"\r\n-\r\n-contains\r\n+end subroutine\r\n \r\n subroutine fcn(m, n, x, fvec, iflag)\r\n integer, intent(in) :: m, n, iflag\r\n@@ -59,8 +60,6 @@ fvec(1) = iflag\r\n fvec = data_y - expr(data_x, x)\r\n end subroutine\r\n \r\n-end subroutine\r\n-\r\n end module\r\n```\r\n\r\n### ASR pass promote captured arguments into regular arguments\r\n\r\nThis is pass would promote all captured arguments into actual arguments; this pass requires access to all the code stack that contains the given callback, and it would extend all declaration and callsite with those arguments. If there are multiple callbacks with different arguments, then this ASR pass must decide whether to duplicate code, or do a superset of all arguments. The big advantage of this pass is that it doesn't access any global variables or state, every function becomes \"pure\", so potentially faster and thread safe. The downside is that you must have access to all the code, and it might be potentially harder to implement. We should implement this pass, but we will choose between this pass and the previous pass, the user can select using a command line option, or something like that.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/1059/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/1059/timeline","performed_via_github_app":null,"state_reason":null}