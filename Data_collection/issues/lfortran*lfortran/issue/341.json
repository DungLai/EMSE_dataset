{"url":"https://api.github.com/repos/lfortran/lfortran/issues/341","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/341/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/341/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/341/events","html_url":"https://github.com/lfortran/lfortran/issues/341","id":1338727189,"node_id":"I_kwDOCpMuHc5Py1sV","number":341,"title":"Safe mode","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T09:05:23Z","updated_at":"2022-08-15T09:05:23Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/369\n\nWe should have a \"safe mode\" (perhaps on by default in Debug mode) where a Fortran code cannot segfault at runtime no matter how it is written. To do so, we have to implement the following runtime checks:\n\n* Array bounds checking (https://gitlab.com/lfortran/lfortran/-/issues/367)\n* Accessing unallocated variable (https://gitlab.com/lfortran/lfortran/-/issues/370)\n* Dangling pointers checks (https://gitlab.com/lfortran/lfortran/-/issues/366)\n* Infinite recursion checks (https://gitlab.com/lfortran/lfortran/-/issues/368)\n* Numerical errors / exceptions checks (https://gitlab.com/lfortran/lfortran/-/issues/371)\n* Out of memory (https://gitlab.com/lfortran/lfortran/-/issues/372)\n*    Accessing an OPTIONAL argument that is not PRESENT\n*    Opening a file for reading that does not exist\n*    Reading a variable from a line of a file that has data of the wrong type\n*    Reading N elements of an array from a character string that contains fewer than N values\n*    An invalid format string (for example with missing parenthesis) or a format string that does not match the data read or written. When the data consists of scalars, maybe the compatibility of the data and format string can be checked at compile time.\n*    Allocating an array that is already allocated, or deallocating an array that is not allocated\n\nIf there is any other way a Fortran code could segfault, we should add it to the above list and check it at runtime.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/341/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/341/timeline","performed_via_github_app":null,"state_reason":null}