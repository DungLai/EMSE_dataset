{"url":"https://api.github.com/repos/lfortran/lfortran/issues/413","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/413/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/413/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/413/events","html_url":"https://github.com/lfortran/lfortran/issues/413","id":1338735618,"node_id":"I_kwDOCpMuHc5Py3wC","number":413,"title":"LLVM backend call convention refactoring","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T09:12:20Z","updated_at":"2022-08-15T09:12:20Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/546\n\nCurrently one has complex logic to determine the calling convention for arguments at two places, the function definition:\n```c++\n                    if (x.m_abi == ASR::abiType::BindC) {\n                        if (platform == Platform::Windows) {\n                            // pass as subroutine\n                            return_type = getComplexType(a_kind, true);\n                            std::vector<llvm::Type*> args = convert_args(x);\n                            args.insert(args.begin(), return_type);\n                            llvm::FunctionType *function_type = llvm::FunctionType::get(\n                                    llvm::Type::getVoidTy(context), args, false);\n                            return function_type;\n                        } else {\n                            return_type = getComplexType(a_kind);\n                        }\n                    } else {\n                        return_type = getComplexType(a_kind);\n                    }\n```\nand function calls:\n```\n            if (s->m_abi == ASR::abiType::BindC) {\n                ASR::ttype_t *return_var_type0 = EXPR2VAR(s->m_return_var)->m_type;\n                if (is_a<ASR::Complex_t>(*return_var_type0)) {\n                    int a_kind = down_cast<ASR::Complex_t>(return_var_type0)->m_kind;\n                    if (a_kind == 8) {\n                        if (platform == Platform::Windows) {\n                            tmp = builder->CreateAlloca(complex_type_8, nullptr);\n                            args.insert(args.begin(), tmp);\n                            builder->CreateCall(fn, args);\n                        } else {\n                            tmp = builder->CreateCall(fn, args);\n                        }\n                    } else {\n                        tmp = builder->CreateCall(fn, args);\n                    }\n                } else {\n                    tmp = builder->CreateCall(fn, args);\n                }\n            } else {\n                tmp = builder->CreateCall(fn, args);\n            }\n```\n\nRather, we should have an internal mapping (function argument -> calling convention). When function is created, we do the complex logic once, and figure out what the calling convention will be. We store it, and then at both function declaration and function call, we simply have a switch based on the calling convention and implement the convention. The calling conventions currently implemented:\n\n* linux_single_complex_arg (`<2 x float>`)\n* linux_single_complex_return_arg (`<2 x float>`)\n* windows_single_complex_arg (`i64`)\n* windows_single_complex_return_arg (`i64`)\n* linux_double_complex_arg (`{double,double}`)\n* linux_double_complex_return_arg (`{double,double}`)\n* windows_double_complex_arg (`{double,double}*`)\n* windows_double_complex_return_arg (`{double,double}*` passed as first argument in a subroutine instead of a function)\n* reference (such as `i64*, i32*, float*, double*, {double,double}* ...`)\n* value (such as `i64, i32, float, double, {double, double} ...`)","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/413/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/413/timeline","performed_via_github_app":null,"state_reason":null}