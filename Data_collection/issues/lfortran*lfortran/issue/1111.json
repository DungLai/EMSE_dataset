{"url":"https://api.github.com/repos/lfortran/lfortran/issues/1111","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/1111/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/1111/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/1111/events","html_url":"https://github.com/lfortran/lfortran/issues/1111","id":1498526950,"node_id":"I_kwDOCpMuHc5ZUbTm","number":1111,"title":"Implement ``present``","user":{"login":"czgdp1807","id":36567889,"node_id":"MDQ6VXNlcjM2NTY3ODg5","avatar_url":"https://avatars.githubusercontent.com/u/36567889?v=4","gravatar_id":"","url":"https://api.github.com/users/czgdp1807","html_url":"https://github.com/czgdp1807","followers_url":"https://api.github.com/users/czgdp1807/followers","following_url":"https://api.github.com/users/czgdp1807/following{/other_user}","gists_url":"https://api.github.com/users/czgdp1807/gists{/gist_id}","starred_url":"https://api.github.com/users/czgdp1807/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/czgdp1807/subscriptions","organizations_url":"https://api.github.com/users/czgdp1807/orgs","repos_url":"https://api.github.com/users/czgdp1807/repos","events_url":"https://api.github.com/users/czgdp1807/events{/privacy}","received_events_url":"https://api.github.com/users/czgdp1807/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":{"login":"czgdp1807","id":36567889,"node_id":"MDQ6VXNlcjM2NTY3ODg5","avatar_url":"https://avatars.githubusercontent.com/u/36567889?v=4","gravatar_id":"","url":"https://api.github.com/users/czgdp1807","html_url":"https://github.com/czgdp1807","followers_url":"https://api.github.com/users/czgdp1807/followers","following_url":"https://api.github.com/users/czgdp1807/following{/other_user}","gists_url":"https://api.github.com/users/czgdp1807/gists{/gist_id}","starred_url":"https://api.github.com/users/czgdp1807/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/czgdp1807/subscriptions","organizations_url":"https://api.github.com/users/czgdp1807/orgs","repos_url":"https://api.github.com/users/czgdp1807/repos","events_url":"https://api.github.com/users/czgdp1807/events{/privacy}","received_events_url":"https://api.github.com/users/czgdp1807/received_events","type":"User","site_admin":false},"assignees":[{"login":"czgdp1807","id":36567889,"node_id":"MDQ6VXNlcjM2NTY3ODg5","avatar_url":"https://avatars.githubusercontent.com/u/36567889?v=4","gravatar_id":"","url":"https://api.github.com/users/czgdp1807","html_url":"https://github.com/czgdp1807","followers_url":"https://api.github.com/users/czgdp1807/followers","following_url":"https://api.github.com/users/czgdp1807/following{/other_user}","gists_url":"https://api.github.com/users/czgdp1807/gists{/gist_id}","starred_url":"https://api.github.com/users/czgdp1807/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/czgdp1807/subscriptions","organizations_url":"https://api.github.com/users/czgdp1807/orgs","repos_url":"https://api.github.com/users/czgdp1807/repos","events_url":"https://api.github.com/users/czgdp1807/events{/privacy}","received_events_url":"https://api.github.com/users/czgdp1807/received_events","type":"User","site_admin":false}],"milestone":null,"comments":2,"created_at":"2022-12-15T14:20:34Z","updated_at":"2022-12-16T05:09:43Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"As far as I know ``present`` is a feature for functions in Fortran source code (i.e., `Source` ABI) and is applicable to optional arguments. So I list the following approaches for implementing it in LFortran,\r\n\r\n1. **Pass bits for each optional argument** - Consider the function is `f(a, b, c)` where `b` and `c` are specified as optional arguments. So we will write an ASR pass which will convert `f(a, b, c)` to `f(a, b, is_b_present, c, is_c_present)` where `is_b_present` and `is_c_present` are simply the bits which will be `true` if the associated argument is present and `false` if not. And inside the function body calls like `present(b)` will be replaced by `is_b_present`. The calls to function `f` will also be modified accordingly. Like `f(a, b)` will become, `f(a, b, true, c, false)`. Everything will be done at ASR level, no modifications in any of the backends. This is the same pattern as `pass_array_by_data` so we have the infrastructure for this already.\r\n2. **Pass arguments by pointer and set non-present to nullptr** - In this approach we don't touch the ASR, just in LLVM backend, convert calls like `f(a, b)` to `f(a, b, nullptr)` and whenever we encounter `present(c)`, replace it with `c == nullptr`. This approach depends on the fact we pass argument by pointers.\r\n\r\nIn my opinion first approach is robust and adds the feature to all the backends simultaneously (so I favour it). The second approach is limited to LLVM backend and also very risky (because of the nullptr checks and involvement of nullptr brings the risk of frequent segmentation faults as well).","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/1111/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/1111/timeline","performed_via_github_app":null,"state_reason":null}