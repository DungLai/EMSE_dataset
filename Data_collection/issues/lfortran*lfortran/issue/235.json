{"url":"https://api.github.com/repos/lfortran/lfortran/issues/235","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/235/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/235/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/235/events","html_url":"https://github.com/lfortran/lfortran/issues/235","id":1338687370,"node_id":"I_kwDOCpMuHc5Pyr-K","number":235,"title":"Track numerical accuracy of floating point numbers","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T08:21:50Z","updated_at":"2022-08-15T08:21:50Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/137\n\nProvide optional error propagation for double precision and print lost digits in red or gray. One way to do that robustly is to keep a quadruple precision number along each double precision, and do all operations on both and when printing compare the two.\n\nCurrently my experience with GFortran in quadruple precision is that it slows down the code about 10x. But I think it calls into an external [quadmath](https://gcc.gnu.org/onlinedocs/libquadmath/) library. I can imagine having an internal quadruple precision implementation using two double precision numbers and the compiler would inject this code and there might be a way to optimize this better, perhaps even vectorize somehow. If things could be sped up to be only 2-4x slower, then I think this would be a very viable and useful feature.\n\n\nThe same for single precision numbers (LFortran would do the same calculation in double precision and compare the two).","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/235/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/235/timeline","performed_via_github_app":null,"state_reason":null}