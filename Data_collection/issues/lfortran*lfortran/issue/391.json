{"url":"https://api.github.com/repos/lfortran/lfortran/issues/391","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/391/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/391/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/391/events","html_url":"https://github.com/lfortran/lfortran/issues/391","id":1338733435,"node_id":"I_kwDOCpMuHc5Py3N7","number":391,"title":"Compiling example program from Fortran Discourse","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T09:10:17Z","updated_at":"2022-08-15T09:10:17Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/512\n\nHere is a nice simple code: https://fortran-lang.discourse.group/t/how-can-i-solve-this-equation-which-has-condition/1669/2\nCopying here for reference:\n```fortran\n! bisect.f90 --\n!     Improving sample program\n!\nprogram bisec\n    implicit none\n    integer, parameter :: n=1000\n    double precision   :: x1,x2,eps\n    double precision   :: roots(n)\n\n    double precision   :: a, b  !<== these were not defined\n\n    integer i, nroots\n\n    a = 1.0       !<== values will be available in the function f,\n    b = 2.0       !<== because f is an internal function now.\n\n    x1=0.0\n    x2=10.0 ! I change this number.\n    eps=1.0e-7\n    call bisection(f,x1,x2,eps,n,roots,nroots)\n    if (nroots==0) then\n        write(*,*) 'no root found'  !<== plain quotes, not \"smart\" quotes\n        stop\n    end if\n    write(*,*) 'roots of equation are'\n    do i=1,nroots,1\n        write (*,*) i, roots(i)\n    end do\n\ncontains\n\n! Using a so-called internal routine/function, then the variables a and b\n! are taken from the encompassing program. Avoids having to pass them\n! explicitly via the routine \"bisect\".\n\nfunction f( x )    !<== argument should be added\n    implicit none\n    double precision f,x\n\n    if (x>4.0) then\n        f = a/x\n    else\n        f=(a/b)*(3-x**2.0)\n    endif\nend function\n\nend program bisec\n\nsubroutine bisection(f,x1,x2,eps,n,roots,nroots)\n    implicit none\n    double precision f,x1,x2,eps,roots(n)\n    double precision a,b,c,dx,root\n    integer n,i,j,nroots\n    integer, parameter::sk =200\n\n    dx = (x2-x1)/n\n    nroots=0\n    do j =1,n\n        a=x1+(j-1)*dx\n        b=a+dx\n        if (f(a)*f(b) > 0) cycle\n        do i = 1, sk\n            c=(b+a)/2.0\n            if (f(c)*f(a) <= 0) then\n                b=c\n            else\n                a=c\n            end if\n            if (abs(a-b) <= eps) exit\n        end do\n        root=(a+b)/2.0\n        if (abs(f(root)) < 1.0) then\n            nroots=nroots+1\n            Roots(nroots)= root\n        end if\n    end do\nend subroutine bisection\n```\nIt can almost be compiled with LFortran. Here are the things to fix:\n* [x] `double precision` not implemented (https://gitlab.com/lfortran/lfortran/-/merge_requests/1192)\n* [ ] `Roots` variable lookup to `roots` should be case insenstitive (https://gitlab.com/lfortran/lfortran/-/merge_requests/1193)\n* [ ] `roots(n)` the declaration can't find `n`\n* [ ] ASR then shows (not sure if correct), but LLVM fails with:\n```\nAssertion failed: (Ty && \"Invalid GetElementPtrInst indices for type!\"), function checkGEPType, file /Users/certik/miniforge3/envs/lf/include/llvm/IR/Instructions.h, line 897.\nTraceback (most recent call last):\n  Binary file \"/usr/lib/system/libsystem_platform.dylib\", local address: 0x7fff20355d7c\nAbort: Signal SIGABRT (abort) received\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/391/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/391/timeline","performed_via_github_app":null,"state_reason":null}