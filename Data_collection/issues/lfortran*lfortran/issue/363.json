{"url":"https://api.github.com/repos/lfortran/lfortran/issues/363","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/363/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/363/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/363/events","html_url":"https://github.com/lfortran/lfortran/issues/363","id":1338730585,"node_id":"I_kwDOCpMuHc5Py2hZ","number":363,"title":"Create pedantic/strict mode","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2022-08-15T09:07:32Z","updated_at":"2022-09-20T22:35:23Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/450\n\nIn this mode, LFortran would provide warnings (or even errors) for code that is valid, but we determined as a community that we would not like using it.\n\nExamples:\n\n* more restrictive intents: it can force `intent(inout)` to `intent(in)` or `intent(out)` where appropriate; and require `intent` to be present for all arguments\n* apply `pure` and `simple` where appropriate\n* implicit typing, implied save and other such features would not be allowed\n* \"1.3\" and \"1.3d0\" would not be allowed, you have to specify the kind such as \"1.3_dp\" or \"1.3_sp\"\n* `endif`, `enddo` etc. would not be allowed, you have to use `end if`, `end do`, ...\n* `real(8)` and `real*8` would not be allowed, you have to use `real(dp)` and such\n* standardize how to define return type of a function (see [here](https://fortran-lang.discourse.group/t/closing-if-loops-by-endif-vs-end-if/1651/7))\n* not allow routines without explicit interfaces (i.e., all routines must be in modules or have an interface specified).\n* When a variable is used that is not initialized, it will give a compiler error (obviously we have to ensure no false positives)\n* ...\n\nWe can add any number of rules. The idea is that we determine as a community what kind of modern Fortran we would like to be writing and then use the compiler to enforce the rules. It can also be configurable.\n\nThis mode will be possible to enable / disable with a compiler option. First this mode would be off by default, but as people use it and if they like it, we can discuss if it should be on by default (you'll always be able to turn it off with an option).","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/363/reactions","total_count":2,"+1":2,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/363/timeline","performed_via_github_app":null,"state_reason":null}