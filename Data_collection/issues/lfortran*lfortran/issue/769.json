{"url":"https://api.github.com/repos/lfortran/lfortran/issues/769","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/769/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/769/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/769/events","html_url":"https://github.com/lfortran/lfortran/issues/769","id":1387989647,"node_id":"I_kwDOCpMuHc5SuwqP","number":769,"title":"Implement Assign","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[{"id":4432142216,"node_id":"LA_kwDOCpMuHc8AAAABCC0fiA","url":"https://api.github.com/repos/lfortran/lfortran/labels/SciPy","name":"SciPy","color":"d4c5f9","default":false,"description":"issues related to enable LFortran to compile the entire FORTRAN codebase in SciPy"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2022-09-27T15:51:40Z","updated_at":"2022-10-07T16:20:14Z","closed_at":"2022-10-07T16:20:14Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"To implement Assign and the associated \"goto\" statement, I would use the same approach as in https://github.com/lfortran/lfortran/pull/682, that is, I would take this code:\r\n\r\n```c++\r\n            } else if (AST::is_a<AST::Name_t>(*x.m_goto_label)) {\r\n                auto name = AST::down_cast<AST::Name_t>(x.m_goto_label);\r\n                auto sym_name = std::string(name->m_id);\r\n                auto sym = current_scope->resolve_symbol(sym_name);\r\n                if (sym == nullptr) {\r\n                    throw SemanticError(\"Cannot do `GOTO select` for undeclared variable\",\r\n                        x.base.base.loc);\r\n                }\r\n                if (!ASR::is_a<ASR::Variable_t>(*sym)) {\r\n                    throw SemanticError(\"Symbol needs to be a variable\",\r\n                        x.base.base.loc);\r\n                }\r\n                // n_labels GOTO\r\n                Vec<ASR::case_stmt_t*> a_body_vec;\r\n                a_body_vec.reserve(al, x.n_labels);\r\n\r\n                // 1 label SELECT\r\n                Vec<ASR::stmt_t*> def_body;\r\n                def_body.reserve(al, 1);\r\n\r\n                for (size_t i = 0; i < x.n_labels; ++i) {\r\n                    if (!AST::is_a<AST::Num_t>(*x.m_labels[i])) {\r\n                        throw SemanticError(\"Can only `GOTO` integer labels\",\r\n                            x.base.base.loc);\r\n                    } else {\r\n                        auto l = AST::down_cast<AST::Num_t>(x.m_labels[i]); // l->m_n gets the target -> if l->m_n == (i+1) ...\r\n                        Vec<ASR::stmt_t*> body;\r\n                        body.reserve(al, 1);\r\n                        body.push_back(al, ASRUtils::STMT(ASR::make_GoTo_t(al, x.base.base.loc, l->m_n)));\r\n                        Vec<ASR::expr_t*> comparator_one;\r\n                        comparator_one.reserve(al, 1);\r\n                        ASR::ttype_t *int32_type = LFortran::ASRUtils::TYPE(ASR::make_Integer_t(al, x.base.base.loc, 4, nullptr, 0));\r\n                        comparator_one.push_back(al, LFortran::ASRUtils::EXPR(ASR::make_IntegerConstant_t(al, x.base.base.loc, i+1, int32_type)));\r\n                        a_body_vec.push_back(al, ASR::down_cast<ASR::case_stmt_t>(ASR::make_CaseStmt_t(al, x.base.base.loc, comparator_one.p, 1, body.p, 1)));\r\n                    }\r\n                }\r\n                ASR::expr_t* target_var = ASRUtils::EXPR(ASR::make_Var_t(al, x.base.base.loc, sym));\r\n                tmp = ASR::make_Select_t(al, x.base.base.loc, target_var, a_body_vec.p,\r\n                           a_body_vec.size(), def_body.p, def_body.size());\r\n            } else {           \r\n```\r\nAnd I would change `ASR::make_IntegerConstant_t(al, x.base.base.loc, i+1, int32_type)` to `ASR::make_IntegerConstant_t(al, x.base.base.loc, l->m_n, int32_type)`.\r\n\r\nThen the other change we need to do is to ignore all `x.m_labels[:]` and rather we need to loop over every label in the local scope. So we need to obtain a list of all local labels. The local labels are just integers and at the ASR level they are represented by the `GoToTarget` node. At the AST level they are represented by the \"label\" argument of statements.\r\n\r\nTo obtain the list of all local labels, in order to keep the compilation to be efficient, I think we can do it like this:\r\n\r\n* For each function, subroutine and program in the BodyVisitor, we will set a boolean variable \"label_list_populated=false\".\r\n* When a GoTo AST node is visited, only then we will call a function \"populate_local_labels\" to populate this list. Then we simply use the list that the function populates to iterate over in the above code.\r\n* The populate_local_labels() would do nothing if `label_list_populated == true`. Otherwise it would go into the body of the given function/subroutine/program, visit every statement and collect any nonzero label arguments into the list. It would also set `label_list_populated=true`. \r\n\r\nThis way if there are no GoTo statements (such as in most modern codes), there is no performance penalty.","closed_by":{"login":"konradha","id":9871746,"node_id":"MDQ6VXNlcjk4NzE3NDY=","avatar_url":"https://avatars.githubusercontent.com/u/9871746?v=4","gravatar_id":"","url":"https://api.github.com/users/konradha","html_url":"https://github.com/konradha","followers_url":"https://api.github.com/users/konradha/followers","following_url":"https://api.github.com/users/konradha/following{/other_user}","gists_url":"https://api.github.com/users/konradha/gists{/gist_id}","starred_url":"https://api.github.com/users/konradha/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/konradha/subscriptions","organizations_url":"https://api.github.com/users/konradha/orgs","repos_url":"https://api.github.com/users/konradha/repos","events_url":"https://api.github.com/users/konradha/events{/privacy}","received_events_url":"https://api.github.com/users/konradha/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/769/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/769/timeline","performed_via_github_app":null,"state_reason":"completed"}