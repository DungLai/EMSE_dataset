{"url":"https://api.github.com/repos/lfortran/lfortran/issues/170","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/170/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/170/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/170/events","html_url":"https://github.com/lfortran/lfortran/issues/170","id":1338681256,"node_id":"I_kwDOCpMuHc5Pyqeo","number":170,"title":"Make the AST round-trippable","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T08:15:34Z","updated_at":"2022-08-15T08:15:34Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/42\n\nThe general idea is to follow the Roslyn design:\n\nhttps://github.com/dotnet/roslyn/wiki/Roslyn%20Overview\n\nOne can play with the Roslyn AST viewer here:\n\nhttps://sharplab.io/\n\n---\n\nThe problem is that it seems the Roslyn AST is not as simple as our LFortran AST. For example Roslyn has all the tokens like `}` and `;` in the AST tree. But those are not needed for the rest of the compiler, because they do not convey any semantic information.\n\nSo we decided to first design LFortran's AST and ASR to be as simple and abstract as possible. We are pretty close with the design. It is important that the design is not influenced by this round-trip requirement, but rather by the requirement that AST and ASR is simple, because that will simplify the rest of LFortran as well as all the other tools that people will write on top.\n\nNext step is to figure out how to add all the optional nodes like white space, `;`, `end if` and other tokens, so that the original source code can be exactly reproduced from AST, and perhaps even from ASR (that's even more complicated than from AST, because ASR does not have any declaration nodes).\n\nAnother open question is whether these optional white space nodes should always be generated, or only when the given (refactoring) tool requires it.\n\nOne should note that we can use the current AST to do formatting, and if the source code is always formatted the way LFortran does it, then we can use LFortran to do refactorings. It's just that it would be very nice to have a tool that can refactor a code base that is not already formatted using LFortran, exactly preserving the original formatting.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/170/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/170/timeline","performed_via_github_app":null,"state_reason":null}