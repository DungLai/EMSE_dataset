{"url":"https://api.github.com/repos/lfortran/lfortran/issues/165","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/165/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/165/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/165/events","html_url":"https://github.com/lfortran/lfortran/issues/165","id":1338680750,"node_id":"I_kwDOCpMuHc5PyqWu","number":165,"title":"Potential features","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T08:15:06Z","updated_at":"2022-08-15T08:15:06Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/29\n\nHere are some nice features that `lfort` can have that other Fortran compilers don't have:\n* nice stacktraces\n* safe mode (https://gitlab.com/lfortran/lfortran/-/issues/369) --- where everything is checked, including pointers (keeping track of who points at `target` variables and when they go out of scope, mark pointers as dangling, and if dereferenced, error out with a nice stacktrace: https://gitlab.com/lfortran/lfortran/-/issues/366), arrays (https://gitlab.com/lfortran/lfortran/-/issues/367), everything. If a code compiles and then segfaults or has undefined behavior, it's a bug in `lfortran`. Once code never gives a stacktrace for any user input, then it can be run with all optimizations on, or compiled with other compilers.\n* all optimizations on by default (just like `ifort`)\n* better than gfortran one at least some benchmarks\n* compile all modern codes\n* arbitrary precision real numbers\n* Arb real numbers\n* exact real numbers (using symengine to build up an exact numerical expression) --- so things like `1+pi+sin(3)` would keep a symengine expression internally.\n* provide optional error propagation for double precision and print lost digits in red or gray.\n* The previous point is essentially an interval arithmetic (https://pdfs.semanticscholar.org/609c/b8e89c7ad0bbfdc6bc79eb3861ccf806122f.pdf), but changed to value+radius, so that it Debug mode you turn on radius, but in release mode you turn off radius, and obtain fast (and identical) results. See also: http://fab.cba.mit.edu/classes/S62.12/docs/Hickey_interval.pdf\n* Provide checks for Fortran school of thought --- randomize operation order in loops, rewrite expressions in random ways, according to the rules of the Fortran school. If the code is written using the rules, it should always work even with randomization.\n* Julia like macros (`[@ assert](https://gitlab.com/assert) x == 1`), implemented in Fortran by implementing a \"function\", except it would be called a `macro`, not a `function`. This means easy access of AST from Fortran (and the required datastructures), and probably the `:()` and `:` operators.\n* Converting functions to subroutines, for faster returning of arrays (https://gitlab.com/lfortran/lfortran/-/issues/384)\n* Incremental compilation (in Jupyter notebook), JIT compilation, behaving like a scripting language, REPL prompt, this would mean relaxing the order of statements, so that one can define a subroutine, and statements before/after.\n* Expose the compiler as a library, for IDE integration, etc. (https://gitlab.com/lfortran/lfortran/-/issues/12), also with nice Python interface for experimenting, writing new applications (say, for spitting out C header files)\n* Automatic wrapping into Python/NumPy, so that one can call subroutines from Python without any extra work from the user.\n* Save the AST and semantic analysis (and all dependency modules with full paths) into the `*.mod` files and create a similar file for programs. One compiles a bigger project using any build system (say, cmake). `lfort` generates these `*.mod` files correctly. Then write external tools that can read these (one points to the main program `*.mod` file and it has links to all the others) and can produce say C header files, or provide proper symbols for IDEs (ctags), or anything else one would like to do with the code.\n* Hook into [loopy](https://github.com/inducer/loopy) and other array optimizing libraries.\n* Automatic calling from Python (no need to write any `iso_c_binding` C / Cython wrappers by hand) and other languages.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/165/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/165/timeline","performed_via_github_app":null,"state_reason":null}