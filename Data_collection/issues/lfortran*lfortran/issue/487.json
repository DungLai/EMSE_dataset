{"url":"https://api.github.com/repos/lfortran/lfortran/issues/487","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/487/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/487/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/487/events","html_url":"https://github.com/lfortran/lfortran/issues/487","id":1338779416,"node_id":"I_kwDOCpMuHc5PzCcY","number":487,"title":"ASR design improvements","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T09:56:15Z","updated_at":"2023-01-05T15:59:07Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/636\r\n\r\nHere are some design improvements/simplifications/generalizations that I think we should consider for ASR and either implement, or reject and document why not:\r\n\r\n* [x] Unify Subroutine/Function into just Function, that has return_type optional (if null, it is a subroutine) (https://gitlab.com/lfortran/lfortran/-/issues/703)\r\n* [ ] Unify stmt and expr into just expr (might actually make things more complex, so might not be worth it..)\r\n* [ ] Unify Explicit/ImplicitCast into just Cast\r\n* [x] https://gitlab.com/lfortran/lfortran/-/issues/637: Add builtin functions `size`, `len`, `u/lbound`, `shape`, `allocated` into ASR itself (one way or another) to make ASR self contained (similar to the string // operation already in ASR)\r\n* [ ] Implement lambda function node, with closures (environment), then make Subroutine/Function just use it (empty environment = no closure), and nested functions might have non empty environment. The LLVM backend then just needs to implement closures in a clean way as a first class feature (currently it is a bit complicated and maybe not fully general). For Fortran only a subset would be used, but for Python (or Scheme) frontends this would be used fully.\r\n* [ ] Function type (signature) should probably be a first class type (helpful for `type(procedure)`) (https://github.com/lfortran/lfortran/issues/1162)\r\n* [ ] Implement generics/templates\r\n* [ ] Brainstorm how dimension/arrays are implemented in the type system\r\n* [ ] Add a tuple type (where each element is typed), allow to return it from functions\r\n* [ ] Add a dictionary type (the key/value are both typed), allow to return it from functions\r\n* [ ] Add a set type, allow to return it from functions\r\n* [ ] See if we can add a DataFrame (R/Panda/Apache Arrow style)\r\n* [ ] Masked arrays to represent missing values (related to data frame also)\r\n* [ ] Efficient \"push_back\" for 1D arrays, just like `std::vector::push_back()` with efficient doubling of internal allocated memory as needed\r\n* [ ] Each type has associated intrinsic functions that operate on it: complex has %re and %im; array has `size`, `shape`, `u/lbound`. String has `len`, `concat`. Dictionary has element access and appending, etc. Set has element access and appending.\r\n* [ ] Besides parallel loops and coarrays, also implement task based parallelism\r\n* [ ] Consider adding unsigned integers (for C interoperability and interacting with binary data formats that may store data in unsigned types)","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/487/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/487/timeline","performed_via_github_app":null,"state_reason":null}