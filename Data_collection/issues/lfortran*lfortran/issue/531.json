{"url":"https://api.github.com/repos/lfortran/lfortran/issues/531","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/531/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/531/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/531/events","html_url":"https://github.com/lfortran/lfortran/issues/531","id":1338782915,"node_id":"I_kwDOCpMuHc5PzDTD","number":531,"title":"How to test the WASM backend","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2022-08-15T10:00:24Z","updated_at":"2022-08-19T20:06:04Z","closed_at":"2022-08-19T16:02:32Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/689\n\nHere are several ideas.\n\n1. The way we can test it is by using our existing `./run_tests.py`, which checks the hash of the generated output (the wasm binary file), but we will not check it into git (it's not a good idea to have binary files in git). Everything will work (`./run_tests.py` was designed to allow this), but one disadvantage is that if some MR changes tests results (say we refactor how the wasm backend works a little bit, which we will do almost for sure from time to time), we'll see that the hash changed, and we'll see the new wasm binary files, but it might not be obvious if we didn't break anything. It would not be quite obvious anyway, even if the old binaries were in git. Plus we can always generate them from master.\n\n2. The second idea is to first generate the wasm binary, then convert it to wat, and store the wat files in git. That way any change will be obvious, as they are stored as text. Just like we store the ASR results.\n\n\nThe second option I think is preferable. There are two further ways to do it:\n\n2a. We can first generate the wasm binary, then convert it to wat. We can either use `wabt` to do it by calling `wasm2wat` (but then LFortran would always depend on it), or we do it as part of LFortran itself (then we need to link the `wabt` library), or we write our own code to do that.\n\n2b. We generate wat directly by the backend/assembler. We then need to maintain both ways, it will be slower (so possibly we only want to do it when a macro define is enabled. \n\n\nI don't know which option is better. \n\nHowever, we also want to have wasm->x86/arm backends. It seems to me those backends should take the wasm binary as input, they should decode it and then transform into x86 or arm (and other platforms if needed). Being able to start from a wasm binary would allow this backend to be tested completely independently of LFortran, and usable for any wasm binary. Which I think is a good design.\n\nSo treating the wasm binary as the \"ground truth\", as the IR, seems like a good design. The alternative is to have WASM.asdl and generate our own IR that represents the WASM binary, which we can do also, but it seems the wasm binary itself has been design in a way that can be used as our IR directly. All we need is to write a \"visitor\" that can visit the individual nodes of the wasm binary.\n\nSo once we have this visitor (that we need for the wasm->x86/arm backends), we can also use this visitor to print the wasm in textual form. I have noticed that WAT doesn't directly corresponds to the binary: it seems it lumps together the function header with the body. So we can possibly have our own textual representation that directly maps what is in the wasm binary (it seems one has to do further transformations on it to get WAT).\n\nIt seems to me the best way forward is to keep the current wasm backend as is, that is, it emits a binary. Then let's write a reader for (any) wasm binary that \"visits\" every element (it gives you access to all the sections and then iterates over each section). Then we'll write a visitor that emits a textual representation and use it for our tests. And we then also write a different visitor that emits x86 and arm machine codes.","closed_by":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/531/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/531/timeline","performed_via_github_app":null,"state_reason":"completed"}