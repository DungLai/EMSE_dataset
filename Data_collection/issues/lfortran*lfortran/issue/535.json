{"url":"https://api.github.com/repos/lfortran/lfortran/issues/535","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/535/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/535/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/535/events","html_url":"https://github.com/lfortran/lfortran/issues/535","id":1338783283,"node_id":"I_kwDOCpMuHc5PzDYz","number":535,"title":"Array operations removal ASR pass","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T10:00:46Z","updated_at":"2022-08-15T10:00:46Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/693\n\nI think we should have an optional ASR pass that removes all array operations, thus making it very easy on the LLVM and other backends. This pass should be optional, because not all backends would use it, and even the LLVM backend might later not use it for performance reasons (of both compile time and runtime).\n\nThis pass (or combination of passes) should do the following transformations:\n\n* Transform all array operations like `a+b` and `a*b` into explicit loops, so all binary operations would operate on array elements (`ArrayItem`), never on `ArraySection` or `Array`. I think the current `array_op` pass already does this. This pass (or a new pass) also has to replace all `ArraySection` with just a loop and `ArrayItem`.\n* All functions that return an array will get transformed into subroutines with `intent(out)` array argument, so the function definition must be rewritten as well as all call sites (expressions must be rewritten using a temporary). This should be a separate pass from `array_op`, to keep things clean.\n\nAfter these two passes run, the only array operations that will remain \n\n* Declaration of arrays\n* Loading and Storing elements in an array using `ArrayItem`\n* Subroutine/functions can accept arrays as arguments, but inside they operate on them element-wise (using `ArrayItem` only). Functions do not return arrays.\n\nWe can think about splitting Assignment into:\n\n* `IntegerAssign`, `RealAssign`, possibly lumping them into `ScalarAssign`\n* `ArrayItemAssign`\n* `ArraySectionAssign`\n\nPossibly rename `Assign` to `Store` or `Set`. That way `ArrayItem` is only used to retrieve an element of an array, as part of an expression.\n\n\nThe bigger issue is what about ASR nodes that return an array? Here they are:\n\n* Integer/Real/Complex BinOp\n* ArraySection\n* ArrayMatMul\n* ArrayTranspose\n* ArrayMerge\n* ArrayReshape\n* ArrayConjugate\n\nI think we want to keep these as ASR nodes that return an array. That makes it natural to map with the front-end language. The BinOp and ArraySection gets rewritten by the `array_op` pass. We should add a pass that rewrites `Reshape`, `Transpose` and `Conjugate` into an explicit loop and a copy, effectively implementing the operation. The `transpose` is actually non-trivial, we should call into a specialized runtime function for that. `MatMul` is like `Transpose`, highly non-trivial for high performance, that requires a runtime function call. I think it's natural if these are kept as `expr` nodes that return an array, as opposed to `stmt` nodes with `intent(out)` array argument. However, we can add a pass that rewrites ASR to introduce temporaries so that each of these nodes is of the form `ArraySectionAssign(a, ArrayMatMul(b, c))`, then the backend can replace these with a function call. Alternatively, we can also add equivalent `stmt` nodes, so for each `a = ArrayTranspose(b)` also have `ArrayTransposeStmt(a, b)`, and an ASR pass that transforms the former into the latter, and the LLVM backend only has to implement `ArrayTransposeStmt`. It seems redundant, but `ArrayMatMulStmt` is effectively equivalent to `ArraySectionAssign(a, ArrayMatMul(b, c))`.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/535/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/535/timeline","performed_via_github_app":null,"state_reason":null}