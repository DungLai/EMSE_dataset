{"url":"https://api.github.com/repos/lfortran/lfortran/issues/504","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/504/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/504/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/504/events","html_url":"https://github.com/lfortran/lfortran/issues/504","id":1338780808,"node_id":"I_kwDOCpMuHc5PzCyI","number":504,"title":"Make inheritance using scoped symbol table","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T09:57:51Z","updated_at":"2022-08-15T09:57:51Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/655\n\nIn https://gitlab.com/lfortran/lfortran/-/merge_requests/1610, we implemented quite complicated symbol resolution from inherited derived types.\n\nIt seems a simpler solution is to make the symbol table in an inherited derived type \"scoped\" using the parent derived type, and then the usual symbol table resolution should just work. We might need to modify a few places, the most important is the check in verify() that goes over a given symbol table (say a module symbol table) and checks that every symbol's parent is the very symbol table. This check will have to be modified to follow the parent recursively until it hits the very symbol table (i.e., you still must get to the very symbol table that contains the given symbol, but it might no longer be directly as parent, but might be a couple steps --- and we should check that this multiple hops parents relationship only applies to derived types and we should check that all steps in this \"ladder\" correspond to a parent derived type appropriately).","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/504/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/504/timeline","performed_via_github_app":null,"state_reason":null}