{"url":"https://api.github.com/repos/lfortran/lfortran/issues/239","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/239/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/239/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/239/events","html_url":"https://github.com/lfortran/lfortran/issues/239","id":1338687495,"node_id":"I_kwDOCpMuHc5PysAH","number":239,"title":"C++ line editing libraries","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T08:21:58Z","updated_at":"2022-08-15T08:21:58Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/141\n\nHere are the C / C++ line editing libraries that I found so far that we could use for the C++ based LFortran:\n\n* [readline](https://tiswww.case.edu/php/chet/readline/rltop.html) (is not BSD licensed, [few examples](https://eli.thegreenplace.net/2016/basics-of-using-the-readline-library/) how to get started)\n* [libedit](http://thrysoee.dk/editline/)\n* [linenoise](https://github.com/antirez/linenoise) (does not seem to support Windows)\n* [replxx](https://github.com/AmokHuginnsson/replxx) (does not support multiline editing)\n\nOutside of C++, we can also consider:\n\n* [Jupyter console](https://github.com/jupyter/jupyter_console) with LFortran kernel\n* [python-prompt-toolkit](https://github.com/prompt-toolkit/python-prompt-toolkit) (we use that in the Python based LFortran)\n\nRelated to this are libraries for handling colors and styles in terminals in a multiplatform way:\n\n* [rang](https://github.com/agauniyal/rang)\n\nAnd in general, there are Text-based user interface ([TUI](https://en.wikipedia.org/wiki/Text-based_user_interface)) libraries:\n\n* [curses](https://en.wikipedia.org/wiki/Curses_%28programming_library%29) and [ncurses](https://www.gnu.org/software/ncurses/ncurses.html) (the most widely used TUI library)\n* [Newt](https://en.wikipedia.org/wiki/Newt_(programming_library))\n* [termbox](https://github.com/nsf/termbox)\n* Go only: [gocui](https://github.com/jroimartin/gocui), [clui](https://github.com/VladimirMarkelov/clui), [tview](https://github.com/rivo/tview)\n\nIt might be the cleanest to write our own library. If we go that route, then here is how it should be done:\n\n* Every terminal (including the `cmd.exe` console on Windows 10 and later) now supports ANSI escape sequences to print colors / move cursors. Here is a demo that works everywhere: https://solarianprogrammer.com/2019/04/08/c-programming-ansi-escape-codes-windows-macos-linux-terminals/. On Windows one must execute some Windows API calls during initialization to enable the ANSI sequences, but the rest of the application is the same as on Linux or macOS.\n\n* Here is my example how to use ANSI sequences to print and react to keyboard and mouse: https://gitlab.com/certik/termui\n\n* The modern approach to write TUI is to follow the same design as [ReactJS](https://en.wikipedia.org/wiki/React_(web_framework)): there is a state of the application, and a render method that takes the state and renders the TUI (or GUI) from scratch. Keyboard / mouse input then has simple callbacks that modify the state, and render is called again. The render method compares old screen with the new screen (drawn from scratch) and creates an efficient \"diff\". For TUI, one creates an efficient sequence of ANSI escape codes to update the whole screen in the most efficient way possible, by comparing the old and new virtual terminal screens (characters and their styles). An example of the screen diffing implementation: https://github.com/prompt-toolkit/python-prompt-toolkit/blob/850a4cdd21713060d5cbd1dfd923b69b1c696f4b/prompt_toolkit/renderer.py#L194. Specifically, one does *not* track the changes to the GUI from the keyboard/mouse callbacks as in the [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) approach, one always re-renders the whole GUI from scratch. Only the renderer does the diffing.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/239/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/239/timeline","performed_via_github_app":null,"state_reason":null}