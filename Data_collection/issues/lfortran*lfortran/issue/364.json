{"url":"https://api.github.com/repos/lfortran/lfortran/issues/364","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/364/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/364/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/364/events","html_url":"https://github.com/lfortran/lfortran/issues/364","id":1338730686,"node_id":"I_kwDOCpMuHc5Py2i-","number":364,"title":"Implement prescanner","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T09:07:38Z","updated_at":"2022-08-15T09:07:38Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/453\n\nIn order to robustly fix issues like https://gitlab.com/lfortran/lfortran/-/issues/430 as well as make progress towards https://gitlab.com/lfortran/lfortran/-/issues/444, we have to implement a prescanner. The job of a prescanner is to take the file that is being compiled, apply the following fixes, and produce a new source that will be used to tokenize and parse. Prescanner fixes:\n\n* Remove all `&` and connect the lines according to the rules\n* Handle the `include` Fortran directive\n* Optionally handle the C preprocessor and/or any other preprocessor such as `fypp`\n* Convert fixed form to free form\n\nIn addition, it will build the following data structures:\n\n* Only one file is being prescanned, but thanks to the include directive and the preprocessor, the final source is composed of many original files (they can be recursive). For each original file, store the name+path, a linear list of position of \"end lines\" (which will be used to quickly convert back and forth between a pointer and a line/column number).\n* If a preprocessor is used, there will be a mapping from a macro invocation to a macro definition\n* The final source code will have a mapping for each character into the original source (as accurately as possible), whether included or macro expanded, and one can recursively get to the original sources that the user has. The final source is divided into consecutive intervals (no gaps, no overlaps). Several options can happen:\n  * An interval can map 1:1 character-wise to an original source interval (both intervals are the same size, but can start at different places). It means the source code is identical in both files in these intervals, so each character in the final source can be mapped to a single character in the original source. This should be by far the most common case.\n  * Macro expansion: An interval (such as `some_function(1, 2, 3)`) maps into an interval (such as `X(3)`) that is the macro being expanded. The two intervals do not represent the same code, and so a single character int he final source can only be mapped to an interval in the original source.\n  * `&` removal: the two consecutive intervals in the final source have a gap in the original source (e.g., the `&\\n    &` does not have any corresponding interval in the final source)\n  * fixed form white space and comments transformation: it seems this would be a combination of the previous two points\n  * macro or Fortran include: One could simply map a long chunk into just a line `#include \"some_header.h\"` in the original file; but a better way would be to map directly into the included file, and that would be the first case (1:1 mapping), just a different filename. It should also remember where in the original it was included.\n  * I don't know if it can happen that intervals overlap in the original source. I can't think of any such case right now.\n  * As such, an interval is simply represented by a starting position in the final source + length; and a starting position in the source file + length. Information if it is 1:1 (and whether directly into original, or via an include line in another file first) or unknown (macro expansion). So in the final source the intervals are just an array of the starting points (as they are continuous and disjunct), the source part has a starting point + length; and for each interval there is the additional metadata of the interval type.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/364/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/364/timeline","performed_via_github_app":null,"state_reason":null}