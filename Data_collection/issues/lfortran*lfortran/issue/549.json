{"url":"https://api.github.com/repos/lfortran/lfortran/issues/549","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/549/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/549/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/549/events","html_url":"https://github.com/lfortran/lfortran/issues/549","id":1338784695,"node_id":"I_kwDOCpMuHc5PzDu3","number":549,"title":"Feature Request: Call Stack Depth or Overflow Detector","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2022-08-15T10:02:06Z","updated_at":"2022-09-13T17:43:25Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/713\n\nDepending on how many function or subroutine calls have taken place, there may be a problem with the stack memory depending on whether an activation record is pushed on the stack. Activation records would need to be studied for the appropriate processor or operating system used such as x86 and Ubuntu or an embedded system processor such as a microcontroller ARM processor core. When a lot of calls might take place (a lot of activation records present), or possibly an infinite amount, there should be an appropriate error or warning generated. This might require tracing through function and subroutine dependencies and knowing whether the standard allows for recursion in the function or subroutine.\n \nFor example,\n```\nprogram recursive\n\n   call sub1()\n\ncontains\n   recursive subroutine sub1()\n      integer :: i = 0\n      i = i + 1\n      print *, 'in sub1', i, 'times'\n      if (i < 7000) then\n         call sub1()\n      else\n         ! enough\n      end if\n      print *, 'enough', i\n   end subroutine\n\nend program\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/549/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/549/timeline","performed_via_github_app":null,"state_reason":null}