{"url":"https://api.github.com/repos/lfortran/lfortran/issues/541","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/541/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/541/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/541/events","html_url":"https://github.com/lfortran/lfortran/issues/541","id":1338783862,"node_id":"I_kwDOCpMuHc5PzDh2","number":541,"title":"Refactor how types are lowered in backends","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T10:01:21Z","updated_at":"2022-08-15T10:01:21Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/701\n\nCurrently we have a lot of repetitive code like this:\n```c++\n        switch (asr_type->type) {\n            case (ASR::ttypeType::Integer) : {\n                ASR::Integer_t* v_type = down_cast<ASR::Integer_t>(asr_type);\n                n_dims = v_type->n_dims;\n                a_kind = v_type->m_kind;\n                if( n_dims > 0 ) {\n                    if (m_abi == ASR::abiType::BindC) {\n                        // Bind(C) arrays are represened as a pointer\n                        type = getIntType(a_kind, true);\n                    } else {\n                        is_array_type = true;\n                        llvm::Type* el_type = get_el_type(asr_type, a_kind);\n                        if( m_storage == ASR::storage_typeType::Allocatable ) {\n                            type = arr_descr->get_malloc_array_type(asr_type, a_kind, n_dims, el_type, true);\n                        } else {\n                            type = arr_descr->get_array_type(asr_type, a_kind, n_dims, el_type, true);\n                        }\n                } else {\n                    if (arg_m_abi == ASR::abiType::BindC\n                        && arg_m_value_attr) {\n                        type = getIntType(a_kind, false);\n                    } else {\n                        type = getIntType(a_kind, true);\n                    }\n            }\n            case (ASR::ttypeType::Real) : {\n                ASR::Real_t* v_type = down_cast<ASR::Real_t>(asr_type);\n                n_dims = v_type->n_dims;\n                a_kind = v_type->m_kind;\n                if( n_dims > 0 ) {\n                    if (m_abi == ASR::abiType::BindC) {\n                        // Bind(C) arrays are represened as a pointer\n                        type = getFPType(a_kind, true);\n                    } else {\n                        is_array_type = true;\n                        llvm::Type* el_type = get_el_type(asr_type, a_kind);\n                        if( m_storage == ASR::storage_typeType::Allocatable ) {\n                            type = arr_descr->get_malloc_array_type(asr_type, a_kind, n_dims, el_type, true);\n\n```\nfor each type, and repeated for arguments, local variables etc. So adding a new type (or refactoring how a particular type is lowered) requires changes at a lot of places in the code and ensuring they are all compatible. Rather, I think the `asr_to_llvm.cpp` file should be effectively type independent and the above code should instead be something like:\n```c++\n                type_builder = get_type_builder(asr_type) // returns a specific instance of the type builder based on type, kind (but not dims)\n                n_dims = get_ndims(asr_type);\n                if( n_dims > 0 ) {\n                    if (m_abi == ASR::abiType::BindC) {\n                        type = type_builder->get_bindc_array();\n                    } else {\n                        is_array_type = true;\n                        if( m_storage == ASR::storage_typeType::Allocatable ) {\n                            type = type_builder->get_allocatable_array(n_dims);\n                        } else {\n                            type = type_builder->get_array(n_dims);\n                        }\n                } else {\n                    if (arg_m_abi == ASR::abiType::BindC\n                        && arg_m_value_attr) {\n                        type = type_builder->get_bindc_value();\n                    } else {\n                        type = type_builder->get();\n                    }\n            }\n```\nAnd then we create a separate header file, where we create a specific class for each type and kind, as follows:\n```c++\nclass Integer8TypeBuilder : public TypeBuilder {\n    llvm::Type* get_allocatable_array(int n_dims) { return arr_descr->get_malloc_array_type(Integer8, 8, n_dims, Integer8, true); }\n    llvm::Type* get_array(int n_dims) { return arr_descr->get_array_type(Integer8, 8, n_dims, Integer8, true);  }\n    llvm::Type* get_bindc_array() { return getIntType(8, true); }\n    llvm::Type* get_bindc_value() { return getIntType(8, false); }\n    llvm::Type* get() { return getIntType(8, true); }\n}\n```\nAnd the function `get_type_builder(asr_type)` then returns a particular instance, such as `Integer8TypeBuilder` or `Real4TypeBuilder`. These instances would be pre-created, it would just quickly return a pointer, so that it is fast.\n\nThe `asr_to_llvm` would remember for each variable if it is passed by value or not, if it is allocatable or not, if it is a pointer or not, if it is an array or not, and all allowed combinations. But it would interact with the actual concrete type via the above \"interface\", which is type/kind independent. We have to design exactly how this \"interface\" should look like, but it should beautifully clean up the `asr_to_llvm` to become type independent, and we have all aspects of lowering of a given type at one place.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/541/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/541/timeline","performed_via_github_app":null,"state_reason":null}