{"url":"https://api.github.com/repos/lfortran/lfortran/issues/1038","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/1038/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/1038/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/1038/events","html_url":"https://github.com/lfortran/lfortran/issues/1038","id":1464811738,"node_id":"I_kwDOCpMuHc5XT0Da","number":1038,"title":"Generic renaming and error message for +","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2022-11-25T17:57:43Z","updated_at":"2023-01-09T07:07:30Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Two bugs and one question:\r\n\r\n\r\nIt does not accept a generic renaming of the instantiations, e.g., triple_add_l => triple_l.\r\nOne would expect an error message in triple_e which uses an undeclared + on type T.\r\nIs it possible to put requirement Magma_r in a separate module that one can reuse in many examples?\r\n\r\n\r\n```fortran\r\nmodule Math_integer_m\r\n\r\n    implicit none\r\n    private\r\n    public :: add_integer, mult_integer, minus_integer, max_integer, min_integer, zero_integer, one_integer\r\n\r\ncontains\r\n\r\n    pure function add_integer(x, y) result(result)\r\n        integer, intent(in) :: x, y\r\n        integer :: result\r\n        result = x + y\r\n    end function\r\n\r\n    pure function mult_integer(x, y) result(result)\r\n        integer, intent(in) :: x, y\r\n        integer :: result\r\n        result = x * y\r\n    end function\r\n\r\n    pure function minus_integer(x, y) result(result)\r\n        integer, intent(in) :: x, y\r\n        integer :: result\r\n        result = x - y\r\n    end function\r\n\r\n    pure function max_integer(x, y) result(result)\r\n        integer, intent(in) :: x, y\r\n        integer :: result\r\n        result = max ( x, y )\r\n    end function\r\n\r\n    pure function min_integer(x, y) result(result)\r\n        integer, intent(in) :: x, y\r\n        integer :: result\r\n        result = min ( x, y )\r\n    end function\r\n\r\n    pure function zero_integer() result(result)\r\n        integer :: result\r\n        result = 0\r\n    end function\r\n\r\n    pure function one_integer() result(result)\r\n        integer :: result\r\n        result = 1\r\n    end function\r\n\r\nend module\r\n\r\n\r\n\r\n\r\n\r\n\r\nmodule Math_real_m\r\n\r\n    implicit none\r\n    private\r\n    public :: add_real, mult_real, minus_real, slash_real, max_real, min_real, zero_real, one_real\r\n\r\ncontains\r\n\r\n    pure function add_real(x, y) result(result)\r\n        real, intent(in) :: x, y\r\n        real :: result\r\n        result = x + y\r\n    end function\r\n\r\n    pure function mult_real(x, y) result(result)\r\n        real, intent(in) :: x, y\r\n        real :: result\r\n        result = x * y\r\n    end function\r\n\r\n    pure function minus_real(x, y) result(result)\r\n        real, intent(in) :: x, y\r\n        real :: result\r\n        result = x - y\r\n    end function\r\n\r\n    pure function slash_real(x, y) result(result)\r\n        real, intent(in) :: x, y\r\n        real :: result\r\n        result = x / y\r\n    end function\r\n\r\n    pure function max_real(x, y) result(result)\r\n        real, intent(in) :: x, y\r\n        real :: result\r\n        result = max ( x, y )\r\n    end function\r\n\r\n    pure function min_real(x, y) result(result)\r\n        real, intent(in) :: x, y\r\n        real :: result\r\n        result = min ( x, y )\r\n    end function\r\n\r\n    pure function zero_real() result(result)\r\n        real :: result\r\n        result = 0.0\r\n    end function\r\n\r\n    pure function one_real() result(result)\r\n        real :: result\r\n        result = 1.0\r\n    end function\r\n\r\nend module\r\n\r\n\r\nmodule Triple_m\r\n\r\n    implicit none\r\n    private\r\n    public :: triple_tmpl\r\n\r\n    requirement Magma_r(T, plus_T)\r\n        type :: T; end type\r\n\r\n        pure function plus_T(l, r) result(total)\r\n            type(T), intent(in) :: l, R\r\n            type(T) :: total\r\n        end function\r\n    end requirement\r\n\r\n    template triple_tmpl(T, plus_T)\r\n        private\r\n        public :: triple_l, triple_r, triple_e\r\n        requires Magma_r(T,plus_T)\r\n    contains\r\n        pure function triple_l(t) result(res)\r\n            type(T), intent(in) :: t\r\n            type(T) :: res\r\n            res = plus_T( plus_T(t,t), t )\r\n        end function\r\n        pure function triple_r(t) result(res)\r\n            type(T), intent(in) :: t\r\n            type(T) :: res\r\n            res = plus_T( t, plus_T(t,t) )\r\n        end function\r\n        pure function triple_e(t) result(res)\r\n            type(T), intent(in) :: t\r\n            type(T) :: res\r\n            res = plus_T( t, t+t )\r\n        end function\r\n    end template\r\n\r\nend module\r\n\r\nmodule use_triple_m\r\n\r\n    use Math_integer_m\r\n    use Math_real_m\r\n\r\ncontains\r\n\r\n    subroutine test_add_triples()\r\n        instantiate triple_tmpl(integer, add_integer), &\r\n            only: triple_add_l => triple_l, &\r\n                  triple_add_r => triple_r\r\n        integer tal = triple_add_l(7)\r\n        integer tar = triple_add_r(7)\r\n        ! integer tae = triple_add_e(7)\r\n        print *, \"tal=\", tal, \" tar=\", tar ! \" tae=\", tae\r\n    end subroutine\r\n    subroutine test_minus_triples()\r\n        instantiate triple_tmpl(real, minus_real), &\r\n            only: triple_minus_l => triple_l, &\r\n                  triple_minus_r => triple_r\r\n        real tml = triple_minus_l(7)\r\n        real tmr = triple_minus_r(7)\r\n        print *, \"tml=\", tml, \" tmr=\", tmr\r\n    end subroutine\r\n    subroutine test_max_triples()\r\n        instantiate triple_tmpl(real, max_real), &\r\n            only: triple_max_l => triple_l, &\r\n                  triple_max_r => triple_r\r\n        real tmaxl = triple_max_l(7)\r\n        real tmaxr = triple_max_r(7)\r\n        print *, \"tmaxl=\", tmaxl, \" tmaxr=\", tmaxr\r\n    end subroutine\r\n\r\nend module\r\n\r\nprogram template_triple_test\r\nuse template_travel_m\r\nimplicit none\r\n\r\ncall test_add_triples()\r\ncall test_minus_triples()\r\ncall test_max_triples()\r\n\r\nend program template_triple_test\r\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/1038/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/1038/timeline","performed_via_github_app":null,"state_reason":null}