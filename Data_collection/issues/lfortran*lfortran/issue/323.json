{"url":"https://api.github.com/repos/lfortran/lfortran/issues/323","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/323/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/323/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/323/events","html_url":"https://github.com/lfortran/lfortran/issues/323","id":1338724663,"node_id":"I_kwDOCpMuHc5Py1E3","number":323,"title":"Port HIP translation to use ASR","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T09:03:38Z","updated_at":"2022-08-15T09:03:38Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/323\n\nIn https://gitlab.com/lfortran/lfortran/-/merge_requests/839 it became too hard to keep the AST -> C++/HIP translation up to date after an AST refactoring so it was removed in https://gitlab.com/lfortran/lfortran/-/merge_requests/844; the translation needs to be ported to use ASR anyway and it wasn't actually used in production anyway. I created this issue to document the current state, what was working and how to re-enable it properly.\n\nThe last version in master that works is 737fc413dc4ac532cdf3db07f8ac9f06f1100e43. Here is how to use it, on the only two examples that were actually tested as part of the testsuite:\n```console\n$ cat tests/subroutine4.f90 \nsubroutine triad(a, b, scalar, c)\nreal, intent(in) :: a(:), b(:), scalar\nreal, intent(out) :: c(:)\ninteger :: N, i\nN = size(a)\ndo concurrent (i = 1:N)\n    c(i) = a(i) + scalar * b(i)\nend do\nend subroutine\n\n$ ./src/bin/cpptranslate --show-ast-cpp-hip tests/subroutine4.f90\n#define blocksize 128\n\n//Pass by value variables found in the loop body:  scalar\n//Pass by reference variables found in the loop body:  b a c\n__global__ void Tempkernelname(int N, float scalar, float *b, float *a, float *c){\n    int i = blockIDx.x*blockDim.x+threadIdx.x;\n    if (i >= N) return;\n    c[i] = (a[i]) + ((scalar)*(b[i]));\n}\n\nvoid triad(float *a, size_t a_size, float *b, size_t b_size, float scalar, \nfloat *c, size_t c_size)\n{\n    size_t N;\n    size_t i;\n    N = a_size;\n    int gridsize = (N + blocksize - 1)/blocksize;\n    float *b_d;\n    hipMalloc(&b_d, N*sizeof(float));\n    hipMemcpy(b_d, b, N*sizeof(float), hipMemcpyHostToDevice);\n    float *a_d;\n    hipMalloc(&a_d, N*sizeof(float));\n    hipMemcpy(a_d, a, N*sizeof(float), hipMemcpyHostToDevice);\n    float *c_d;\n    hipMalloc(&c_d, N*sizeof(float));\n    hipMemcpy(c_d, c, N*sizeof(float), hipMemcpyHostToDevice);\n    hipLaunchKernelGGL(Tempkernelname, dim3(gridsize), dim3(blocksize), 0, 0, N, scalar, b_d, a_d, c_d);\n\n}\n\n$ cat tests/subroutine6.f90 \nsubroutine triad(a, b, scalar, c)\nreal, intent(in) :: a(:), b(:), scalar\nreal, intent(out) :: c(:)\ninteger :: N, N2, i, j\nN = size(a)\nN2 = size(b)\ndo concurrent (i = 1:N)\n    c(i) = a(i) + scalar * b(i)\nend do\n\ndo concurrent (j = 1:N2)\n    c(j) = b(j) + scalar\nend do\nend subroutine\n\n$ ./src/bin/cpptranslate --show-ast-cpp-hip tests/subroutine6.f90\n#define blocksize 128\n\n//Pass by value variables found in the loop body:  scalar\n//Pass by reference variables found in the loop body:  b c\n__global__ void Tempkernelname1(int N2, float scalar, float *b, float *c){\n    int j = blockIDx.x*blockDim.x+threadIdx.x;\n    if (j >= N2) return;\n    c[j] = (b[j]) + (scalar);\n}\n\n//Pass by value variables found in the loop body:  scalar\n//Pass by reference variables found in the loop body:  b a c\n__global__ void Tempkernelname(int N, float scalar, float *b, float *a, float *c){\n    int i = blockIDx.x*blockDim.x+threadIdx.x;\n    if (i >= N) return;\n    c[i] = (a[i]) + ((scalar)*(b[i]));\n}\n\nvoid triad(float *a, size_t a_size, float *b, size_t b_size, float scalar, \nfloat *c, size_t c_size)\n{\n    size_t N;\n    size_t N2;\n    size_t i;\n    size_t j;\n    N = a_size;\n    N2 = a_size;\n    int gridsize = (N + blocksize - 1)/blocksize;\n    float *b_d;\n    hipMalloc(&b_d, N*sizeof(float));\n    hipMemcpy(b_d, b, N*sizeof(float), hipMemcpyHostToDevice);\n    float *a_d;\n    hipMalloc(&a_d, N*sizeof(float));\n    hipMemcpy(a_d, a, N*sizeof(float), hipMemcpyHostToDevice);\n    float *c_d;\n    hipMalloc(&c_d, N*sizeof(float));\n    hipMemcpy(c_d, c, N*sizeof(float), hipMemcpyHostToDevice);\n    hipLaunchKernelGGL(Tempkernelname, dim3(gridsize), dim3(blocksize), 0, 0, N, scalar, b_d, a_d, c_d);\n\n    int gridsize1 = (N2 + blocksize - 1)/blocksize;\n    float *b_d1;\n    hipMalloc(&b_d1, N2*sizeof(float));\n    hipMemcpy(b_d1, b, N2*sizeof(float), hipMemcpyHostToDevice);\n    float *c_d1;\n    hipMalloc(&c_d1, N2*sizeof(float));\n    hipMemcpy(c_d1, c, N2*sizeof(float), hipMemcpyHostToDevice);\n    hipLaunchKernelGGL(Tempkernelname1, dim3(gridsize1), dim3(blocksize), 0, 0, N2, scalar, b_d1, c_d1);\n\n}\n```\n\nThe translation was mainly implemented in the `visit_DoConcurrentLoop()` method here: https://gitlab.com/lfortran/lfortran/-/blob/737fc413dc4ac532cdf3db07f8ac9f06f1100e43/src/lfortran/ast_to_cpp_hip.cpp#L489.\n\nWhat we should do to re-enable this feature is to take the new ASR based C++ backend, and enable to select how to parallelize arrays and loops. Currently Kokkos is hardwired in the C++ backend and we should also allow just raw C pointers and HIP, or any other combination that people would like to see.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/323/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/323/timeline","performed_via_github_app":null,"state_reason":null}