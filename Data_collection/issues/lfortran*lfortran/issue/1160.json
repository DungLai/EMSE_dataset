{"url":"https://api.github.com/repos/lfortran/lfortran/issues/1160","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/1160/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/1160/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/1160/events","html_url":"https://github.com/lfortran/lfortran/issues/1160","id":1519302572,"node_id":"I_kwDOCpMuHc5ajres","number":1160,"title":"Idea: introduce Array type node","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2023-01-04T17:01:25Z","updated_at":"2023-01-04T17:05:30Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"And store `arraystorage` and `arrayrepresentation` in it:\r\n```diff\r\n--- a/src/libasr/ASR.asdl\r\n+++ b/src/libasr/ASR.asdl\r\n@@ -275,8 +275,8 @@ expr\r\n \r\n     | Var(symbol v)\r\n \r\n-    | ArrayConstant(expr* args, ttype type, arraystorage storage_format)\r\n-    | ArrayItem(expr v, array_index* args, ttype type, arraystorage storage_format, expr? value)\r\n+    | ArrayConstant(expr* args, ttype type)\r\n+    | ArrayItem(expr v, array_index* args, ttype type, expr? value)\r\n     | ArraySection(expr v, array_index* args, ttype type, expr? value)\r\n     | ArraySize(expr v, expr? dim, ttype type, expr? value)\r\n     | ArrayBound(expr v, expr? dim, ttype type, arraybound bound,\r\n@@ -335,23 +335,25 @@ expr\r\n --     integer, so we also use kind=4 for the default logical.)\r\n \r\n ttype\r\n-    = Integer(int kind, dimension* dims)\r\n-    | Real(int kind, dimension* dims)\r\n-    | Complex(int kind, dimension* dims)\r\n-    | Character(int kind, int len, expr? len_expr, dimension* dims)\r\n-    | Logical(int kind, dimension* dims)\r\n+    = Integer(int kind)\r\n+    | Real(int kind)\r\n+    | Complex(int kind)\r\n+    | Character(int kind, int len, expr? len_expr)\r\n+    | Logical(int kind)\r\n     | Set(ttype type)\r\n     | List(ttype type)\r\n     | Tuple(ttype* type)\r\n-    | Struct(symbol derived_type, dimension* dims)\r\n-    | Enum(symbol enum_type, dimension *dims)\r\n-    | Union(symbol union_type, dimension *dims)\r\n-    | Class(symbol class_type, dimension* dims)\r\n+    | Struct(symbol derived_type)\r\n+    | Enum(symbol enum_type)\r\n+    | Union(symbol union_type)\r\n+    | Class(symbol class_type)\r\n     | Dict(ttype key_type, ttype value_type)\r\n     | Pointer(ttype type)\r\n+    | Array(ttype type, dimension* dims, arraystorage storage_format,\r\n+        arrayrepresentation representation)\r\n     | Const(ttype type)\r\n     | CPtr()\r\n-    | TypeParameter(identifier param, dimension* dims)\r\n+    | TypeParameter(identifier param)\r\n \r\n restriction_arg = RestrictionArg(identifier restriction_name, symbol restriction_func)\r\n \r\n@@ -367,6 +369,12 @@ arraybound = LBound | UBound\r\n \r\n arraystorage = RowMajor | ColMajor\r\n \r\n+arrayrepresentation\r\n+    = ArrayRepresentationPointer\r\n+    | ArrayRepresentationDescriptor\r\n+-- In the future there might be different descriptors too (such as those that\r\n+allow strides)\r\n+\r\n cast_kind\r\n     = RealToInteger\r\n     | IntegerToReal\r\n```\r\n\r\nThen in the backend one would know for each array variable how it is represented. \r\n\r\nJust like RowMajor / ColMajor, it's in some sense a backend decision, but it helps to have this in the ASR itself, especially for C interoperability. The same with descriptor/pointer.\r\n\r\nWe can think of these as optimization decisions, the optimizer can choose based on various criteria how to represent it. In the backend we would not be making any of these choices anymore, and just implement what is directed in ASR, or give an error message if we do not support it.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/1160/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/1160/timeline","performed_via_github_app":null,"state_reason":null}