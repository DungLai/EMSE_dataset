{"url":"https://api.github.com/repos/lfortran/lfortran/issues/204","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/204/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/204/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/204/events","html_url":"https://github.com/lfortran/lfortran/issues/204","id":1338684378,"node_id":"I_kwDOCpMuHc5PyrPa","number":204,"title":"Add automatic differentiation","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T08:18:45Z","updated_at":"2022-08-15T08:18:45Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/97\n\nThis has been requested several times. \n\n1. The first step would be to add code that takes an ASR of some Fortran function and returns the derivative as an ASR.\n\n2. Then one can easily write a Python script that will retrieve a Fortran function from a module, differentiates and generates Fortran code in a new module.\n\n3. Further improvement can be to have something like pragmas, something like:\n   ```fortran\n   !pragma lfortran autodiff(pow_diff)\n   real(dp) function pow(x, a)\n   pow = x**a\n   end function\n   ```\n   which would call an `autodiff` function implemented in step 1. above, and \"insert\" the generated function in the current module as `pod_diff` function. This would be a general mechanism how to create \"macros\" or anything else we want. One would simply implement any such custom functionality, say, using the Python API of LFortran.\n\nAnother option to explore would be to add a new type, for example as an LFortran extension implemented using the code from 1. I don't know if that makes sense or not, I feel the option 3. might be the best way to integrate this with Fortran.\n\nWe can get inspired, e.g., by the [Zygote](https://github.com/FluxML/Zygote.jl) module in Julia.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/204/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/204/timeline","performed_via_github_app":null,"state_reason":null}