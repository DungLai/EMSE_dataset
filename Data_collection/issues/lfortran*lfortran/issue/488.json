{"url":"https://api.github.com/repos/lfortran/lfortran/issues/488","repository_url":"https://api.github.com/repos/lfortran/lfortran","labels_url":"https://api.github.com/repos/lfortran/lfortran/issues/488/labels{/name}","comments_url":"https://api.github.com/repos/lfortran/lfortran/issues/488/comments","events_url":"https://api.github.com/repos/lfortran/lfortran/issues/488/events","html_url":"https://github.com/lfortran/lfortran/issues/488","id":1338779511,"node_id":"I_kwDOCpMuHc5PzCd3","number":488,"title":"ASR Intrinsic function design","user":{"login":"certik","id":20568,"node_id":"MDQ6VXNlcjIwNTY4","avatar_url":"https://avatars.githubusercontent.com/u/20568?v=4","gravatar_id":"","url":"https://api.github.com/users/certik","html_url":"https://github.com/certik","followers_url":"https://api.github.com/users/certik/followers","following_url":"https://api.github.com/users/certik/following{/other_user}","gists_url":"https://api.github.com/users/certik/gists{/gist_id}","starred_url":"https://api.github.com/users/certik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/certik/subscriptions","organizations_url":"https://api.github.com/users/certik/orgs","repos_url":"https://api.github.com/users/certik/repos","events_url":"https://api.github.com/users/certik/events{/privacy}","received_events_url":"https://api.github.com/users/certik/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-08-15T09:56:20Z","updated_at":"2022-08-15T09:56:20Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"*Original issue*: https://gitlab.com/lfortran/lfortran/-/issues/637\n\nMost Fortran intrinsic functions can actually be implemented in pure or impure LFortran runtime library using Fortran. That is the best design.\n\nHowever, then there are some functions that must be implemented by the ASR backend itself, such as `size`, `len`, `u/lbound`, `shape`, `allocated`, string `//`, `%re`, `%im`, etc. Currently they are implemented in the `builtin` section of the LFortran runtime library, but they should really be part of the ASR itself, to make it self contained and easily reusable by different frontends, as well as more clear in the backend that those functions have to be implemented no matter what.\n\nOne option is to add more nodes to `expr`. For example the string concatenation `//` is implemented as `StrOp` node. However, the node can only accept an `expr` expression, and that is actually the wrong kind of abstraction for this. It really is just a function that accepts two strings and returns a string. The `size`, `shape` and `u/lbound` functions operate on an array (of any type). The `allocated` function operates on any type (integer/real/..., array or not) that is allocatable. The `%re` and `%im` are read/write members of the complex type.\n\nThere are two ways out. Either they will be added as expr nodes, but we need to add extra checking to restrict the argument from any `expr` to a particular subset, such as only arrays, or only complex type, or only string type.\n\nOr they should be represented as Function interfaces, of the proper type, and using FunctionCall expr node to call them. That should be possible in most cases and it seems cleaner.\n\nOne option is to predeclare these interfaces in the global scope, always. A cleaner way seems to have a module (as it is now) with these interfaces, and the frontend inserts them as needed. That is in fact already the current design, it's just that we currently use Fortran to represent the interfaces, and we should move this into the ASR library itself, in a Fortran independent way somehow. We should also extend our type system in such a way so that one can represent the argument types naturally and accurately, so that we can reuse the type checking mechanism and error reporting.\n\nWhat about `%re` and `%im`? The frontend can recognize if they are used for writing or reading and generate appropriate `set/get_re/im` methods. If they are passed as `intent(inout)` arguments to functions, the frontend might need to create a temporary variable, and `get_re/im` to initialize it, and `set_re/im` on the complex type after the function is finished.\n\nAn alternative implementation is to implement `%re`, `%im` as attributes of the type. An array type can have `.size` and `.shape` read only attributes. A string can have a `.len` attribute as well as a `.concat` method. This approach in some sense is quite similar to a dedicated builtin module approach.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/lfortran/lfortran/issues/488/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/lfortran/lfortran/issues/488/timeline","performed_via_github_app":null,"state_reason":null}