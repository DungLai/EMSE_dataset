{"url":"https://api.github.com/repos/catalyst-team/catalyst/issues/913","repository_url":"https://api.github.com/repos/catalyst-team/catalyst","labels_url":"https://api.github.com/repos/catalyst-team/catalyst/issues/913/labels{/name}","comments_url":"https://api.github.com/repos/catalyst-team/catalyst/issues/913/comments","events_url":"https://api.github.com/repos/catalyst-team/catalyst/issues/913/events","html_url":"https://github.com/catalyst-team/catalyst/issues/913","id":675965328,"node_id":"MDU6SXNzdWU2NzU5NjUzMjg=","number":913,"title":"Iteration-based training","user":{"login":"janvainer","id":31015638,"node_id":"MDQ6VXNlcjMxMDE1NjM4","avatar_url":"https://avatars.githubusercontent.com/u/31015638?v=4","gravatar_id":"","url":"https://api.github.com/users/janvainer","html_url":"https://github.com/janvainer","followers_url":"https://api.github.com/users/janvainer/followers","following_url":"https://api.github.com/users/janvainer/following{/other_user}","gists_url":"https://api.github.com/users/janvainer/gists{/gist_id}","starred_url":"https://api.github.com/users/janvainer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/janvainer/subscriptions","organizations_url":"https://api.github.com/users/janvainer/orgs","repos_url":"https://api.github.com/users/janvainer/repos","events_url":"https://api.github.com/users/janvainer/events{/privacy}","received_events_url":"https://api.github.com/users/janvainer/received_events","type":"User","site_admin":false},"labels":[{"id":1029400272,"node_id":"MDU6TGFiZWwxMDI5NDAwMjcy","url":"https://api.github.com/repos/catalyst-team/catalyst/labels/enhancement","name":"enhancement","color":"a2eeef","default":true,"description":"New feature or request"},{"id":1029400273,"node_id":"MDU6TGFiZWwxMDI5NDAwMjcz","url":"https://api.github.com/repos/catalyst-team/catalyst/labels/help%20wanted","name":"help wanted","color":"008672","default":true,"description":"Extra attention is needed"},{"id":1029400277,"node_id":"MDU6TGFiZWwxMDI5NDAwMjc3","url":"https://api.github.com/repos/catalyst-team/catalyst/labels/wontfix","name":"wontfix","color":"ffffff","default":true,"description":"This will not be worked on"}],"state":"closed","locked":false,"assignee":{"login":"bagxi","id":19803638,"node_id":"MDQ6VXNlcjE5ODAzNjM4","avatar_url":"https://avatars.githubusercontent.com/u/19803638?v=4","gravatar_id":"","url":"https://api.github.com/users/bagxi","html_url":"https://github.com/bagxi","followers_url":"https://api.github.com/users/bagxi/followers","following_url":"https://api.github.com/users/bagxi/following{/other_user}","gists_url":"https://api.github.com/users/bagxi/gists{/gist_id}","starred_url":"https://api.github.com/users/bagxi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagxi/subscriptions","organizations_url":"https://api.github.com/users/bagxi/orgs","repos_url":"https://api.github.com/users/bagxi/repos","events_url":"https://api.github.com/users/bagxi/events{/privacy}","received_events_url":"https://api.github.com/users/bagxi/received_events","type":"User","site_admin":false},"assignees":[{"login":"ditwoo","id":7264490,"node_id":"MDQ6VXNlcjcyNjQ0OTA=","avatar_url":"https://avatars.githubusercontent.com/u/7264490?v=4","gravatar_id":"","url":"https://api.github.com/users/ditwoo","html_url":"https://github.com/ditwoo","followers_url":"https://api.github.com/users/ditwoo/followers","following_url":"https://api.github.com/users/ditwoo/following{/other_user}","gists_url":"https://api.github.com/users/ditwoo/gists{/gist_id}","starred_url":"https://api.github.com/users/ditwoo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ditwoo/subscriptions","organizations_url":"https://api.github.com/users/ditwoo/orgs","repos_url":"https://api.github.com/users/ditwoo/repos","events_url":"https://api.github.com/users/ditwoo/events{/privacy}","received_events_url":"https://api.github.com/users/ditwoo/received_events","type":"User","site_admin":false},{"login":"Scitator","id":7606451,"node_id":"MDQ6VXNlcjc2MDY0NTE=","avatar_url":"https://avatars.githubusercontent.com/u/7606451?v=4","gravatar_id":"","url":"https://api.github.com/users/Scitator","html_url":"https://github.com/Scitator","followers_url":"https://api.github.com/users/Scitator/followers","following_url":"https://api.github.com/users/Scitator/following{/other_user}","gists_url":"https://api.github.com/users/Scitator/gists{/gist_id}","starred_url":"https://api.github.com/users/Scitator/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Scitator/subscriptions","organizations_url":"https://api.github.com/users/Scitator/orgs","repos_url":"https://api.github.com/users/Scitator/repos","events_url":"https://api.github.com/users/Scitator/events{/privacy}","received_events_url":"https://api.github.com/users/Scitator/received_events","type":"User","site_admin":false},{"login":"bagxi","id":19803638,"node_id":"MDQ6VXNlcjE5ODAzNjM4","avatar_url":"https://avatars.githubusercontent.com/u/19803638?v=4","gravatar_id":"","url":"https://api.github.com/users/bagxi","html_url":"https://github.com/bagxi","followers_url":"https://api.github.com/users/bagxi/followers","following_url":"https://api.github.com/users/bagxi/following{/other_user}","gists_url":"https://api.github.com/users/bagxi/gists{/gist_id}","starred_url":"https://api.github.com/users/bagxi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagxi/subscriptions","organizations_url":"https://api.github.com/users/bagxi/orgs","repos_url":"https://api.github.com/users/bagxi/repos","events_url":"https://api.github.com/users/bagxi/events{/privacy}","received_events_url":"https://api.github.com/users/bagxi/received_events","type":"User","site_admin":false}],"milestone":null,"comments":2,"created_at":"2020-08-10T08:38:15Z","updated_at":"2020-10-23T11:01:24Z","closed_at":"2020-10-23T11:01:24Z","author_association":"NONE","active_lock_reason":null,"body":"## ðŸš€ Feature Request\r\nMake iteration-based training available - instead of specifying epoch count, the user should be ableto specify gradient step cound and spefify how many steps form an epoch. The dataloader would be cycled indefinitely.\r\n\r\n\r\n### Motivation\r\nLets say I have a very large dataset. One epoch of training (seeing all the data) can easily take several hours.\r\nI want to be able to do the following actions after a certain number of seen batches irrespective of wether the epoch is over or not:\r\n\r\n1. Run validation on validation set\r\n2. Show example outputs\r\n3. Make scheduler step - this is very important, because If I run only say 4 epochs on my large dataset, I get only 4 scheduler steps, but the optimizer has made very many steps in the mean time\r\n4. Save a checkpoint\r\n\r\n### Proposal\r\nI would like an interface to be something like this:\r\n\r\n```\r\n    runner.train(\r\n        model, \r\n        train_loader,\r\n        epochs=args.epochs,\r\n        scheduler_step_every=1,   # each epoch, make a step\r\n        steps_per_epoch=args.steps_per_epoch,  # how many gradient steps form an epoch\r\n        valid_loader=valid_loader,\r\n    )\r\n```\r\n\r\n\r\n It would be nice to have this option in the default api.\r\nThe main problem is how to make the dataloader go infinitely. One can wrap any dataloader in something like Infinite Stream:\r\n```\r\nclass InfiniteEpochStream:\r\n    def __init__(self, data_loader, steps_per_epoch):\r\n        self.data_loader = data_loader\r\n        self.steps_per_iter = steps_per_epoch\r\n        self.iterator = iter(self.data_loader)\r\n\r\n        self.__steps = 0\r\n        self.__iterator_steps = 0\r\n\r\n    def __iter__(self):\r\n        self.__steps = 0\r\n        return self\r\n\r\n    def __len__(self):\r\n        return self.steps_per_iter\r\n\r\n    def __next__(self):\r\n        if self.__steps < self.steps_per_iter:\r\n            if self.__iterator_steps >= len(self.data_loader):\r\n                self.__refresh_iterator()\r\n\r\n            self.__steps += 1\r\n            self.__iterator_steps += 1\r\n            return next(self.iterator)\r\n        else:\r\n            raise StopIteration\r\n\r\n    def __refresh_iterator(self):\r\n        self.iterator = iter(self.data_loader)\r\n        self.__iterator_steps = 0\r\n```\r\nA dataloader wrapped in this class should cycle indefinitely over random batches.\r\nNow we can do the following:\r\n\r\n```\r\nnum_samples, num_features, num_classes = int(1e4), int(1e1), 4\r\nX = torch.rand(num_samples, num_features)\r\ny = (torch.rand(num_samples, ) * num_classes).to(torch.int64)\r\n\r\n# pytorch loaders\r\ndataset = TensorDataset(X, y)\r\nloader = DataLoader(dataset, batch_size=32, num_workers=1)\r\nloaders = {\r\n    \"train\": InfiniteEpochStream(loader, steps_per_epoch=1000),  # after 1000 steps, the loader wil return StopIteration\r\n    \"valid\": loader}\r\n\r\n# model, criterion, optimizer, scheduler\r\nmodel = torch.nn.Linear(num_features, num_classes)\r\ncriterion = torch.nn.CrossEntropyLoss()\r\noptimizer = torch.optim.Adam(model.parameters())\r\nscheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, [2])\r\n\r\n# model training\r\nrunner = dl.SupervisedRunner()\r\nrunner.train(\r\n    model=model,\r\n    criterion=criterion,\r\n    optimizer=optimizer,\r\n    scheduler=scheduler,\r\n    loaders=loaders,\r\n    logdir=\"./logdir\",\r\n    num_epochs=3,\r\n    callbacks=[dl.AccuracyCallback(num_classes=num_classes)]\r\n)\r\n```\r\n\r\nI am not sure how this would play with the distributed training as the [distributed training examples ](https://catalyst-team.github.io/catalyst/info/distributed.html) do not specify Dataloaders but use datasets with params for the default dataloader.\r\n","closed_by":{"login":"stale[bot]","id":26384082,"node_id":"MDM6Qm90MjYzODQwODI=","avatar_url":"https://avatars.githubusercontent.com/in/1724?v=4","gravatar_id":"","url":"https://api.github.com/users/stale%5Bbot%5D","html_url":"https://github.com/apps/stale","followers_url":"https://api.github.com/users/stale%5Bbot%5D/followers","following_url":"https://api.github.com/users/stale%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/stale%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/stale%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/stale%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/stale%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/stale%5Bbot%5D/repos","events_url":"https://api.github.com/users/stale%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/stale%5Bbot%5D/received_events","type":"Bot","site_admin":false},"reactions":{"url":"https://api.github.com/repos/catalyst-team/catalyst/issues/913/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/catalyst-team/catalyst/issues/913/timeline","performed_via_github_app":null,"state_reason":"completed"}