{"url":"https://api.github.com/repos/theislab/diffxpy/issues/194","repository_url":"https://api.github.com/repos/theislab/diffxpy","labels_url":"https://api.github.com/repos/theislab/diffxpy/issues/194/labels{/name}","comments_url":"https://api.github.com/repos/theislab/diffxpy/issues/194/comments","events_url":"https://api.github.com/repos/theislab/diffxpy/issues/194/events","html_url":"https://github.com/theislab/diffxpy/issues/194","id":841153874,"node_id":"MDU6SXNzdWU4NDExNTM4NzQ=","number":194,"title":"All arrays must be instances of SparseArray","user":{"login":"ealsop","id":26933142,"node_id":"MDQ6VXNlcjI2OTMzMTQy","avatar_url":"https://avatars.githubusercontent.com/u/26933142?v=4","gravatar_id":"","url":"https://api.github.com/users/ealsop","html_url":"https://github.com/ealsop","followers_url":"https://api.github.com/users/ealsop/followers","following_url":"https://api.github.com/users/ealsop/following{/other_user}","gists_url":"https://api.github.com/users/ealsop/gists{/gist_id}","starred_url":"https://api.github.com/users/ealsop/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ealsop/subscriptions","organizations_url":"https://api.github.com/users/ealsop/orgs","repos_url":"https://api.github.com/users/ealsop/repos","events_url":"https://api.github.com/users/ealsop/events{/privacy}","received_events_url":"https://api.github.com/users/ealsop/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":6,"created_at":"2021-03-25T17:29:42Z","updated_at":"2021-05-31T13:18:54Z","closed_at":"2021-05-31T13:18:54Z","author_association":"NONE","active_lock_reason":null,"body":"Running de.test.wald using an un-normalized adata.X matrix with only 2 samples and ~5000 cells to test differential expression in scanpy. All libraries (numby, scanpy, diffxpy, sparse and dask) are updated the most recent versions.\r\n\r\ntest = de.test.wald(data=adata, formula_loc=\"~ 1 + Group\", factor_loc_totest=\"Group\")\r\n\r\nmake initally make this run at all I needed to include:\r\n\r\n%env SPARSE_AUTO_DENSIFY=1\r\n\r\nOr I would receive the error \"RuntimeError: Cannot convert a sparse array to dense automatically. To manually densify, use the todense method.\" mentioned in other issues.\r\n\r\nWith this solved I am now running through several iterations:\r\n\r\ntraining location model: False\r\ntraining scale model: True\r\niter   0: ll=74052044.544684\r\niter   1: ll=74052044.544684, converged: 0.00% (loc: 100.00%, scale update: False), in 0.00sec\r\niter   2: ll=53700205.003682, converged: 16.18% (loc: 16.18%, scale update: True), in 883.76sec\r\niter   3: ll=53700205.003682, converged: 16.18% (loc: 100.00%, scale update: False), in 0.01sec\r\niter   4: ll=53407203.078969, converged: 84.27% (loc: 84.27%, scale update: True), in 692.52sec\r\niter   5: ll=53407203.078969, converged: 84.27% (loc: 100.00%, scale update: False), in 0.00sec\r\niter   6: ll=53376103.605985, converged: 94.97% (loc: 94.97%, scale update: True), in 178.97sec\r\niter   7: ll=53376103.605985, converged: 94.97% (loc: 100.00%, scale update: False), in 0.00sec\r\nFitting 1842 dispersion models: (progress not available with multiprocessing)\r\n\r\nBut getting this error / trace back:\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-8-b4ac0989633a> in <module>\r\n----> 1 test = de.test.wald(data=adata, formula_loc=\"~ 1 + Group\", factor_loc_totest=\"Group\")\r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/diffxpy/testing/tests.py in wald(data, factor_loc_totest, coef_to_test, formula_loc, formula_scale, as_numeric, init_a, init_b, gene_names, sample_description, dmat_loc, dmat_scale, constraints_loc, constraints_scale, noise_model, size_factors, batch_size, backend, train_args, training_strategy, quick_scale, dtype, **kwargs)\r\n    719 \r\n    720     # Fit model.\r\n--> 721     model = _fit(\r\n    722         noise_model=noise_model,\r\n    723         data=data,\r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/diffxpy/testing/tests.py in _fit(noise_model, data, design_loc, design_scale, design_loc_names, design_scale_names, constraints_loc, constraints_scale, init_model, init_a, init_b, gene_names, size_factors, batch_size, backend, training_strategy, quick_scale, train_args, close_session, dtype)\r\n    242         pass\r\n    243 \r\n--> 244     estim.train_sequence(\r\n    245         training_strategy=training_strategy,\r\n    246         **train_args\r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/batchglm/models/base/estimator.py in train_sequence(self, training_strategy, **kwargs)\r\n    122                         (x, str(d[x]), str(kwargs[x]))\r\n    123                     )\r\n--> 124             self.train(**d, **kwargs)\r\n    125             logger.debug(\"Training sequence #%d complete\", idx + 1)\r\n    126 \r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/batchglm/train/numpy/base_glm/estimator.py in train(self, max_steps, method_b, update_b_freq, ftol_b, lr_b, max_iter_b, nproc, **kwargs)\r\n    115                     self.model.b_var = self.model.b_var + b_step\r\n    116                     # Reverse update by feature if update leads to worse loss:\r\n--> 117                     ll_proposal = - self.model.ll_byfeature_j(j=idx_update).compute()\r\n    118                     idx_bad_step = idx_update[np.where(ll_proposal > ll_current[idx_update])[0]]\r\n    119                     if isinstance(self.model.b_var, dask.array.core.Array):\r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/dask/base.py in compute(self, **kwargs)\r\n    281         dask.base.compute\r\n    282         \"\"\"\r\n--> 283         (result,) = compute(self, traverse=False, **kwargs)\r\n    284         return result\r\n    285 \r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/dask/base.py in compute(*args, **kwargs)\r\n    564 \r\n    565     results = schedule(dsk, keys, **kwargs)\r\n--> 566     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])\r\n    567 \r\n    568 \r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/dask/base.py in <listcomp>(.0)\r\n    564 \r\n    565     results = schedule(dsk, keys, **kwargs)\r\n--> 566     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])\r\n    567 \r\n    568 \r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/dask/array/core.py in finalize(results)\r\n   1081     while isinstance(results2, (tuple, list)):\r\n   1082         if len(results2) > 1:\r\n-> 1083             return concatenate3(results)\r\n   1084         else:\r\n   1085             results2 = results2[0]\r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/dask/array/core.py in concatenate3(arrays)\r\n   4747         try:\r\n   4748             x = unpack_singleton(arrays)\r\n-> 4749             return _concatenate2(arrays, axes=tuple(range(x.ndim)))\r\n   4750         except TypeError:\r\n   4751             pass\r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/dask/array/core.py in _concatenate2(arrays, axes)\r\n    348         type(max(arrays, key=lambda x: getattr(x, \"__array_priority__\", 0)))\r\n    349     )\r\n--> 350     return concatenate(arrays, axis=axes[0])\r\n    351 \r\n    352 \r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/sparse/_common.py in concatenate(arrays, axis, compressed_axes)\r\n   1253         from ._coo import concatenate as coo_concat\r\n   1254 \r\n-> 1255         return coo_concat(arrays, axis)\r\n   1256     else:\r\n   1257         from ._compressed import concatenate as gcxs_concat\r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/sparse/_coo/common.py in concatenate(arrays, axis)\r\n    159     from .core import COO\r\n    160 \r\n--> 161     check_consistent_fill_value(arrays)\r\n    162 \r\n    163     arrays = [x if isinstance(x, COO) else COO(x) for x in arrays]\r\n\r\n~/anaconda3/envs/scanpy/lib/python3.8/site-packages/sparse/_utils.py in check_consistent_fill_value(arrays)\r\n    468 \r\n    469     if not all(isinstance(s, SparseArray) for s in arrays):\r\n--> 470         raise ValueError(\"All arrays must be instances of SparseArray.\")\r\n    471     if len(arrays) == 0:\r\n    472         raise ValueError(\"At least one array required.\")\r\n\r\nValueError: All arrays must be instances of SparseArray.\r\n\r\n","closed_by":{"login":"davidsebfischer","id":11200205,"node_id":"MDQ6VXNlcjExMjAwMjA1","avatar_url":"https://avatars.githubusercontent.com/u/11200205?v=4","gravatar_id":"","url":"https://api.github.com/users/davidsebfischer","html_url":"https://github.com/davidsebfischer","followers_url":"https://api.github.com/users/davidsebfischer/followers","following_url":"https://api.github.com/users/davidsebfischer/following{/other_user}","gists_url":"https://api.github.com/users/davidsebfischer/gists{/gist_id}","starred_url":"https://api.github.com/users/davidsebfischer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/davidsebfischer/subscriptions","organizations_url":"https://api.github.com/users/davidsebfischer/orgs","repos_url":"https://api.github.com/users/davidsebfischer/repos","events_url":"https://api.github.com/users/davidsebfischer/events{/privacy}","received_events_url":"https://api.github.com/users/davidsebfischer/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/theislab/diffxpy/issues/194/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/theislab/diffxpy/issues/194/timeline","performed_via_github_app":null,"state_reason":"completed"}