{"url":"https://api.github.com/repos/theislab/diffxpy/issues/201","repository_url":"https://api.github.com/repos/theislab/diffxpy","labels_url":"https://api.github.com/repos/theislab/diffxpy/issues/201/labels{/name}","comments_url":"https://api.github.com/repos/theislab/diffxpy/issues/201/comments","events_url":"https://api.github.com/repos/theislab/diffxpy/issues/201/events","html_url":"https://github.com/theislab/diffxpy/issues/201","id":908214140,"node_id":"MDU6SXNzdWU5MDgyMTQxNDA=","number":201,"title":"ValueError: array must not contain infs or NaNs","user":{"login":"Zethson","id":21954664,"node_id":"MDQ6VXNlcjIxOTU0NjY0","avatar_url":"https://avatars.githubusercontent.com/u/21954664?v=4","gravatar_id":"","url":"https://api.github.com/users/Zethson","html_url":"https://github.com/Zethson","followers_url":"https://api.github.com/users/Zethson/followers","following_url":"https://api.github.com/users/Zethson/following{/other_user}","gists_url":"https://api.github.com/users/Zethson/gists{/gist_id}","starred_url":"https://api.github.com/users/Zethson/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Zethson/subscriptions","organizations_url":"https://api.github.com/users/Zethson/orgs","repos_url":"https://api.github.com/users/Zethson/repos","events_url":"https://api.github.com/users/Zethson/events{/privacy}","received_events_url":"https://api.github.com/users/Zethson/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-06-01T11:56:19Z","updated_at":"2021-06-01T12:23:46Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"Hey,\r\n\r\n```\r\nimport diffxpy.api as de\r\n\r\nde_w_test = de.test.wald(\r\n    data=leukocytes_only_raw.X,\r\n    formula_loc=\"~ 1 + condition\",\r\n    factor_loc_totest=\"condition\",\r\n    gene_names=leukocytes_only_raw.var_names,\r\n    sample_description=leukocytes_only_raw.obs,\r\n)\r\n```\r\n\r\nresults in\r\n\r\n```\r\n╭──────────────────────────── Traceback (most recent call last) ────────────────────────────╮\r\n│ <ipython-input-75-467c1e316174>:3 in <module>                                             │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/diffxpy/test │\r\n│ ing/tests.py:717 in wald                                                                  │\r\n│                                                                                           │\r\n│    714 │   col_indices = np.array([np.where(constraints_loc_temp[x, :] == 1)[0][0] for x  │\r\n│    715 │                                                                                  │\r\n│    716 │   # Fit model.                                                                   │\r\n│ ❱  717 │   model = _fit(                                                                  │\r\n│    718 │   │   noise_model=noise_model,                                                   │\r\n│    719 │   │   data=data,                                                                 │\r\n│    720 │   │   design_loc=design_loc,                                                     │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/diffxpy/test │\r\n│ ing/tests.py:222 in _fit                                                                  │\r\n│                                                                                           │\r\n│    219 │   else:                                                                          │\r\n│    220 │   │   raise ValueError('backend=\"%s\" not recognized.' % backend)                 │\r\n│    221 │                                                                                  │\r\n│ ❱  222 │   estim = Estimator(                                                             │\r\n│    223 │   │   input_data=input_data,                                                     │\r\n│    224 │   │   init_a=init_a,                                                             │\r\n│    225 │   │   init_b=init_b,                                                             │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/batchglm/tra │\r\n│ in/numpy/glm_nb/estimator.py:59 in __init__                                               │\r\n│                                                                                           │\r\n│    56 │   │   │   Useful in scenarios where fitting the exact `scale` is not absolutely n │\r\n│    57 │   │   :param dtype: Numerical precision.                                          │\r\n│    58 │   │   \"\"\"                                                                         │\r\n│ ❱  59 │   │   init_a, init_b, train_loc, train_scale = init_par(                          │\r\n│    60 │   │   │   input_data=input_data,                                                  │\r\n│    61 │   │   │   init_a=init_a,                                                          │\r\n│    62 │   │   │   init_b=init_b,                                                          │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/batchglm/mod │\r\n│ els/glm_nb/utils.py:129 in init_par                                                       │\r\n│                                                                                           │\r\n│   126 │   │   │   │   )                                                                   │\r\n│   127 │   │   │   │                                                                       │\r\n│   128 │   │   │   │   # train mu, if the closed-form solution is inaccurate               │\r\n│ ❱ 129 │   │   │   │   train_loc = not (np.all(np.abs(rmsd_a) < 1e-20) or rmsd_a.size == 0 │\r\n│   130 │   │   │   │                                                                       │\r\n│   131 │   │   │   │   if input_data.size_factors is not None:                             │\r\n│   132 │   │   │   │   │   if np.any(input_data.size_factors != 1):                        │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/dask/array/c │\r\n│ ore.py:1622 in __bool__                                                                   │\r\n│                                                                                           │\r\n│   1619 │   │   │   │   \"Use a.any() or a.all().\".format(self.__class__.__name__)          │\r\n│   1620 │   │   │   )                                                                      │\r\n│   1621 │   │   else:                                                                      │\r\n│ ❱ 1622 │   │   │   return bool(self.compute())                                            │\r\n│   1623 │                                                                                  │\r\n│   1624 │   __nonzero__ = __bool__  # python 2                                             │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/dask/base.py │\r\n│ :283 in compute                                                                           │\r\n│                                                                                           │\r\n│    280 │   │   --------                                                                   │\r\n│    281 │   │   dask.base.compute                                                          │\r\n│    282 │   │   \"\"\"                                                                        │\r\n│ ❱  283 │   │   (result,) = compute(self, traverse=False, **kwargs)                        │\r\n│    284 │   │   return result                                                              │\r\n│    285 │                                                                                  │\r\n│    286 │   def __await__(self):                                                           │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/dask/base.py │\r\n│ :565 in compute                                                                           │\r\n│                                                                                           │\r\n│    562 │   │   keys.append(x.__dask_keys__())                                             │\r\n│    563 │   │   postcomputes.append(x.__dask_postcompute__())                              │\r\n│    564 │                                                                                  │\r\n│ ❱  565 │   results = schedule(dsk, keys, **kwargs)                                        │\r\n│    566 │   return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])          │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/dask/threade │\r\n│ d.py:76 in get                                                                            │\r\n│                                                                                           │\r\n│   73 │   │   │   │   atexit.register(pool.close)                                          │\r\n│   74 │   │   │   │   pools[thread][num_workers] = pool                                    │\r\n│   75 │                                                                                    │\r\n│ ❱ 76 │   results = get_async(                                                             │\r\n│   77 │   │   pool.apply_async,                                                            │\r\n│   78 │   │   len(pool._pool),                                                             │\r\n│   79 │   │   dsk,                                                                         │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/dask/local.p │\r\n│ y:487 in get_async                                                                        │\r\n│                                                                                           │\r\n│   484 │   │   │   │   │   │   task = dsk[key]                                             │\r\n│   485 │   │   │   │   │   │   _execute_task(task, data)  # Re-execute locally             │\r\n│   486 │   │   │   │   │   else:                                                           │\r\n│ ❱ 487 │   │   │   │   │   │   raise_exception(exc, tb)                                    │\r\n│   488 │   │   │   │   res, worker_id = loads(res_info)                                    │\r\n│   489 │   │   │   │   state[\"cache\"][key] = res                                           │\r\n│   490 │   │   │   │   finish_task(dsk, key, state, results, keyorder.get)                 │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/dask/local.p │\r\n│ y:317 in reraise                                                                          │\r\n│                                                                                           │\r\n│   314 def reraise(exc, tb=None):                                                          │\r\n│   315 │   if exc.__traceback__ is not tb:                                                 │\r\n│   316 │   │   raise exc.with_traceback(tb)                                                │\r\n│ ❱ 317 │   raise exc                                                                       │\r\n│   318                                                                                     │\r\n│   319                                                                                     │\r\n│   320 def identity(x):                                                                    │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/dask/local.p │\r\n│ y:222 in execute_task                                                                     │\r\n│                                                                                           │\r\n│   219 │   \"\"\"                                                                             │\r\n│   220 │   try:                                                                            │\r\n│   221 │   │   task, data = loads(task_info)                                               │\r\n│ ❱ 222 │   │   result = _execute_task(task, data)                                          │\r\n│   223 │   │   id = get_id()                                                               │\r\n│   224 │   │   result = dumps((result, id))                                                │\r\n│   225 │   │   failed = False                                                              │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/dask/core.py │\r\n│ :121 in _execute_task                                                                     │\r\n│                                                                                           │\r\n│   118 │   │   # Note: Don't assign the subtask results to a variable. numpy detects       │\r\n│   119 │   │   # temporaries by their reference count and can execute certain              │\r\n│   120 │   │   # operations in-place.                                                      │\r\n│ ❱ 121 │   │   return func(*(_execute_task(a, cache) for a in args))                       │\r\n│   122 │   elif not ishashable(arg):                                                       │\r\n│   123 │   │   return arg                                                                  │\r\n│   124 │   elif arg in cache:                                                              │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/scipy/linalg │\r\n│ /basic.py:334 in solve_triangular                                                         │\r\n│                                                                                           │\r\n│    331 │   │   │    'versions of SciPy.', DeprecationWarning, stacklevel=2)               │\r\n│    332 │                                                                                  │\r\n│    333 │   a1 = _asarray_validated(a, check_finite=check_finite)                          │\r\n│ ❱  334 │   b1 = _asarray_validated(b, check_finite=check_finite)                          │\r\n│    335 │   if len(a1.shape) != 2 or a1.shape[0] != a1.shape[1]:                           │\r\n│    336 │   │   raise ValueError('expected square matrix')                                 │\r\n│    337 │   if a1.shape[0] != b1.shape[0]:                                                 │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/scipy/_lib/_ │\r\n│ util.py:262 in _asarray_validated                                                         │\r\n│                                                                                           │\r\n│   259 │   │   if np.ma.isMaskedArray(a):                                                  │\r\n│   260 │   │   │   raise ValueError('masked arrays are not supported')                     │\r\n│   261 │   toarray = np.asarray_chkfinite if check_finite else np.asarray                  │\r\n│ ❱ 262 │   a = toarray(a)                                                                  │\r\n│   263 │   if not objects_ok:                                                              │\r\n│   264 │   │   if a.dtype is np.dtype('O'):                                                │\r\n│   265 │   │   │   raise ValueError('object arrays are not supported')                     │\r\n│                                                                                           │\r\n│ /home/lukas/miniconda3/envs/single_cell_analysis/lib/python3.8/site-packages/numpy/lib/fu │\r\n│ nction_base.py:485 in asarray_chkfinite                                                   │\r\n│                                                                                           │\r\n│    482 │   \"\"\"                                                                            │\r\n│    483 │   a = asarray(a, dtype=dtype, order=order)                                       │\r\n│    484 │   if a.dtype.char in typecodes['AllFloat'] and not np.isfinite(a).all():         │\r\n│ ❱  485 │   │   raise ValueError(                                                          │\r\n│    486 │   │   │   \"array must not contain infs or NaNs\")                                 │\r\n│    487 │   return a                                                                       │\r\n╰───────────────────────────────────────────────────────────────────────────────────────────╯\r\nValueError: array must not contain infs or NaNs\r\n```\r\n\r\nI already checked that leukocytes_raw.X does not contain any infs or nans.\r\n\r\nGot any idea?","closed_by":null,"reactions":{"url":"https://api.github.com/repos/theislab/diffxpy/issues/201/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/theislab/diffxpy/issues/201/timeline","performed_via_github_app":null,"state_reason":null}