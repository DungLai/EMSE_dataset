{"url":"https://api.github.com/repos/theislab/diffxpy/issues/145","repository_url":"https://api.github.com/repos/theislab/diffxpy","labels_url":"https://api.github.com/repos/theislab/diffxpy/issues/145/labels{/name}","comments_url":"https://api.github.com/repos/theislab/diffxpy/issues/145/comments","events_url":"https://api.github.com/repos/theislab/diffxpy/issues/145/events","html_url":"https://github.com/theislab/diffxpy/issues/145","id":574912167,"node_id":"MDU6SXNzdWU1NzQ5MTIxNjc=","number":145,"title":"Cannot handle sparse matrices","user":{"login":"LuckyMD","id":13019956,"node_id":"MDQ6VXNlcjEzMDE5OTU2","avatar_url":"https://avatars.githubusercontent.com/u/13019956?v=4","gravatar_id":"","url":"https://api.github.com/users/LuckyMD","html_url":"https://github.com/LuckyMD","followers_url":"https://api.github.com/users/LuckyMD/followers","following_url":"https://api.github.com/users/LuckyMD/following{/other_user}","gists_url":"https://api.github.com/users/LuckyMD/gists{/gist_id}","starred_url":"https://api.github.com/users/LuckyMD/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LuckyMD/subscriptions","organizations_url":"https://api.github.com/users/LuckyMD/orgs","repos_url":"https://api.github.com/users/LuckyMD/repos","events_url":"https://api.github.com/users/LuckyMD/events{/privacy}","received_events_url":"https://api.github.com/users/LuckyMD/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2020-03-03T20:11:07Z","updated_at":"2022-05-24T07:10:14Z","closed_at":"2020-03-04T10:53:59Z","author_association":"NONE","active_lock_reason":null,"body":"Hey! i'm running a simple model with `de.tests.wald()` and get the following issue with sparse input matrices\r\n\r\nThis is on Diffxpy 0.7.3 and batchglm 0.7.3, with sparse 0.9.1 and dask 1.1.0.\r\n\r\nThe call is:\r\n\r\n```\r\n    sex_test_tmp = de.test.wald(\r\n        data=adata_tmp.X,\r\n        formula_loc=\"~ 1 + sex + dataset + total_counts\",\r\n        as_numeric=['total_counts'],\r\n        factor_loc_totest=[\"sex\"],\r\n        sample_description=adata_tmp.obs,\r\n        gene_names=adata_tmp.var_names,\r\n        noise_model='nb',\r\n        dtype=\"float64\"\r\n    )\r\n```\r\n\r\nAnd the error:\r\n\r\n```pytb\r\n---------------------------------------------------------------------------\r\nRuntimeError                              Traceback (most recent call last)\r\n<ipython-input-16-e09783913589> in <module>\r\n     41         gene_names=adata_tmp.var_names,\r\n     42         noise_model='nb',\r\n---> 43         dtype=\"float64\"\r\n     44     )\r\n     45 \r\n\r\n~/.local/lib/python3.6/site-packages/diffxpy/testing/tests.py in wald(data, factor_loc_totest, coef_to_test, formula_loc, formula_scale, as_numeric, init_a, init_b, gene_names, sample_description, dmat_loc, dmat_scale, constraints_loc, constraints_scale, noise_model, size_factors, batch_size, backend, train_args, training_strategy, quick_scale, dtype, **kwargs)\r\n    734         quick_scale=quick_scale,\r\n    735         dtype=dtype,\r\n--> 736         **kwargs,\r\n    737     )\r\n    738 \r\n\r\n~/.local/lib/python3.6/site-packages/diffxpy/testing/tests.py in _fit(noise_model, data, design_loc, design_scale, design_loc_names, design_scale_names, constraints_loc, constraints_scale, init_model, init_a, init_b, gene_names, size_factors, batch_size, backend, training_strategy, quick_scale, train_args, close_session, dtype)\r\n    225         init_b=init_b,\r\n    226         dtype=dtype,\r\n--> 227         **constructor_args\r\n    228     )\r\n    229     estim.initialize()\r\n\r\n~/.local/lib/python3.6/site-packages/batchglm/train/numpy/glm_nb/estimator.py in __init__(self, input_data, init_a, init_b, batch_size, quick_scale, dtype, **kwargs)\r\n     65             init_a=init_a,\r\n     66             init_b=init_b,\r\n---> 67             init_model=None\r\n     68         )\r\n     69         init_a = init_a.astype(dtype)\r\n\r\n~/.local/lib/python3.6/site-packages/batchglm/train/numpy/glm_nb/estimator.py in init_par(self, input_data, init_a, init_b, init_model)\r\n    153 \r\n    154                     init_a = np.zeros([input_data.num_loc_params, input_data.num_features])\r\n--> 155                     init_a[0, :] = np.log(overall_means)\r\n    156                     self._train_loc = True\r\n    157 \r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/array/core.py in __array__(self, dtype, **kwargs)\r\n   1026 \r\n   1027     def __array__(self, dtype=None, **kwargs):\r\n-> 1028         x = self.compute()\r\n   1029         if dtype and x.dtype != dtype:\r\n   1030             x = x.astype(dtype)\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/base.py in compute(self, **kwargs)\r\n    154         dask.base.compute\r\n    155         \"\"\"\r\n--> 156         (result,) = compute(self, traverse=False, **kwargs)\r\n    157         return result\r\n    158 \r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/base.py in compute(*args, **kwargs)\r\n    396     keys = [x.__dask_keys__() for x in collections]\r\n    397     postcomputes = [x.__dask_postcompute__() for x in collections]\r\n--> 398     results = schedule(dsk, keys, **kwargs)\r\n    399     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])\r\n    400 \r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)\r\n     74     results = get_async(pool.apply_async, len(pool._pool), dsk, result,\r\n     75                         cache=cache, get_id=_thread_get_id,\r\n---> 76                         pack_exception=pack_exception, **kwargs)\r\n     77 \r\n     78     # Cleanup pools associated to dead threads\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)\r\n    457                         _execute_task(task, data)  # Re-execute locally\r\n    458                     else:\r\n--> 459                         raise_exception(exc, tb)\r\n    460                 res, worker_id = loads(res_info)\r\n    461                 state['cache'][key] = res\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/compatibility.py in reraise(exc, tb)\r\n    110         if exc.__traceback__ is not tb:\r\n    111             raise exc.with_traceback(tb)\r\n--> 112         raise exc\r\n    113 \r\n    114     import pickle as cPickle\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)\r\n    228     try:\r\n    229         task, data = loads(task_info)\r\n--> 230         result = _execute_task(task, data)\r\n    231         id = get_id()\r\n    232         result = dumps((result, id))\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/core.py in _execute_task(arg, cache, dsk)\r\n    116     elif istask(arg):\r\n    117         func, args = arg[0], arg[1:]\r\n--> 118         args2 = [_execute_task(a, cache) for a in args]\r\n    119         return func(*args2)\r\n    120     elif not ishashable(arg):\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/core.py in <listcomp>(.0)\r\n    116     elif istask(arg):\r\n    117         func, args = arg[0], arg[1:]\r\n--> 118         args2 = [_execute_task(a, cache) for a in args]\r\n    119         return func(*args2)\r\n    120     elif not ishashable(arg):\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/core.py in _execute_task(arg, cache, dsk)\r\n    116     elif istask(arg):\r\n    117         func, args = arg[0], arg[1:]\r\n--> 118         args2 = [_execute_task(a, cache) for a in args]\r\n    119         return func(*args2)\r\n    120     elif not ishashable(arg):\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/core.py in <listcomp>(.0)\r\n    116     elif istask(arg):\r\n    117         func, args = arg[0], arg[1:]\r\n--> 118         args2 = [_execute_task(a, cache) for a in args]\r\n    119         return func(*args2)\r\n    120     elif not ishashable(arg):\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/core.py in _execute_task(arg, cache, dsk)\r\n    117         func, args = arg[0], arg[1:]\r\n    118         args2 = [_execute_task(a, cache) for a in args]\r\n--> 119         return func(*args2)\r\n    120     elif not ishashable(arg):\r\n    121         return arg\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/optimization.py in __call__(self, *args)\r\n    940                              % (len(self.inkeys), len(args)))\r\n    941         return core.get(self.dsk, self.outkey,\r\n--> 942                         dict(zip(self.inkeys, args)))\r\n    943 \r\n    944     def __reduce__(self):\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/core.py in get(dsk, out, cache)\r\n    147     for key in toposort(dsk):\r\n    148         task = dsk[key]\r\n--> 149         result = _execute_task(task, cache)\r\n    150         cache[key] = result\r\n    151     result = _execute_task(out, cache)\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/core.py in _execute_task(arg, cache, dsk)\r\n    117         func, args = arg[0], arg[1:]\r\n    118         args2 = [_execute_task(a, cache) for a in args]\r\n--> 119         return func(*args2)\r\n    120     elif not ishashable(arg):\r\n    121         return arg\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/compatibility.py in apply(func, args, kwargs)\r\n     91     def apply(func, args, kwargs=None):\r\n     92         if kwargs:\r\n---> 93             return func(*args, **kwargs)\r\n     94         else:\r\n     95             return func(*args)\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/array/reductions.py in mean_chunk(x, sum, numel, dtype, **kwargs)\r\n    330 \r\n    331 def mean_chunk(x, sum=chunk.sum, numel=numel, dtype='f8', **kwargs):\r\n--> 332     n = numel(x, dtype=dtype, **kwargs)\r\n    333     total = sum(x, dtype=dtype, **kwargs)\r\n    334     empty = empty_lookup.dispatch(type(n))\r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/dask/array/reductions.py in numel(x, **kwargs)\r\n    321 def numel(x, **kwargs):\r\n    322     \"\"\" A reduction to count the number of elements \"\"\"\r\n--> 323     return chunk.sum(np.ones_like(x), **kwargs)\r\n    324 \r\n    325 \r\n\r\n~/anaconda3/envs/cov19/lib/python3.6/site-packages/numpy/core/numeric.py in ones_like(a, dtype, order, subok)\r\n    286 \r\n    287     \"\"\"\r\n--> 288     res = empty_like(a, dtype=dtype, order=order, subok=subok)\r\n    289     multiarray.copyto(res, 1, casting='unsafe')\r\n    290     return res\r\n\r\n~/.local/lib/python3.6/site-packages/sparse/_sparse_array.py in __array__(self, **kwargs)\r\n    221         if not AUTO_DENSIFY:\r\n    222             raise RuntimeError(\r\n--> 223                 \"Cannot convert a sparse array to dense automatically. \"\r\n    224                 \"To manually densify, use the todense method.\"\r\n    225             )\r\n\r\nRuntimeError: Cannot convert a sparse array to dense automatically. To manually densify, use the todense method.\r\n```","closed_by":{"login":"davidsebfischer","id":11200205,"node_id":"MDQ6VXNlcjExMjAwMjA1","avatar_url":"https://avatars.githubusercontent.com/u/11200205?v=4","gravatar_id":"","url":"https://api.github.com/users/davidsebfischer","html_url":"https://github.com/davidsebfischer","followers_url":"https://api.github.com/users/davidsebfischer/followers","following_url":"https://api.github.com/users/davidsebfischer/following{/other_user}","gists_url":"https://api.github.com/users/davidsebfischer/gists{/gist_id}","starred_url":"https://api.github.com/users/davidsebfischer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/davidsebfischer/subscriptions","organizations_url":"https://api.github.com/users/davidsebfischer/orgs","repos_url":"https://api.github.com/users/davidsebfischer/repos","events_url":"https://api.github.com/users/davidsebfischer/events{/privacy}","received_events_url":"https://api.github.com/users/davidsebfischer/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/theislab/diffxpy/issues/145/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/theislab/diffxpy/issues/145/timeline","performed_via_github_app":null,"state_reason":"completed"}