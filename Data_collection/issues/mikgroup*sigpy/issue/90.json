{"url":"https://api.github.com/repos/mikgroup/sigpy/issues/90","repository_url":"https://api.github.com/repos/mikgroup/sigpy","labels_url":"https://api.github.com/repos/mikgroup/sigpy/issues/90/labels{/name}","comments_url":"https://api.github.com/repos/mikgroup/sigpy/issues/90/comments","events_url":"https://api.github.com/repos/mikgroup/sigpy/issues/90/events","html_url":"https://github.com/mikgroup/sigpy/issues/90","id":936519041,"node_id":"MDU6SXNzdWU5MzY1MTkwNDE=","number":90,"title":"Implementing PSF for faster evaluation of NUFFT normal operator.","user":{"login":"sidward","id":7364812,"node_id":"MDQ6VXNlcjczNjQ4MTI=","avatar_url":"https://avatars.githubusercontent.com/u/7364812?v=4","gravatar_id":"","url":"https://api.github.com/users/sidward","html_url":"https://github.com/sidward","followers_url":"https://api.github.com/users/sidward/followers","following_url":"https://api.github.com/users/sidward/following{/other_user}","gists_url":"https://api.github.com/users/sidward/gists{/gist_id}","starred_url":"https://api.github.com/users/sidward/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sidward/subscriptions","organizations_url":"https://api.github.com/users/sidward/orgs","repos_url":"https://api.github.com/users/sidward/repos","events_url":"https://api.github.com/users/sidward/events{/privacy}","received_events_url":"https://api.github.com/users/sidward/received_events","type":"User","site_admin":false},"labels":[{"id":983094943,"node_id":"MDU6TGFiZWw5ODMwOTQ5NDM=","url":"https://api.github.com/repos/mikgroup/sigpy/labels/enhancement","name":"enhancement","color":"a2eeef","default":true,"description":"New feature or request"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-07-04T18:57:21Z","updated_at":"2021-08-18T23:35:02Z","closed_at":"2021-08-18T23:35:01Z","author_association":"COLLABORATOR","active_lock_reason":null,"body":"**Is your feature request related to a problem? Please describe.**\r\nA normal operator for the NUFFT linear operator in conjunction with Pull Request #86 should help in increasing reconstruction speed for cases where the NUFFT psf fits in memory.\r\n\r\n**Describe the solution you'd like**\r\nAn NUFFT normal operator akin to BART.\r\n\r\n**Additional context**\r\nI talked with @frankong and we decided it'll be best to have this discussion on here to have it track-able.\r\n\r\n**What I've tried so far**\r\n\r\n- Let F be the NUFFT linear operator with input dimension \"n\". We are working in 1D for simplicity.\r\n- From what I understand, the normal operator N = FH * F is linear and time invariant, and hence can be effectively modeled by a convolution. \r\n- Let d be a delta and p = FH * F * d be the impulse response/ point spread function/ convolution kernel. This has support equal to \"n\".\r\n- In order to model the _linear_ convolution with FFTs, we have to zero-pad the input to \"2n\". Let R denote the (center) zero-padding from \"n\" to \"2n\".\r\n- Let P = FFT(R(p)). Then, in principle, the following should hold: F^H * F = R.H * FFT.H * P * FFT * R.\r\n- However, in practice, I get higher than expected errors.\r\n\r\n**1D Example**\r\n\r\nThis gives me an error of ~13%.\r\n\r\n```python\r\nimport sigpy as sp\r\nimport sigpy.plot as pl\r\nimport sigpy.mri as mr\r\n\r\nn      = 256\r\ndevnum = 1\r\nzpad   = 2\r\n\r\ndevice = sp.Device(devnum)\r\nxp = device.xp\r\n\r\n# Linear operators\r\ncoords = mr.spiral(n * 1E-3, n, 2, 2, 32, 1.5, 0.27, 1.8)[:, 0, None]\r\nnF = sp.linop.NUFFT((n,), coords) # Non-uniform\r\nuF = sp.linop.FFT([int(k * zpad) for k in nF.ishape]) # Uniform\r\nR  = sp.linop.Resize(uF.ishape, nF.ishape)\r\n\r\nwith device:\r\n\r\n    # Calculating PSF\r\n    d = xp.zeros((nF.ishape), dtype=xp.complex64)\r\n    d[d.shape[0]//2] = 1\r\n    h = nF.H * nF * d\r\n    \r\n    # Creating Toeplitz operator\r\n    psf = xp.zeros([int(k * zpad) for k in d.shape], xp.complex64)\r\n    psf[(psf.shape[0] - d.shape[0])//2 : (psf.shape[0] - d.shape[0])//2 + d.shape[0]] = h\r\n    PSF = uF(psf)\r\n    T = R.H * uF.H * sp.linop.Multiply(uF.oshape, PSF) * uF * R \r\n    \r\n    # Testing\r\n    nrmse = lambda x, y: 100 * xp.linalg.norm(x/xp.linalg.norm(x) - y/xp.linalg.norm(y))\r\n    vec = xp.random.standard_normal(T.ishape) + 1j * xp.random.standard_normal(T.ishape)\r\n    print(\"Random test: %0.2f%%\" % nrmse(nF.H * nF * vec, T * vec))\r\n    print(\"Delta test:  %0.2f%%\" % nrmse(h, T(d)))\r\n```\r\n\r\n**2D Example**\r\n\r\nThis gives me an error of ~70%.\r\n\r\n```python\r\nimport sigpy as sp\r\nimport sigpy.plot as pl\r\nimport sigpy.mri as mr\r\n\r\nn = 256\r\ndevnum = 1\r\nzpad = 2\r\n\r\ndevice = sp.Device(devnum)\r\nxp = device.xp\r\n\r\n# Linear operators\r\ncoords = mr.spiral(n * 1E-3, n, 2, 2, 32, 1.5, 0.27, 1.8)\r\nnF = sp.linop.NUFFT((n, n), coords) # Non-uniform\r\nuF = sp.linop.FFT([int(k * zpad) for k in nF.ishape], axes=(0, 1)) # Uniform\r\nR  = sp.linop.Resize(uF.ishape, nF.ishape)\r\n\r\nwith device:\r\n\r\n    # Calculating PSF\r\n    d = xp.zeros((nF.ishape), dtype=xp.complex64)\r\n    d[d.shape[0]//2, d.shape[1]//2] = 1\r\n    h = nF.H * nF * d\r\n    \r\n    # Creating Toeplitz operator\r\n    psf = xp.zeros([int(k * zpad) for k in d.shape], xp.complex64)\r\n    psf[(psf.shape[0] - d.shape[0])//2 : (psf.shape[0] - d.shape[0])//2 + d.shape[0],\r\n        (psf.shape[1] - d.shape[1])//2 : (psf.shape[1] - d.shape[1])//2 + d.shape[1]] = h\r\n    PSF = uF(psf)\r\n    T = R.H * uF.H * sp.linop.Multiply(uF.oshape, PSF) * uF * R \r\n    \r\n    # Testing\r\n    nrmse = lambda x, y: 100 * xp.linalg.norm(x/xp.linalg.norm(x) - y/xp.linalg.norm(y))\r\n    vec = xp.random.standard_normal(T.ishape) + 1j * xp.random.standard_normal(T.ishape)\r\n    print(\"Random test: %0.2f%%\" % nrmse(nF.H * nF * vec, T * vec))\r\n    print(\"Delta test:  %0.2f%%\" % nrmse(h, T(d)))\r\n```\r\n","closed_by":{"login":"sidward","id":7364812,"node_id":"MDQ6VXNlcjczNjQ4MTI=","avatar_url":"https://avatars.githubusercontent.com/u/7364812?v=4","gravatar_id":"","url":"https://api.github.com/users/sidward","html_url":"https://github.com/sidward","followers_url":"https://api.github.com/users/sidward/followers","following_url":"https://api.github.com/users/sidward/following{/other_user}","gists_url":"https://api.github.com/users/sidward/gists{/gist_id}","starred_url":"https://api.github.com/users/sidward/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sidward/subscriptions","organizations_url":"https://api.github.com/users/sidward/orgs","repos_url":"https://api.github.com/users/sidward/repos","events_url":"https://api.github.com/users/sidward/events{/privacy}","received_events_url":"https://api.github.com/users/sidward/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/mikgroup/sigpy/issues/90/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/mikgroup/sigpy/issues/90/timeline","performed_via_github_app":null,"state_reason":"completed"}