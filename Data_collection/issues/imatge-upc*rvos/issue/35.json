{"url":"https://api.github.com/repos/imatge-upc/rvos/issues/35","repository_url":"https://api.github.com/repos/imatge-upc/rvos","labels_url":"https://api.github.com/repos/imatge-upc/rvos/issues/35/labels{/name}","comments_url":"https://api.github.com/repos/imatge-upc/rvos/issues/35/comments","events_url":"https://api.github.com/repos/imatge-upc/rvos/issues/35/events","html_url":"https://github.com/imatge-upc/rvos/issues/35","id":675711778,"node_id":"MDU6SXNzdWU2NzU3MTE3Nzg=","number":35,"title":"hi, why the decoder need to loop T times","user":{"login":"DeveloperZWK","id":17663406,"node_id":"MDQ6VXNlcjE3NjYzNDA2","avatar_url":"https://avatars.githubusercontent.com/u/17663406?v=4","gravatar_id":"","url":"https://api.github.com/users/DeveloperZWK","html_url":"https://github.com/DeveloperZWK","followers_url":"https://api.github.com/users/DeveloperZWK/followers","following_url":"https://api.github.com/users/DeveloperZWK/following{/other_user}","gists_url":"https://api.github.com/users/DeveloperZWK/gists{/gist_id}","starred_url":"https://api.github.com/users/DeveloperZWK/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DeveloperZWK/subscriptions","organizations_url":"https://api.github.com/users/DeveloperZWK/orgs","repos_url":"https://api.github.com/users/DeveloperZWK/repos","events_url":"https://api.github.com/users/DeveloperZWK/events{/privacy}","received_events_url":"https://api.github.com/users/DeveloperZWK/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-08-09T14:42:34Z","updated_at":"2020-08-09T14:42:34Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"@carlesventura   \r\nExcuse me, could you tell me why the decoder need to loop T times?\r\n================================\r\nfor t in range(0, T):\r\n        #prev_hidden_temporal_list is a list with the hidden state for all instances from previous time instant\r\n        #If this is the first frame of the sequence, hidden_temporal is initialized to None. Otherwise, it is set with the value from previous time instant.\r\n        if prev_hidden_temporal_list is not None:\r\n            hidden_temporal = prev_hidden_temporal_list[t]\r\n            if args.only_temporal:\r\n                hidden_spatial = None\r\n        else:\r\n            hidden_temporal = None\r\n            \r\n        #The decoder receives two hidden state variables: hidden_spatial (a tuple, with hidden_state and cell_state) which refers to the\r\n        #hidden state from the previous object instance from the same time instant, and hidden_temporal which refers to the hidden state from the same\r\n        #object instance from the previous time instant.\r\n        out_mask, hidden = decoder(feats, hidden_spatial, hidden_temporal)\r\n        hidden_tmp = []\r\n        for ss in range(len(hidden)):\r\n            if mode == 'train':\r\n                hidden_tmp.append(hidden[ss][0])\r\n            else:\r\n                hidden_tmp.append(hidden[ss][0].data)\r\n        hidden_spatial = hidden\r\n        hidden_temporal_list.append(hidden_tmp)\r\n\r\n        upsample_match = nn.UpsamplingBilinear2d(size=(x.size()[-2], x.size()[-1]))\r\n        out_mask = upsample_match(out_mask) # batch_size * 1 * height * width\r\n        out_mask = out_mask.view(out_mask.size(0), -1) # batch_size * height x width\r\n        \r\n        # repeat predicted mask as many times as elements in ground truth.\r\n        # to compute iou against all ground truth elements at once\r\n        y_pred_i = out_mask.unsqueeze(0) # out_mask: batch_size * height x width -> 1 * batch_size * height x width\r\n        y_pred_i = y_pred_i.permute(1,0,2) # 1 * batch_size * height * width -> batch_size * 1 * height x width\r\n        y_pred_i = y_pred_i.repeat(1,y_mask.size(1),1) \r\n        y_pred_i = y_pred_i.view(y_mask.size(0)*y_mask.size(1),y_mask.size(2))# torch.Size([10, 10, 114688]) -> torch.Size([100, 114688])\r\n        y_true_p = y_mask.view(y_mask.size(0)*y_mask.size(1),y_mask.size(2))# torch.Size([100, 114688])\r\n\r\n        c = args.iou_weight * softIoU(y_true_p, y_pred_i)\r\n        c = c.view(sw_mask.size(0),-1)\r\n        scores[:,:,t] = c.cpu().data\r\n\r\n        # get predictions in list to concat later\r\n        out_masks.append(out_mask)\r\n=================================\r\nGlad to waiting for your answer. Thanks!\r\nBest ragards,\r\nzwk","closed_by":null,"reactions":{"url":"https://api.github.com/repos/imatge-upc/rvos/issues/35/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/imatge-upc/rvos/issues/35/timeline","performed_via_github_app":null,"state_reason":null}