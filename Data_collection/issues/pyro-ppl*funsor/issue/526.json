{"url":"https://api.github.com/repos/pyro-ppl/funsor/issues/526","repository_url":"https://api.github.com/repos/pyro-ppl/funsor","labels_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/526/labels{/name}","comments_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/526/comments","events_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/526/events","html_url":"https://github.com/pyro-ppl/funsor/issues/526","id":855990666,"node_id":"MDU6SXNzdWU4NTU5OTA2NjY=","number":526,"title":"Support Python immutable datatypes without subclassing Funsor","user":{"login":"fritzo","id":648532,"node_id":"MDQ6VXNlcjY0ODUzMg==","avatar_url":"https://avatars.githubusercontent.com/u/648532?v=4","gravatar_id":"","url":"https://api.github.com/users/fritzo","html_url":"https://github.com/fritzo","followers_url":"https://api.github.com/users/fritzo/followers","following_url":"https://api.github.com/users/fritzo/following{/other_user}","gists_url":"https://api.github.com/users/fritzo/gists{/gist_id}","starred_url":"https://api.github.com/users/fritzo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fritzo/subscriptions","organizations_url":"https://api.github.com/users/fritzo/orgs","repos_url":"https://api.github.com/users/fritzo/repos","events_url":"https://api.github.com/users/fritzo/events{/privacy}","received_events_url":"https://api.github.com/users/fritzo/received_events","type":"User","site_admin":false},"labels":[{"id":1245797346,"node_id":"MDU6TGFiZWwxMjQ1Nzk3MzQ2","url":"https://api.github.com/repos/pyro-ppl/funsor/labels/refactor","name":"refactor","color":"ff9900","default":false,"description":""},{"id":1262045842,"node_id":"MDU6TGFiZWwxMjYyMDQ1ODQy","url":"https://api.github.com/repos/pyro-ppl/funsor/labels/discussion","name":"discussion","color":"fef2c0","default":false,"description":""},{"id":1266688771,"node_id":"MDU6TGFiZWwxMjY2Njg4Nzcx","url":"https://api.github.com/repos/pyro-ppl/funsor/labels/low%20priority","name":"low priority","color":"c2e0c6","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-04-12T13:41:09Z","updated_at":"2021-04-12T15:05:20Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"Alternative to #525\r\n\r\n## The problem\r\n\r\nFunsor computations rely on metadata stored as `Funsor` attributes (including `.inputs`, `.output`, `.input_vars`, `.fresh`, `.bound`) and rely on special behavior accessed via methods `FunsorMeta.__call__()` and `Funsor.__call__()`.  One problem with relying on attributes and methods is that computations are then restricted to funsor-owned custom datatypes, namely subclasses of the base `Funsor` class.  These restrictions make it cumbersome to perform funsor computations on non-`Funsor` immutable data such as tuples or frozensets of `Funsors`.  Moreover these restrictions prevent interaction with 3rd-party libraries that define their own immutable datatypes.\r\n\r\n## Proposed solution\r\n\r\nConsider moving all funsor metadata to a new metadata layer, say via a `funsor.meta(-)` function that looks up an immutable `Metadata` object with attributies `.inputs`, `.output`, `.input_vars`, `.fresh`, `.bound` etc.  All `Metadata` instances are stored in a single global `WeakKeyDictionary` keyed on the immutable data which implements `.__hash__()`.\r\n\r\nFurther consider supporting non-`Funsor`-types by replacing:\r\n1. `FunsorMeta.__call__()` → `reinterpret(-)` or a new `funsor.make(-)`, thereby supporting hash-consing and reinterpretation for non-`Funsor`-subclass types.\r\n2. `Funsor.__call__()` → `substitute(-, -)` or `Subs(-, -)` or a new `funsor.subs(arg, **kwargs)`, thereby supporting substitution for non-`Funsor.\r\n\r\nThis new type-agnostic interface for funsor data mechanics would be something like:\r\n- `funsor.meta(-)` to read metadata like `.inputs`, `.output` etc.\r\n- `funsor.subs(-, **kwargs)` to substitute for free variables in data\r\n- `funsor.make(-)` to create data in an interpretation-dependent way\r\n\r\n## Complications\r\n\r\n1. `str`, `tuple`, and subclasses thereof do not support weak referencing: they cannot be used as keys in a `WeakKeyDictionary` and cannot be registered via `weakref.finalize(-,-)`.\r\n\r\n## Tasks\r\n\r\n- [ ] Add a `funsor.meta(-)` function backed by a `WeakKeyDictionary`, and `Metadata` class (a `namedtuple`)\r\n- [ ] Move `.inputs` and `.output` into `Metadata`\r\n- [ ] Move `.fresh` and `.bound` into `Metadata`\r\n- [ ] Add a `frozendict` type\r\n- [ ] Compute metadata for other non-`Funsor`-subclass types: tuple, frozenset, frozendict\r\n- [ ] Simplify `funsor.interpreter` by using the new metadata\r\n- [ ] Add a `funsor.subs(-, **kwargs)` function (basically `funsor.terms.substitute(-, -)`)\r\n- [ ] Refactor to use `funsor.subs` instead of `Funsor.__call__()`\r\n- [ ] Add a `funsor.make(-)` function\r\n- [ ] Refactor to use `funsor.make(-)` instead of `FunsorMeta.__call__()`\r\n- [ ] Support non-`Funsor`-subclass types in `funsor.make(-)`\r\n- [ ] Remove `funsor.Terms.Tuple` type since `tuple` now suffices\r\n- [ ] Implement a singledispatch function `funsor.fingerprint(-)` to extensibly hash non-hashable non-equality-comparable datatypes.\r\n- [ ] Consider renaming `.inputs` → `.free_vars` and `.output` → `.domain` or `.dtype` or similar","closed_by":null,"reactions":{"url":"https://api.github.com/repos/pyro-ppl/funsor/issues/526/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/526/timeline","performed_via_github_app":null,"state_reason":null}