{"url":"https://api.github.com/repos/pyro-ppl/funsor/issues/374","repository_url":"https://api.github.com/repos/pyro-ppl/funsor","labels_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/374/labels{/name}","comments_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/374/comments","events_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/374/events","html_url":"https://github.com/pyro-ppl/funsor/issues/374","id":711403376,"node_id":"MDU6SXNzdWU3MTE0MDMzNzY=","number":374,"title":"Exploit opportunities for analytic KL and entropy computations","user":{"login":"eb8680","id":2032320,"node_id":"MDQ6VXNlcjIwMzIzMjA=","avatar_url":"https://avatars.githubusercontent.com/u/2032320?v=4","gravatar_id":"","url":"https://api.github.com/users/eb8680","html_url":"https://github.com/eb8680","followers_url":"https://api.github.com/users/eb8680/followers","following_url":"https://api.github.com/users/eb8680/following{/other_user}","gists_url":"https://api.github.com/users/eb8680/gists{/gist_id}","starred_url":"https://api.github.com/users/eb8680/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eb8680/subscriptions","organizations_url":"https://api.github.com/users/eb8680/orgs","repos_url":"https://api.github.com/users/eb8680/repos","events_url":"https://api.github.com/users/eb8680/events{/privacy}","received_events_url":"https://api.github.com/users/eb8680/received_events","type":"User","site_admin":false},"labels":[{"id":1215006862,"node_id":"MDU6TGFiZWwxMjE1MDA2ODYy","url":"https://api.github.com/repos/pyro-ppl/funsor/labels/enhancement","name":"enhancement","color":"0e8a16","default":true,"description":"New feature or request"},{"id":1215006863,"node_id":"MDU6TGFiZWwxMjE1MDA2ODYz","url":"https://api.github.com/repos/pyro-ppl/funsor/labels/help%20wanted","name":"help wanted","color":"008672","default":true,"description":"Extra attention is needed"},{"id":1262045842,"node_id":"MDU6TGFiZWwxMjYyMDQ1ODQy","url":"https://api.github.com/repos/pyro-ppl/funsor/labels/discussion","name":"discussion","color":"fef2c0","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-09-29T19:52:10Z","updated_at":"2020-09-29T20:05:03Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"Motivated by @fehiepsi's work on `TraceMeanField_ELBO` in NumPyro https://github.com/pyro-ppl/numpyro/pull/748 and ongoing issues with the LDA example in Pyro. cc @fritzo @martinjankowiak \r\n\r\nIt is common in Pyro to use mean-field variational distributions with `TraceMeanField_ELBO` to reduce ELBO estimator variance.  However, `TraceMeanField_ELBO` is too conservative and cannot be used for only part of a model or combined with Pyro's other inference tools, notably enumeration of discrete variables, making it difficult to perform variational inference reliably in models like LDA.\r\n\r\nA better long-term approach would be to automatically identify ELBO fragments that admit analytic computation.  Most such fragments are determined (almost) nonparametrically by conditional independence properties of the model and guide, so it should be possible in principle to cover a surprisingly wide range of Pyro models.\r\n\r\nWe can decompose this pattern-matching problem into two stages using Funsor: patterns for recognizing situations within a larger computation where analytic KL divergence and entropy computations may be used, and patterns for actually performing these computations using the backend distribution libraries' preexisting optimized implementations.  These patterns could then be used seamlessly within any Funsor-based ELBO implementation, notably `pyro.contrib.funsor.infer.TraceEnum_ELBO`.\r\n\r\n`funsor.optimize.optimize` already decomposes ELBO computations into conditionally independent fragments, although there are missing details like constant propagation that need to be handled with more generality (see also #163 #109).\r\n\r\nThus, at a high level, for the first stage we'll just need to add patterns that rewrite Monte Carlo expectations back to analytic versions. Obviously this is only applicable when we can guarantee that the Monte Carlo measure is drawn from the same distribution, so these patterns would have to live in their own special interpretation:\r\n```python\r\n@dispatched_interpretation\r\ndef analytic_recognizer(cls, *args):\r\n    return analytic_recognizer.dispatch(cls, *args)(*args)\r\n\r\n@analytic_recognizer.register(Integrate, Delta, Distribution, frozenset)\r\ndef recognize_analytic_entropy(log_measure, integrand, reduced_vars):\r\n    ...  # check that the rewrite can be performed\r\n    return Integrate(integrand, integrand, reduced_vars)\r\n```\r\nFor added robustness, `analytic_recognizer` could be a `StatefulInterpretation` holding a mapping from `Delta` funsors to their sampling distribution funsors.\r\n\r\nFor the second stage, we'll need `eager` patterns that are evaluated using the backend `.entropy` or `kl` implementations:\r\n```python\r\n@eager.register(Integrate, Distribution, Distribution, frozenset)\r\ndef eager_analytic_entropy(log_measure, integrand, reduced_vars):\r\n    name_to_dim, dim_to_name = ...  # arbitrary name-dim mapping\r\n    entropy_raw = -funsor.to_data(integrand, name_to_dim).entropy()  # call TorchDistribution.entropy()\r\n    return funsor.to_funsor(entropy_raw, funsor.Real, dim_to_name)\r\n```\r\n\r\nWith these patterns in hand, computing analytic entropy or KL terms in `pyro.contrib.funsor.infer.TraceEnum_ELBO` shouldn't involve too much beyond using the new `analytic_recognizer` interpretation when evaluating [the final ELBO funsor expression](https://github.com/pyro-ppl/pyro/blob/dev/pyro/contrib/funsor/infer/traceenum_elbo.py#L96).","closed_by":null,"reactions":{"url":"https://api.github.com/repos/pyro-ppl/funsor/issues/374/reactions","total_count":1,"+1":0,"-1":0,"laugh":0,"hooray":1,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/374/timeline","performed_via_github_app":null,"state_reason":null}