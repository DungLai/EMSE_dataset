{"url":"https://api.github.com/repos/pyro-ppl/funsor/issues/441","repository_url":"https://api.github.com/repos/pyro-ppl/funsor","labels_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/441/labels{/name}","comments_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/441/comments","events_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/441/events","html_url":"https://github.com/pyro-ppl/funsor/issues/441","id":793671191,"node_id":"MDU6SXNzdWU3OTM2NzExOTE=","number":441,"title":"Nondeterministic failure in test_distribution_generic.py","user":{"login":"fritzo","id":648532,"node_id":"MDQ6VXNlcjY0ODUzMg==","avatar_url":"https://avatars.githubusercontent.com/u/648532?v=4","gravatar_id":"","url":"https://api.github.com/users/fritzo","html_url":"https://github.com/fritzo","followers_url":"https://api.github.com/users/fritzo/followers","following_url":"https://api.github.com/users/fritzo/following{/other_user}","gists_url":"https://api.github.com/users/fritzo/gists{/gist_id}","starred_url":"https://api.github.com/users/fritzo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fritzo/subscriptions","organizations_url":"https://api.github.com/users/fritzo/orgs","repos_url":"https://api.github.com/users/fritzo/repos","events_url":"https://api.github.com/users/fritzo/events{/privacy}","received_events_url":"https://api.github.com/users/fritzo/received_events","type":"User","site_admin":false},"labels":[{"id":1215006860,"node_id":"MDU6TGFiZWwxMjE1MDA2ODYw","url":"https://api.github.com/repos/pyro-ppl/funsor/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"},{"id":1248329740,"node_id":"MDU6TGFiZWwxMjQ4MzI5NzQw","url":"https://api.github.com/repos/pyro-ppl/funsor/labels/testing","name":"testing","color":"a04623","default":false,"description":""}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2021-01-25T19:40:39Z","updated_at":"2021-02-03T13:14:18Z","closed_at":"2021-02-03T13:14:18Z","author_association":"MEMBER","active_lock_reason":null,"body":"I've been seeing nondeterministic failures in tests that use random generators. This should not happen, since we set the seed in conftest.py. Is there a source of nondeterminism that I'm missing?\r\n\r\n\r\nExample: https://github.com/pyro-ppl/funsor/pull/427 with log https://api.travis-ci.com/v3/job/474778699/log.txt\r\n\r\n<details>\r\n\r\n```\r\n=================================== FAILURES ===================================\r\n\u001B[31m\u001B[1m test_generic_log_prob[True-dist.TransformedDistribution( dist.Uniform(low=case.low, high=case.high), [dist.transforms.TanhTransform().inv]) (('low', '0.5*rand((2, 3))'), ('high', '0.5 + 0.5*rand((2, 3))'))] \u001B[0m\r\n[gw0] linux -- Python 3.6.7 /home/travis/virtualenv/python3.6.7/bin/python\r\n\r\ncase = <test.test_distribution_generic.DistTestCase object at 0x7f5b7dbf2cc0>\r\nuse_lazy = True\r\n\r\n\u001B[1m    @pytest.mark.parametrize(\"case\", TEST_CASES, ids=str)\u001B[0m\r\n\u001B[1m    @pytest.mark.parametrize(\"use_lazy\", [True, False])\u001B[0m\r\n\u001B[1m    def test_generic_log_prob(case, use_lazy):\u001B[0m\r\n\u001B[1m        raw_dist = case.get_dist()\u001B[0m\r\n\u001B[1m        expected_value_domain = case.expected_value_domain\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m        dim_to_name, name_to_dim = _default_dim_to_name(raw_dist.batch_shape)\u001B[0m\r\n\u001B[1m        with interpretation(normalize_with_subs if use_lazy else eager):\u001B[0m\r\n\u001B[1m            with xfail_if_not_implemented(match=\"try upgrading backend\"):\u001B[0m\r\n\u001B[1m                # some distributions have nontrivial eager patterns\u001B[0m\r\n\u001B[1m                funsor_dist = to_funsor(raw_dist, output=funsor.Real, dim_to_name=dim_to_name)\u001B[0m\r\n\u001B[1m        expected_inputs = {name: funsor.Bint[raw_dist.batch_shape[dim]] for dim, name in dim_to_name.items()}\u001B[0m\r\n\u001B[1m        expected_inputs.update({\"value\": expected_value_domain})\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m        check_funsor(funsor_dist, expected_inputs, funsor.Real)\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m        if get_backend() == \"jax\":\u001B[0m\r\n\u001B[1m            raw_value = raw_dist.sample(key=np.array([0, 0], dtype=np.uint32))\u001B[0m\r\n\u001B[1m        else:\u001B[0m\r\n\u001B[1m            raw_value = raw_dist.sample()\u001B[0m\r\n\u001B[1m        expected_logprob = to_funsor(raw_dist.log_prob(raw_value), output=funsor.Real, dim_to_name=dim_to_name)\u001B[0m\r\n\u001B[1m        funsor_value = to_funsor(raw_value, output=expected_value_domain, dim_to_name=dim_to_name)\u001B[0m\r\n\u001B[1m>       assert_close(funsor_dist(value=funsor_value), expected_logprob, rtol=1e-3)\u001B[0m\r\n\r\n\u001B[1m\u001B[31mtest/test_distribution_generic.py\u001B[0m:632: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\u001B[1m\u001B[31mfunsor/testing.py\u001B[0m:105: in assert_close\r\n\u001B[1m    assert_close(actual.data, expected.data, atol=atol, rtol=rtol)\u001B[0m\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nactual = tensor([[ 4.1991e-05, -7.2371e-01,  6.1929e-01],\r\n        [ 2.5963e-01,  2.5250e-01,  7.6591e-01]])\r\nexpected = tensor([[ 4.2111e-05, -7.2371e-01,  6.1929e-01],\r\n        [ 2.5963e-01,  2.5250e-01,  7.6591e-01]])\r\natol = 1e-06, rtol = 0.001\r\n\r\n\u001B[1m    def assert_close(actual, expected, atol=1e-6, rtol=1e-6):\u001B[0m\r\n\u001B[1m        msg = ActualExpected(actual, expected)\u001B[0m\r\n\u001B[1m        if is_array(actual):\u001B[0m\r\n\u001B[1m            assert is_array(expected), msg\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Tensor) and is_array(actual.data):\u001B[0m\r\n\u001B[1m            assert isinstance(expected, Tensor) and is_array(expected.data)\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Contraction) and isinstance(actual.terms[0], Tensor) \\\u001B[0m\r\n\u001B[1m                and is_array(actual.terms[0].data):\u001B[0m\r\n\u001B[1m            assert isinstance(expected, Contraction) and is_array(expected.terms[0].data)\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Gaussian) and is_array(actual.info_vec):\u001B[0m\r\n\u001B[1m            assert isinstance(expected, Gaussian) and is_array(expected.info_vec)\u001B[0m\r\n\u001B[1m        else:\u001B[0m\r\n\u001B[1m            assert type(actual) == type(expected), msg\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m        if isinstance(actual, Funsor):\u001B[0m\r\n\u001B[1m            assert isinstance(actual, Funsor)\u001B[0m\r\n\u001B[1m            assert isinstance(expected, Funsor)\u001B[0m\r\n\u001B[1m            assert actual.inputs == expected.inputs, (actual.inputs, expected.inputs)\u001B[0m\r\n\u001B[1m            assert actual.output == expected.output, (actual.output, expected.output)\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m        if isinstance(actual, (Number, Tensor)):\u001B[0m\r\n\u001B[1m            assert_close(actual.data, expected.data, atol=atol, rtol=rtol)\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Delta):\u001B[0m\r\n\u001B[1m            assert frozenset(n for n, p in actual.terms) == frozenset(n for n, p in expected.terms)\u001B[0m\r\n\u001B[1m            actual = actual.align(tuple(n for n, p in expected.terms))\u001B[0m\r\n\u001B[1m            for (actual_name, (actual_point, actual_log_density)), \\\u001B[0m\r\n\u001B[1m                    (expected_name, (expected_point, expected_log_density)) in \\\u001B[0m\r\n\u001B[1m                    zip(actual.terms, expected.terms):\u001B[0m\r\n\u001B[1m                assert actual_name == expected_name\u001B[0m\r\n\u001B[1m                assert_close(actual_point, expected_point, atol=atol, rtol=rtol)\u001B[0m\r\n\u001B[1m                assert_close(actual_log_density, expected_log_density, atol=atol, rtol=rtol)\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Gaussian):\u001B[0m\r\n\u001B[1m            assert_close(actual.info_vec, expected.info_vec, atol=atol, rtol=rtol)\u001B[0m\r\n\u001B[1m            assert_close(actual.precision, expected.precision, atol=atol, rtol=rtol)\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Contraction):\u001B[0m\r\n\u001B[1m            assert actual.red_op == expected.red_op\u001B[0m\r\n\u001B[1m            assert actual.bin_op == expected.bin_op\u001B[0m\r\n\u001B[1m            assert actual.reduced_vars == expected.reduced_vars\u001B[0m\r\n\u001B[1m            assert len(actual.terms) == len(expected.terms)\u001B[0m\r\n\u001B[1m            for ta, te in zip(actual.terms, expected.terms):\u001B[0m\r\n\u001B[1m                assert_close(ta, te, atol, rtol)\u001B[0m\r\n\u001B[1m        elif type(actual).__name__ == \"Tensor\":\u001B[0m\r\n\u001B[1m            assert get_backend() == \"torch\"\u001B[0m\r\n\u001B[1m            import torch\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m            assert actual.dtype == expected.dtype, msg\u001B[0m\r\n\u001B[1m            assert actual.shape == expected.shape, msg\u001B[0m\r\n\u001B[1m            if actual.dtype in (torch.long, torch.uint8, torch.bool):\u001B[0m\r\n\u001B[1m                assert (actual == expected).all(), msg\u001B[0m\r\n\u001B[1m            else:\u001B[0m\r\n\u001B[1m                eq = (actual == expected)\u001B[0m\r\n\u001B[1m                if eq.all():\u001B[0m\r\n\u001B[1m                    return\u001B[0m\r\n\u001B[1m                if eq.any():\u001B[0m\r\n\u001B[1m                    actual = actual[~eq]\u001B[0m\r\n\u001B[1m                    expected = expected[~eq]\u001B[0m\r\n\u001B[1m                diff = (actual.detach() - expected.detach()).abs()\u001B[0m\r\n\u001B[1m                if rtol is not None:\u001B[0m\r\n\u001B[1m>                   assert (diff / (atol + expected.detach().abs())).max() < rtol, msg\u001B[0m\r\n\u001B[1m\u001B[31mE                   AssertionError: Expected:\u001B[0m\r\n\u001B[1m\u001B[31mE                   tensor([[ 4.2111e-05, -7.2371e-01,  6.1929e-01],\u001B[0m\r\n\u001B[1m\u001B[31mE                           [ 2.5963e-01,  2.5250e-01,  7.6591e-01]])\u001B[0m\r\n\u001B[1m\u001B[31mE                   Actual:\u001B[0m\r\n\u001B[1m\u001B[31mE                   tensor([[ 4.1991e-05, -7.2371e-01,  6.1929e-01],\u001B[0m\r\n\u001B[1m\u001B[31mE                           [ 2.5963e-01,  2.5250e-01,  7.6591e-01]])\u001B[0m\r\n\r\n\u001B[1m\u001B[31mfunsor/testing.py\u001B[0m:142: AssertionError\r\n\u001B[31m\u001B[1m test_generic_log_prob[False-dist.TransformedDistribution( dist.Uniform(low=case.low, high=case.high), [dist.transforms.TanhTransform().inv]) (('low', '0.5*rand((2, 3))'), ('high', '0.5 + 0.5*rand((2, 3))'))] \u001B[0m\r\n[gw0] linux -- Python 3.6.7 /home/travis/virtualenv/python3.6.7/bin/python\r\n\r\ncase = <test.test_distribution_generic.DistTestCase object at 0x7f5b7dbf2cc0>\r\nuse_lazy = False\r\n\r\n\u001B[1m    @pytest.mark.parametrize(\"case\", TEST_CASES, ids=str)\u001B[0m\r\n\u001B[1m    @pytest.mark.parametrize(\"use_lazy\", [True, False])\u001B[0m\r\n\u001B[1m    def test_generic_log_prob(case, use_lazy):\u001B[0m\r\n\u001B[1m        raw_dist = case.get_dist()\u001B[0m\r\n\u001B[1m        expected_value_domain = case.expected_value_domain\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m        dim_to_name, name_to_dim = _default_dim_to_name(raw_dist.batch_shape)\u001B[0m\r\n\u001B[1m        with interpretation(normalize_with_subs if use_lazy else eager):\u001B[0m\r\n\u001B[1m            with xfail_if_not_implemented(match=\"try upgrading backend\"):\u001B[0m\r\n\u001B[1m                # some distributions have nontrivial eager patterns\u001B[0m\r\n\u001B[1m                funsor_dist = to_funsor(raw_dist, output=funsor.Real, dim_to_name=dim_to_name)\u001B[0m\r\n\u001B[1m        expected_inputs = {name: funsor.Bint[raw_dist.batch_shape[dim]] for dim, name in dim_to_name.items()}\u001B[0m\r\n\u001B[1m        expected_inputs.update({\"value\": expected_value_domain})\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m        check_funsor(funsor_dist, expected_inputs, funsor.Real)\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m        if get_backend() == \"jax\":\u001B[0m\r\n\u001B[1m            raw_value = raw_dist.sample(key=np.array([0, 0], dtype=np.uint32))\u001B[0m\r\n\u001B[1m        else:\u001B[0m\r\n\u001B[1m            raw_value = raw_dist.sample()\u001B[0m\r\n\u001B[1m        expected_logprob = to_funsor(raw_dist.log_prob(raw_value), output=funsor.Real, dim_to_name=dim_to_name)\u001B[0m\r\n\u001B[1m        funsor_value = to_funsor(raw_value, output=expected_value_domain, dim_to_name=dim_to_name)\u001B[0m\r\n\u001B[1m>       assert_close(funsor_dist(value=funsor_value), expected_logprob, rtol=1e-3)\u001B[0m\r\n\r\n\u001B[1m\u001B[31mtest/test_distribution_generic.py\u001B[0m:632: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\u001B[1m\u001B[31mfunsor/testing.py\u001B[0m:105: in assert_close\r\n\u001B[1m    assert_close(actual.data, expected.data, atol=atol, rtol=rtol)\u001B[0m\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nactual = tensor([[ 4.1991e-05, -7.2371e-01,  6.1929e-01],\r\n        [ 2.5963e-01,  2.5250e-01,  7.6591e-01]])\r\nexpected = tensor([[ 4.2111e-05, -7.2371e-01,  6.1929e-01],\r\n        [ 2.5963e-01,  2.5250e-01,  7.6591e-01]])\r\natol = 1e-06, rtol = 0.001\r\n\r\n\u001B[1m    def assert_close(actual, expected, atol=1e-6, rtol=1e-6):\u001B[0m\r\n\u001B[1m        msg = ActualExpected(actual, expected)\u001B[0m\r\n\u001B[1m        if is_array(actual):\u001B[0m\r\n\u001B[1m            assert is_array(expected), msg\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Tensor) and is_array(actual.data):\u001B[0m\r\n\u001B[1m            assert isinstance(expected, Tensor) and is_array(expected.data)\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Contraction) and isinstance(actual.terms[0], Tensor) \\\u001B[0m\r\n\u001B[1m                and is_array(actual.terms[0].data):\u001B[0m\r\n\u001B[1m            assert isinstance(expected, Contraction) and is_array(expected.terms[0].data)\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Gaussian) and is_array(actual.info_vec):\u001B[0m\r\n\u001B[1m            assert isinstance(expected, Gaussian) and is_array(expected.info_vec)\u001B[0m\r\n\u001B[1m        else:\u001B[0m\r\n\u001B[1m            assert type(actual) == type(expected), msg\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m        if isinstance(actual, Funsor):\u001B[0m\r\n\u001B[1m            assert isinstance(actual, Funsor)\u001B[0m\r\n\u001B[1m            assert isinstance(expected, Funsor)\u001B[0m\r\n\u001B[1m            assert actual.inputs == expected.inputs, (actual.inputs, expected.inputs)\u001B[0m\r\n\u001B[1m            assert actual.output == expected.output, (actual.output, expected.output)\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m        if isinstance(actual, (Number, Tensor)):\u001B[0m\r\n\u001B[1m            assert_close(actual.data, expected.data, atol=atol, rtol=rtol)\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Delta):\u001B[0m\r\n\u001B[1m            assert frozenset(n for n, p in actual.terms) == frozenset(n for n, p in expected.terms)\u001B[0m\r\n\u001B[1m            actual = actual.align(tuple(n for n, p in expected.terms))\u001B[0m\r\n\u001B[1m            for (actual_name, (actual_point, actual_log_density)), \\\u001B[0m\r\n\u001B[1m                    (expected_name, (expected_point, expected_log_density)) in \\\u001B[0m\r\n\u001B[1m                    zip(actual.terms, expected.terms):\u001B[0m\r\n\u001B[1m                assert actual_name == expected_name\u001B[0m\r\n\u001B[1m                assert_close(actual_point, expected_point, atol=atol, rtol=rtol)\u001B[0m\r\n\u001B[1m                assert_close(actual_log_density, expected_log_density, atol=atol, rtol=rtol)\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Gaussian):\u001B[0m\r\n\u001B[1m            assert_close(actual.info_vec, expected.info_vec, atol=atol, rtol=rtol)\u001B[0m\r\n\u001B[1m            assert_close(actual.precision, expected.precision, atol=atol, rtol=rtol)\u001B[0m\r\n\u001B[1m        elif isinstance(actual, Contraction):\u001B[0m\r\n\u001B[1m            assert actual.red_op == expected.red_op\u001B[0m\r\n\u001B[1m            assert actual.bin_op == expected.bin_op\u001B[0m\r\n\u001B[1m            assert actual.reduced_vars == expected.reduced_vars\u001B[0m\r\n\u001B[1m            assert len(actual.terms) == len(expected.terms)\u001B[0m\r\n\u001B[1m            for ta, te in zip(actual.terms, expected.terms):\u001B[0m\r\n\u001B[1m                assert_close(ta, te, atol, rtol)\u001B[0m\r\n\u001B[1m        elif type(actual).__name__ == \"Tensor\":\u001B[0m\r\n\u001B[1m            assert get_backend() == \"torch\"\u001B[0m\r\n\u001B[1m            import torch\u001B[0m\r\n\u001B[1m    \u001B[0m\r\n\u001B[1m            assert actual.dtype == expected.dtype, msg\u001B[0m\r\n\u001B[1m            assert actual.shape == expected.shape, msg\u001B[0m\r\n\u001B[1m            if actual.dtype in (torch.long, torch.uint8, torch.bool):\u001B[0m\r\n\u001B[1m                assert (actual == expected).all(), msg\u001B[0m\r\n\u001B[1m            else:\u001B[0m\r\n\u001B[1m                eq = (actual == expected)\u001B[0m\r\n\u001B[1m                if eq.all():\u001B[0m\r\n\u001B[1m                    return\u001B[0m\r\n\u001B[1m                if eq.any():\u001B[0m\r\n\u001B[1m                    actual = actual[~eq]\u001B[0m\r\n\u001B[1m                    expected = expected[~eq]\u001B[0m\r\n\u001B[1m                diff = (actual.detach() - expected.detach()).abs()\u001B[0m\r\n\u001B[1m                if rtol is not None:\u001B[0m\r\n\u001B[1m>                   assert (diff / (atol + expected.detach().abs())).max() < rtol, msg\u001B[0m\r\n\u001B[1m\u001B[31mE                   AssertionError: Expected:\u001B[0m\r\n\u001B[1m\u001B[31mE                   tensor([[ 4.2111e-05, -7.2371e-01,  6.1929e-01],\u001B[0m\r\n\u001B[1m\u001B[31mE                           [ 2.5963e-01,  2.5250e-01,  7.6591e-01]])\u001B[0m\r\n\u001B[1m\u001B[31mE                   Actual:\u001B[0m\r\n\u001B[1m\u001B[31mE                   tensor([[ 4.1991e-05, -7.2371e-01,  6.1929e-01],\u001B[0m\r\n\u001B[1m\u001B[31mE                           [ 2.5963e-01,  2.5250e-01,  7.6591e-01]])\u001B[0m\r\n\r\n\u001B[1m\u001B[31mfunsor/testing.py\u001B[0m:142: AssertionError\r\n\u001B[33m=============================== warnings summary ===============================\u001B[0m\r\nfunsor/tensor.py:879\r\nfunsor/tensor.py:879\r\nfunsor/tensor.py:879\r\nfunsor/tensor.py:879\r\n  /home/travis/build/pyro-ppl/funsor/funsor/tensor.py:879: DeprecationWarning: tuple types like (Real, Reals[2]) are deprecated, use Tuple[Real, Reals[2]] instead\r\n    DeprecationWarning)\r\n\r\n-- Docs: https://docs.pytest.org/en/latest/warnings.html\r\n\u001B[31m\u001B[1m 2 failed, 10155 passed, 19 skipped, 533 xfailed, 91 xpassed, 4 warnings in 398.66 seconds \u001B[0m\r\nMakefile:23: recipe for target 'test' failed\r\nmake: *** [test] Error 1\r\ntravis_time:end:088f56c3:start=1611533200567500419,finish=1611533609395635812,duration=408828135393,event=script\r\n\u001B[0K\u001B[31;1mThe command \"FUNSOR_BACKEND=torch make test\" exited with 2.\u001B[0m\r\ntravis_fold:start:cache.2\r\n\u001B[0Kstore build cache\r\ntravis_time:start:0130e024\r\n\u001B[0Ktravis_time:end:0130e024:start=1611533609400001839,finish=1611533609402740055,duration=2738216,event=cache\r\n\u001B[0Ktravis_time:start:01fc5838\r\n\u001B[0K\u001B[32;1mnothing changed\u001B[0m\r\ntravis_time:end:01fc5838:start=1611533609406249165,finish=1611533610249520444,duration=843271279,event=cache\r\n\u001B[0Ktravis_fold:end:cache.2\r\n\u001B[0K\r\n\r\nDone. Your build exited with 1.\r\n```\r\n\r\n</details>","closed_by":{"login":"fritzo","id":648532,"node_id":"MDQ6VXNlcjY0ODUzMg==","avatar_url":"https://avatars.githubusercontent.com/u/648532?v=4","gravatar_id":"","url":"https://api.github.com/users/fritzo","html_url":"https://github.com/fritzo","followers_url":"https://api.github.com/users/fritzo/followers","following_url":"https://api.github.com/users/fritzo/following{/other_user}","gists_url":"https://api.github.com/users/fritzo/gists{/gist_id}","starred_url":"https://api.github.com/users/fritzo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fritzo/subscriptions","organizations_url":"https://api.github.com/users/fritzo/orgs","repos_url":"https://api.github.com/users/fritzo/repos","events_url":"https://api.github.com/users/fritzo/events{/privacy}","received_events_url":"https://api.github.com/users/fritzo/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/pyro-ppl/funsor/issues/441/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/pyro-ppl/funsor/issues/441/timeline","performed_via_github_app":null,"state_reason":"completed"}