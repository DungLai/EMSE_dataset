{"url":"https://api.github.com/repos/hackingmaterials/automatminer/issues/253","repository_url":"https://api.github.com/repos/hackingmaterials/automatminer","labels_url":"https://api.github.com/repos/hackingmaterials/automatminer/issues/253/labels{/name}","comments_url":"https://api.github.com/repos/hackingmaterials/automatminer/issues/253/comments","events_url":"https://api.github.com/repos/hackingmaterials/automatminer/issues/253/events","html_url":"https://github.com/hackingmaterials/automatminer/issues/253","id":507822502,"node_id":"MDU6SXNzdWU1MDc4MjI1MDI=","number":253,"title":"TypeError: can't pickle _thread.RLock objects when saving a pipe","user":{"login":"janosh","id":30958850,"node_id":"MDQ6VXNlcjMwOTU4ODUw","avatar_url":"https://avatars.githubusercontent.com/u/30958850?v=4","gravatar_id":"","url":"https://api.github.com/users/janosh","html_url":"https://github.com/janosh","followers_url":"https://api.github.com/users/janosh/followers","following_url":"https://api.github.com/users/janosh/following{/other_user}","gists_url":"https://api.github.com/users/janosh/gists{/gist_id}","starred_url":"https://api.github.com/users/janosh/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/janosh/subscriptions","organizations_url":"https://api.github.com/users/janosh/orgs","repos_url":"https://api.github.com/users/janosh/repos","events_url":"https://api.github.com/users/janosh/events{/privacy}","received_events_url":"https://api.github.com/users/janosh/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":18,"created_at":"2019-10-16T12:34:08Z","updated_at":"2019-11-12T06:19:31Z","closed_at":"2019-10-20T21:18:18Z","author_association":"MEMBER","active_lock_reason":null,"body":"Just updated to `automatminer@2019.10.14` and I'm now getting a type error with the following stack trace when attempting to save a pipe.\r\n\r\n```py\r\nTypeError                                 Traceback (most recent call last)\r\n      1 pipe.summarize(log_dir + \"pipe_summary.yml\")\r\n----> 2 pipe.save(log_dir + \"mat.pipe\")\r\n      3 \r\n      4 # #%%\r\n      5 # pipe.digest(log_dir + \"digest.txt\")\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/site-packages/automatminer/utils/pkg.py in wrapper(*args, **kwargs)\r\n     80                                  \"\".format(args[0].__class__.__name__))\r\n     81         else:\r\n---> 82             return func(*args, **kwargs)\r\n     83 \r\n     84     return wrapper\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/site-packages/automatminer/pipeline.py in save(self, filename)\r\n    415         self.learner.serialize()\r\n    416 \r\n--> 417         temp_logger = copy.deepcopy(self._logger)\r\n    418         loggables = [\r\n    419             self, self.learner, self.reducer, self.cleaner, self.autofeaturizer\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in deepcopy(x, memo, _nil)\r\n    178                     y = x\r\n    179                 else:\r\n--> 180                     y = _reconstruct(x, memo, *rv)\r\n    181 \r\n    182     # If is its own copy, don't memoize.\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in _reconstruct(x, memo, func, args, state, listiter, dictiter, deepcopy)\r\n    278     if state is not None:\r\n    279         if deep:\r\n--> 280             state = deepcopy(state, memo)\r\n    281         if hasattr(y, '__setstate__'):\r\n    282             y.__setstate__(state)\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in deepcopy(x, memo, _nil)\r\n    148     copier = _deepcopy_dispatch.get(cls)\r\n    149     if copier:\r\n--> 150         y = copier(x, memo)\r\n    151     else:\r\n    152         try:\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in _deepcopy_dict(x, memo, deepcopy)\r\n    238     memo[id(x)] = y\r\n    239     for key, value in x.items():\r\n--> 240         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    241     return y\r\n    242 d[dict] = _deepcopy_dict\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in deepcopy(x, memo, _nil)\r\n    148     copier = _deepcopy_dispatch.get(cls)\r\n    149     if copier:\r\n--> 150         y = copier(x, memo)\r\n    151     else:\r\n    152         try:\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in _deepcopy_list(x, memo, deepcopy)\r\n    213     append = y.append\r\n    214     for a in x:\r\n--> 215         append(deepcopy(a, memo))\r\n    216     return y\r\n    217 d[list] = _deepcopy_list\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in deepcopy(x, memo, _nil)\r\n    178                     y = x\r\n    179                 else:\r\n--> 180                     y = _reconstruct(x, memo, *rv)\r\n    181 \r\n    182     # If is its own copy, don't memoize.\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in _reconstruct(x, memo, func, args, state, listiter, dictiter, deepcopy)\r\n    278     if state is not None:\r\n    279         if deep:\r\n--> 280             state = deepcopy(state, memo)\r\n    281         if hasattr(y, '__setstate__'):\r\n    282             y.__setstate__(state)\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in deepcopy(x, memo, _nil)\r\n    148     copier = _deepcopy_dispatch.get(cls)\r\n    149     if copier:\r\n--> 150         y = copier(x, memo)\r\n    151     else:\r\n    152         try:\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in _deepcopy_dict(x, memo, deepcopy)\r\n    238     memo[id(x)] = y\r\n    239     for key, value in x.items():\r\n--> 240         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    241     return y\r\n    242 d[dict] = _deepcopy_dict\r\n\r\n/usr/local/Caskroom/miniconda/base/envs/thermo/lib/python3.6/copy.py in deepcopy(x, memo, _nil)\r\n    167                     reductor = getattr(x, \"__reduce_ex__\", None)\r\n    168                     if reductor:\r\n--> 169                         rv = reductor(4)\r\n    170                     else:\r\n    171                         reductor = getattr(x, \"__reduce__\", None)\r\n\r\nTypeError: can't pickle _thread.RLock objects\r\n```","closed_by":{"login":"ardunn","id":19936203,"node_id":"MDQ6VXNlcjE5OTM2MjAz","avatar_url":"https://avatars.githubusercontent.com/u/19936203?v=4","gravatar_id":"","url":"https://api.github.com/users/ardunn","html_url":"https://github.com/ardunn","followers_url":"https://api.github.com/users/ardunn/followers","following_url":"https://api.github.com/users/ardunn/following{/other_user}","gists_url":"https://api.github.com/users/ardunn/gists{/gist_id}","starred_url":"https://api.github.com/users/ardunn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ardunn/subscriptions","organizations_url":"https://api.github.com/users/ardunn/orgs","repos_url":"https://api.github.com/users/ardunn/repos","events_url":"https://api.github.com/users/ardunn/events{/privacy}","received_events_url":"https://api.github.com/users/ardunn/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/hackingmaterials/automatminer/issues/253/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hackingmaterials/automatminer/issues/253/timeline","performed_via_github_app":null,"state_reason":"completed"}