{"url":"https://api.github.com/repos/hudson-and-thames/mlfinlab/issues/166","repository_url":"https://api.github.com/repos/hudson-and-thames/mlfinlab","labels_url":"https://api.github.com/repos/hudson-and-thames/mlfinlab/issues/166/labels{/name}","comments_url":"https://api.github.com/repos/hudson-and-thames/mlfinlab/issues/166/comments","events_url":"https://api.github.com/repos/hudson-and-thames/mlfinlab/issues/166/events","html_url":"https://github.com/hudson-and-thames/mlfinlab/issues/166","id":541730067,"node_id":"MDU6SXNzdWU1NDE3MzAwNjc=","number":166,"title":"FR: reverse order bar generation ; because data_structures {tick|volume|dollar} last bar is incomplete, which is a problem for inference","user":{"login":"flamby","id":1496003,"node_id":"MDQ6VXNlcjE0OTYwMDM=","avatar_url":"https://avatars.githubusercontent.com/u/1496003?v=4","gravatar_id":"","url":"https://api.github.com/users/flamby","html_url":"https://github.com/flamby","followers_url":"https://api.github.com/users/flamby/followers","following_url":"https://api.github.com/users/flamby/following{/other_user}","gists_url":"https://api.github.com/users/flamby/gists{/gist_id}","starred_url":"https://api.github.com/users/flamby/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/flamby/subscriptions","organizations_url":"https://api.github.com/users/flamby/orgs","repos_url":"https://api.github.com/users/flamby/repos","events_url":"https://api.github.com/users/flamby/events{/privacy}","received_events_url":"https://api.github.com/users/flamby/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":20,"created_at":"2019-12-23T12:16:52Z","updated_at":"2020-01-04T16:29:06Z","closed_at":"2020-01-04T16:29:06Z","author_association":"NONE","active_lock_reason":null,"body":"Hi,\r\n\r\nI'm using the `data_structures/alex` branch, and realized that the last bar is incomplete, in the sense that for instance, for tick bars with threshold=1000, the last bar's volume is not equal to the volume sum computed manually like so: `df[-1000:].agg({\"volume\":\"sum\"})` whereas the first bar's volume is equal to `df[0:1000].agg({\"volume\":\"sum\"})`, despite the cum_ticks column value is 1000.\r\n\r\nThe consequence for machine learning inference will be huge I think, since the last bar won't be similar in term of information to the ones used during training.\r\n\r\nThe code I used to confirm that:\r\n```python\r\nthreshold = 1000\r\ndf = pd.read_parquet(\"data/trades.parquet\")\r\nprint(\"First bar's volume computed manually\")\r\nprint(df.iloc[0:threshold].agg({\"volume\":\"sum\"}))\r\n>>>volume    22462.836376\r\n>>>dtype: float64\r\nprint(\"Last bar's volume computed manually\")\r\nprint(df.iloc[-threshold:].agg({\"volume\":\"sum\"}))\r\n>>>volume    268.416395\r\n>>>dtype: float64\r\n\r\ncustom_ohlc = standard_data_structures.get_tick_bars(df, threshold=threshold, batch_size=1000000,verbose=False)\r\nprint(\"First bar\")\r\nprint(custom_ohlc.head(1))\r\n>>>            date_time      open      high       low     close        volume  cum_buy_volume  cum_ticks  cum_dollar_value\r\n>>>0 2017-01-01 15:52:52  0.008331  0.008921  0.008331  0.008514  22462.836376    12329.926786       1000        194.043203\r\n\r\nprint(\"Last bar\")\r\nprint(custom_ohlc.tail(1))\r\n>>>                       date_time      open      high       low     close      volume  cum_buy_volume  cum_ticks  cum_dollar_value\r\n>>>15639 2019-12-22 17:48:10.335999  0.017935  0.017935  0.017784  0.017784  210.383762       19.849333       1000          3.749764\r\n```\r\n\r\nLast bar's volume computed using `get_tick_bars`should be 268.416395 whereas it is 210.383762, indicating that less than 1000 trades where used for the last bar, **which can be a very random number I guess**, from 1 to 999 trades in my example above, leading to potentially a bar with very low volume.\r\n\r\nSo the feature request is simple: having an option to those _`get_*_bars`_ function to generate the bar in reverse order, so that the last bar is correct from an information standpoint, and the first bar is not, which is not a problem since we can get rid of it, whether it is training or inference.\r\nI even think that this new behaviour should be the default one, but there might be use cases I did not think about.\r\n\r\nOf course I could generate the data manually for inference, but since my feature engineering requires hundreds of bars to `predict` the Target of the last one, I prefer relying on those _`get_*_bars`_  functions for inference data preparation, particularly if using imbalanced bars which are more complex.\r\n\r\nWhat do you think? Does it make sense?\r\n\r\nThanks and keep the good work!","closed_by":{"login":"proskurin","id":14288229,"node_id":"MDQ6VXNlcjE0Mjg4MjI5","avatar_url":"https://avatars.githubusercontent.com/u/14288229?v=4","gravatar_id":"","url":"https://api.github.com/users/proskurin","html_url":"https://github.com/proskurin","followers_url":"https://api.github.com/users/proskurin/followers","following_url":"https://api.github.com/users/proskurin/following{/other_user}","gists_url":"https://api.github.com/users/proskurin/gists{/gist_id}","starred_url":"https://api.github.com/users/proskurin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/proskurin/subscriptions","organizations_url":"https://api.github.com/users/proskurin/orgs","repos_url":"https://api.github.com/users/proskurin/repos","events_url":"https://api.github.com/users/proskurin/events{/privacy}","received_events_url":"https://api.github.com/users/proskurin/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/hudson-and-thames/mlfinlab/issues/166/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hudson-and-thames/mlfinlab/issues/166/timeline","performed_via_github_app":null,"state_reason":"completed"}