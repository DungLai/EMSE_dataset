[{"id":3897488226,"node_id":"MDE3OlJlbmFtZWRUaXRsZUV2ZW50Mzg5NzQ4ODIyNg==","url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/events/3897488226","actor":{"login":"WangLibo1995","id":38718224,"node_id":"MDQ6VXNlcjM4NzE4MjI0","avatar_url":"https://avatars.githubusercontent.com/u/38718224?v=4","gravatar_id":"","url":"https://api.github.com/users/WangLibo1995","html_url":"https://github.com/WangLibo1995","followers_url":"https://api.github.com/users/WangLibo1995/followers","following_url":"https://api.github.com/users/WangLibo1995/following{/other_user}","gists_url":"https://api.github.com/users/WangLibo1995/gists{/gist_id}","starred_url":"https://api.github.com/users/WangLibo1995/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/WangLibo1995/subscriptions","organizations_url":"https://api.github.com/users/WangLibo1995/orgs","repos_url":"https://api.github.com/users/WangLibo1995/repos","events_url":"https://api.github.com/users/WangLibo1995/events{/privacy}","received_events_url":"https://api.github.com/users/WangLibo1995/received_events","type":"User","site_admin":false},"event":"renamed","commit_id":null,"commit_url":null,"created_at":"2020-10-20T08:59:21Z","rename":{"from":"Iou","to":"IoUMetricsCallback error, iou too small"},"performed_via_github_app":null},{"url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/comments/714279807","html_url":"https://github.com/BloodAxe/pytorch-toolbelt/issues/50#issuecomment-714279807","issue_url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/50","id":714279807,"node_id":"MDEyOklzc3VlQ29tbWVudDcxNDI3OTgwNw==","user":{"login":"WangLibo1995","id":38718224,"node_id":"MDQ6VXNlcjM4NzE4MjI0","avatar_url":"https://avatars.githubusercontent.com/u/38718224?v=4","gravatar_id":"","url":"https://api.github.com/users/WangLibo1995","html_url":"https://github.com/WangLibo1995","followers_url":"https://api.github.com/users/WangLibo1995/followers","following_url":"https://api.github.com/users/WangLibo1995/following{/other_user}","gists_url":"https://api.github.com/users/WangLibo1995/gists{/gist_id}","starred_url":"https://api.github.com/users/WangLibo1995/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/WangLibo1995/subscriptions","organizations_url":"https://api.github.com/users/WangLibo1995/orgs","repos_url":"https://api.github.com/users/WangLibo1995/repos","events_url":"https://api.github.com/users/WangLibo1995/events{/privacy}","received_events_url":"https://api.github.com/users/WangLibo1995/received_events","type":"User","site_admin":false},"created_at":"2020-10-22T07:05:15Z","updated_at":"2020-10-22T07:05:15Z","author_association":"NONE","body":"I think it is not necessary to compute the score on every single image, the correct method is accumulation. the following is code and I have tested it.\r\n\r\nclass Evaluator(object):\r\n    def __init__(self, num_class):\r\n        self.num_class = num_class\r\n        self.confusion_matrix = np.zeros((self.num_class,)*2)\r\n\r\n    def get_tp_fp_tn_fn(self):\r\n        tp = np.diag(self.confusion_matrix)\r\n        fp = self.confusion_matrix.sum(axis=1) - np.diag(self.confusion_matrix)\r\n        fn = self.confusion_matrix.sum(axis=0) - np.diag(self.confusion_matrix)\r\n        tn = np.diag(self.confusion_matrix).sum() - np.diag(self.confusion_matrix)\r\n        return tp, fp, tn, fn\r\n\r\n    def F1(self):\r\n        tp, fp, tn, fn = self.get_tp_fp_tn_fn()\r\n        Precision = tp / (tp + fp)\r\n        Recall = tp / (tp + fn)\r\n        F1 = (2.0 * Precision * Recall) / (Precision + Recall)\r\n        return F1\r\n\r\n    def OA(self):\r\n        OA = np.diag(self.confusion_matrix).sum() / self.confusion_matrix.sum()\r\n        return OA\r\n\r\n    def OA_remove_bg(self):\r\n        bg = np.diag(self.confusion_matrix)[-1]\r\n        OA_remove_bg = (np.diag(self.confusion_matrix).sum() - bg) / (self.confusion_matrix[:-1, :-1].sum())\r\n        return OA_remove_bg\r\n\r\n    def Intersection_over_Union(self):\r\n        # IoU = np.diag(self.confusion_matrix) / (\r\n        #         np.sum(self.confusion_matrix, axis=1) + np.sum(self.confusion_matrix, axis=0) -\r\n        #         np.diag(self.confusion_matrix))\r\n        tp, fp, tn, fn = self.get_tp_fp_tn_fn()\r\n        IoU = tp / (tp + fn + fp)\r\n        return IoU\r\n\r\n    def Dice(self):\r\n        # IoU = np.diag(self.confusion_matrix) / (\r\n        #         np.sum(self.confusion_matrix, axis=1) + np.sum(self.confusion_matrix, axis=0) -\r\n        #         np.diag(self.confusion_matrix))\r\n        # MIoU = np.nanmean(IoU)\r\n        # MDice = (2*MIoU) / (MIoU + 1.0)\r\n        tp, fp, tn, fn = self.get_tp_fp_tn_fn()\r\n        Dice = 2 * tp / ((tp + fp) + (tp + fn))\r\n        return Dice\r\n\r\n    def Pixel_Accuracy_Class(self):\r\n        #         TP                                  TP+FP\r\n        Acc = np.diag(self.confusion_matrix) / self.confusion_matrix.sum(axis=1)\r\n        return Acc\r\n\r\n    def Frequency_Weighted_Intersection_over_Union(self):\r\n        freq = np.sum(self.confusion_matrix, axis=1) / np.sum(self.confusion_matrix)\r\n        iou = self.Intersection_over_Union()\r\n        FWIoU = (freq[freq > 0] * iou[freq > 0]).sum()\r\n        return FWIoU\r\n\r\n    def _generate_matrix(self, gt_image, pre_image):\r\n        mask = (gt_image >= 0) & (gt_image < self.num_class)\r\n        label = self.num_class * gt_image[mask].astype('int') + pre_image[mask]\r\n        count = np.bincount(label, minlength=self.num_class**2)\r\n        confusion_matrix = count.reshape(self.num_class, self.num_class)\r\n        return confusion_matrix\r\n\r\n    def add_batch(self, gt_image, pre_image):\r\n        assert gt_image.shape == pre_image.shape\r\n        self.confusion_matrix += self._generate_matrix(gt_image, pre_image)\r\n\r\n    def reset(self):\r\n        self.confusion_matrix = np.zeros((self.num_class,) * 2)\r\n\r\n\r\nclass EvaluateCallBack(Callback):\r\n    def __init__(\r\n            self,\r\n            class_names=None,  # tuple.('water','tree','person',...)\r\n            num_classes: int = None, # assert len(class_names)==num_classes\r\n            prefix=('iou', 'fwiou', 'OA', 'MPA', 'F1', 'dice'),\r\n            input_key: str = \"targets\",\r\n            output_key: str = \"logits\",\r\n            remove_background=True\r\n    ):\r\n        super().__init__(CallbackOrder.Metric)\r\n\r\n        self.output_key = output_key\r\n        self.input_key = input_key\r\n        self.class_names = class_names\r\n        self.num_classes = num_classes\r\n        self.prefix = prefix\r\n        self.evaluator = Evaluator(num_class=self.num_classes)\r\n        self.remove_background = remove_background\r\n\r\n    def on_loader_start(self, state):\r\n        self.evaluator.reset()\r\n\r\n    @torch.no_grad()\r\n    def on_batch_end(self, runner: IRunner):\r\n        outputs = runner.output[self.output_key].detach()\r\n        targets = runner.input[self.input_key].detach()\r\n\r\n        batch_size = targets.size(0)\r\n        for image_index in range(batch_size):\r\n            y_pred = outputs[image_index]\r\n            y_pred = y_pred.argmax(dim=0).cpu().numpy()\r\n            y_true = targets[image_index].cpu().numpy()\r\n            self.evaluator.add_batch(pre_image=y_pred, gt_image=y_true)\r\n        if self.remove_background:\r\n            runner.batch_metrics[self.prefix[0]] = np.nanmean(self.evaluator.Intersection_over_Union()[:-1])\r\n            runner.batch_metrics[self.prefix[1]] = np.nanmean(self.evaluator.Frequency_Weighted_Intersection_over_Union())\r\n            runner.batch_metrics[self.prefix[2]] = self.evaluator.OA_remove_bg()\r\n            runner.batch_metrics[self.prefix[3]] = np.nanmean(self.evaluator.Pixel_Accuracy_Class()[:-1])\r\n            runner.batch_metrics[self.prefix[4]] = np.nanmean(self.evaluator.F1()[:-1])\r\n            runner.batch_metrics[self.prefix[5]] = np.nanmean(self.evaluator.Dice()[:-1])\r\n        else:\r\n            runner.batch_metrics[self.prefix[0]] = np.nanmean(self.evaluator.Intersection_over_Union())\r\n            runner.batch_metrics[self.prefix[1]] = np.nanmean(self.evaluator.Frequency_Weighted_Intersection_over_Union())\r\n            runner.batch_metrics[self.prefix[2]] = self.evaluator.OA()\r\n            runner.batch_metrics[self.prefix[3]] = np.nanmean(self.evaluator.Pixel_Accuracy_Class())\r\n            runner.batch_metrics[self.prefix[4]] = np.nanmean(self.evaluator.F1())\r\n            runner.batch_metrics[self.prefix[5]] = np.nanmean(self.evaluator.Dice())\r\n\r\n    def on_loader_end(self, runner: IRunner):\r\n        if self.remove_background:\r\n            runner.batch_metrics[self.prefix[0]] = np.nanmean(self.evaluator.Intersection_over_Union()[:-1])\r\n            runner.batch_metrics[self.prefix[1]] = np.nanmean(\r\n                self.evaluator.Frequency_Weighted_Intersection_over_Union())\r\n            runner.batch_metrics[self.prefix[2]] = self.evaluator.OA_remove_bg()\r\n            runner.batch_metrics[self.prefix[3]] = np.nanmean(self.evaluator.Pixel_Accuracy_Class()[:-1])\r\n            runner.batch_metrics[self.prefix[4]] = np.nanmean(self.evaluator.F1()[:-1])\r\n            runner.batch_metrics[self.prefix[5]] = np.nanmean(self.evaluator.Dice()[:-1])\r\n        else:\r\n            runner.batch_metrics[self.prefix[0]] = np.nanmean(self.evaluator.Intersection_over_Union())\r\n            runner.batch_metrics[self.prefix[1]] = np.nanmean(\r\n                self.evaluator.Frequency_Weighted_Intersection_over_Union())\r\n            runner.batch_metrics[self.prefix[2]] = self.evaluator.OA()\r\n            runner.batch_metrics[self.prefix[3]] = np.nanmean(self.evaluator.Pixel_Accuracy_Class())\r\n            runner.batch_metrics[self.prefix[4]] = np.nanmean(self.evaluator.F1())\r\n            runner.batch_metrics[self.prefix[5]] = np.nanmean(self.evaluator.Dice())\r\n        iou_per_class = self.evaluator.Intersection_over_Union()\r\n        f1_per_class = self.evaluator.F1()\r\n        if self.class_names is not None:\r\n            assert len(self.class_names) == self.num_classes\r\n            for class_name, class_iou, class_f1 in zip(self.class_names, iou_per_class, f1_per_class):\r\n                runner.loader_metrics['iou_' + class_name] = float(class_iou)\r\n                runner.loader_metrics['F1_' + class_name] = float(class_f1)","reactions":{"url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/comments/714279807/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"WangLibo1995","id":38718224,"node_id":"MDQ6VXNlcjM4NzE4MjI0","avatar_url":"https://avatars.githubusercontent.com/u/38718224?v=4","gravatar_id":"","url":"https://api.github.com/users/WangLibo1995","html_url":"https://github.com/WangLibo1995","followers_url":"https://api.github.com/users/WangLibo1995/followers","following_url":"https://api.github.com/users/WangLibo1995/following{/other_user}","gists_url":"https://api.github.com/users/WangLibo1995/gists{/gist_id}","starred_url":"https://api.github.com/users/WangLibo1995/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/WangLibo1995/subscriptions","organizations_url":"https://api.github.com/users/WangLibo1995/orgs","repos_url":"https://api.github.com/users/WangLibo1995/repos","events_url":"https://api.github.com/users/WangLibo1995/events{/privacy}","received_events_url":"https://api.github.com/users/WangLibo1995/received_events","type":"User","site_admin":false}},{"url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/comments/721346194","html_url":"https://github.com/BloodAxe/pytorch-toolbelt/issues/50#issuecomment-721346194","issue_url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/50","id":721346194,"node_id":"MDEyOklzc3VlQ29tbWVudDcyMTM0NjE5NA==","user":{"login":"BloodAxe","id":532320,"node_id":"MDQ6VXNlcjUzMjMyMA==","avatar_url":"https://avatars.githubusercontent.com/u/532320?v=4","gravatar_id":"","url":"https://api.github.com/users/BloodAxe","html_url":"https://github.com/BloodAxe","followers_url":"https://api.github.com/users/BloodAxe/followers","following_url":"https://api.github.com/users/BloodAxe/following{/other_user}","gists_url":"https://api.github.com/users/BloodAxe/gists{/gist_id}","starred_url":"https://api.github.com/users/BloodAxe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/BloodAxe/subscriptions","organizations_url":"https://api.github.com/users/BloodAxe/orgs","repos_url":"https://api.github.com/users/BloodAxe/repos","events_url":"https://api.github.com/users/BloodAxe/events{/privacy}","received_events_url":"https://api.github.com/users/BloodAxe/received_events","type":"User","site_admin":false},"created_at":"2020-11-03T20:01:47Z","updated_at":"2020-11-03T20:01:47Z","author_association":"OWNER","body":"Do you have any references to papers which state that multi-class IoU computed per-epoch, not per-image?","reactions":{"url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/comments/721346194/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"BloodAxe","id":532320,"node_id":"MDQ6VXNlcjUzMjMyMA==","avatar_url":"https://avatars.githubusercontent.com/u/532320?v=4","gravatar_id":"","url":"https://api.github.com/users/BloodAxe","html_url":"https://github.com/BloodAxe","followers_url":"https://api.github.com/users/BloodAxe/followers","following_url":"https://api.github.com/users/BloodAxe/following{/other_user}","gists_url":"https://api.github.com/users/BloodAxe/gists{/gist_id}","starred_url":"https://api.github.com/users/BloodAxe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/BloodAxe/subscriptions","organizations_url":"https://api.github.com/users/BloodAxe/orgs","repos_url":"https://api.github.com/users/BloodAxe/repos","events_url":"https://api.github.com/users/BloodAxe/events{/privacy}","received_events_url":"https://api.github.com/users/BloodAxe/received_events","type":"User","site_admin":false}},{"url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/comments/721495090","html_url":"https://github.com/BloodAxe/pytorch-toolbelt/issues/50#issuecomment-721495090","issue_url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/50","id":721495090,"node_id":"MDEyOklzc3VlQ29tbWVudDcyMTQ5NTA5MA==","user":{"login":"WangLibo1995","id":38718224,"node_id":"MDQ6VXNlcjM4NzE4MjI0","avatar_url":"https://avatars.githubusercontent.com/u/38718224?v=4","gravatar_id":"","url":"https://api.github.com/users/WangLibo1995","html_url":"https://github.com/WangLibo1995","followers_url":"https://api.github.com/users/WangLibo1995/followers","following_url":"https://api.github.com/users/WangLibo1995/following{/other_user}","gists_url":"https://api.github.com/users/WangLibo1995/gists{/gist_id}","starred_url":"https://api.github.com/users/WangLibo1995/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/WangLibo1995/subscriptions","organizations_url":"https://api.github.com/users/WangLibo1995/orgs","repos_url":"https://api.github.com/users/WangLibo1995/repos","events_url":"https://api.github.com/users/WangLibo1995/events{/privacy}","received_events_url":"https://api.github.com/users/WangLibo1995/received_events","type":"User","site_admin":false},"created_at":"2020-11-04T03:43:33Z","updated_at":"2020-11-04T03:43:33Z","author_association":"NONE","body":"> Do you have any references to papers which state that multi-class IoU computed per-epoch, not per-image?\r\n\r\nIn my experiment, epoch-iou is more closer to paper's iou.  It's not hard to understand. For example,  image A only has a cat, image B only has a dog , they are both 100% predicted correctly. In case of iou-per-image, image A : iou-cat=1, iou-dog=0, image B : iou-cat=0, iou-dog=1, so final iou-cat=0.5, final iou-dog = 0.5. However, in case of iou-per-epoch, final iou-cat and iou-dog are both 1. Now, model predicts perfectly on dog and cat, the iou should be 1. \r\n\r\nFinally, thank you for your excellent work, it helps me a lot in my competition","reactions":{"url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/comments/721495090/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"WangLibo1995","id":38718224,"node_id":"MDQ6VXNlcjM4NzE4MjI0","avatar_url":"https://avatars.githubusercontent.com/u/38718224?v=4","gravatar_id":"","url":"https://api.github.com/users/WangLibo1995","html_url":"https://github.com/WangLibo1995","followers_url":"https://api.github.com/users/WangLibo1995/followers","following_url":"https://api.github.com/users/WangLibo1995/following{/other_user}","gists_url":"https://api.github.com/users/WangLibo1995/gists{/gist_id}","starred_url":"https://api.github.com/users/WangLibo1995/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/WangLibo1995/subscriptions","organizations_url":"https://api.github.com/users/WangLibo1995/orgs","repos_url":"https://api.github.com/users/WangLibo1995/repos","events_url":"https://api.github.com/users/WangLibo1995/events{/privacy}","received_events_url":"https://api.github.com/users/WangLibo1995/received_events","type":"User","site_admin":false}},{"id":6223955778,"node_id":"CE_lADOCntH-84rO-vLzwAAAAFy-gdC","url":"https://api.github.com/repos/BloodAxe/pytorch-toolbelt/issues/events/6223955778","actor":{"login":"BloodAxe","id":532320,"node_id":"MDQ6VXNlcjUzMjMyMA==","avatar_url":"https://avatars.githubusercontent.com/u/532320?v=4","gravatar_id":"","url":"https://api.github.com/users/BloodAxe","html_url":"https://github.com/BloodAxe","followers_url":"https://api.github.com/users/BloodAxe/followers","following_url":"https://api.github.com/users/BloodAxe/following{/other_user}","gists_url":"https://api.github.com/users/BloodAxe/gists{/gist_id}","starred_url":"https://api.github.com/users/BloodAxe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/BloodAxe/subscriptions","organizations_url":"https://api.github.com/users/BloodAxe/orgs","repos_url":"https://api.github.com/users/BloodAxe/repos","events_url":"https://api.github.com/users/BloodAxe/events{/privacy}","received_events_url":"https://api.github.com/users/BloodAxe/received_events","type":"User","site_admin":false},"event":"closed","commit_id":null,"commit_url":null,"created_at":"2022-03-11T10:40:27Z","state_reason":null,"performed_via_github_app":null}]