[{"url":"https://api.github.com/repos/kLabUM/rrcf/issues/comments/759314340","html_url":"https://github.com/kLabUM/rrcf/issues/81#issuecomment-759314340","issue_url":"https://api.github.com/repos/kLabUM/rrcf/issues/81","id":759314340,"node_id":"MDEyOklzc3VlQ29tbWVudDc1OTMxNDM0MA==","user":{"login":"yasirroni","id":48709672,"node_id":"MDQ6VXNlcjQ4NzA5Njcy","avatar_url":"https://avatars.githubusercontent.com/u/48709672?v=4","gravatar_id":"","url":"https://api.github.com/users/yasirroni","html_url":"https://github.com/yasirroni","followers_url":"https://api.github.com/users/yasirroni/followers","following_url":"https://api.github.com/users/yasirroni/following{/other_user}","gists_url":"https://api.github.com/users/yasirroni/gists{/gist_id}","starred_url":"https://api.github.com/users/yasirroni/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yasirroni/subscriptions","organizations_url":"https://api.github.com/users/yasirroni/orgs","repos_url":"https://api.github.com/users/yasirroni/repos","events_url":"https://api.github.com/users/yasirroni/events{/privacy}","received_events_url":"https://api.github.com/users/yasirroni/received_events","type":"User","site_admin":false},"created_at":"2021-01-13T09:13:52Z","updated_at":"2021-01-13T09:16:52Z","author_association":"NONE","body":"In my case, static model with static threshold is prefered. Here is the code:\r\n\r\n```\r\n# Set tree parameters\r\nNUM_TREES = 100 # around 100 trees or more is recommended\r\nSHINGLE_SIZE = 10 # number of data treated as single data\r\nNUM_SHINGLE = n_points - SHINGLE_SIZE + 1 # number of shingle\r\nTREE_SIZE = NUM_SHINGLE # number of points in the tree for fifo, minutes in a day are 1440\r\nSPROUT_PROBABILITY = 0.8 # the probability of leaf grow on single tree independently, lower means better generality\r\n\r\nTREE_FULL_FLAG = False # flag to mark tree status\r\n\r\n# Create a forest of empty trees\r\nforest = [None] * NUM_TREES\r\nfor i in range(NUM_TREES):\r\n    tree = rrcf.RCTree()\r\n    forest[i] = tree\r\n\r\n# Use the \"shingle\" generator to create rolling window\r\npoints = rrcf.shingle(X, size=SHINGLE_SIZE)\r\n\r\n# transpose\r\ndef shingle_transpose(shingle):\r\n    for val in shingle:\r\n        yield val.T.flatten()\r\n\r\npoints = shingle_transpose(points)\r\n\r\n# create a dict to store anomaly score of each point\r\navg_codisp = pd.Series(0.0, index=np.arange(NUM_SHINGLE))\r\n\r\n# create a dict to store anomaly score of each point\r\navg_codisp = pd.Series(0.0, index=np.arange(NUM_SHINGLE))\r\n\r\n# for each shingle...\r\nfor index, point in enumerate(points):\r\n    # record number of tree that save the shingle\r\n    freq = 0\r\n    # for each tree in the forest...\r\n    for tree in forest:\r\n        # roll dice to determine point become a leave or not\r\n        if np.random.random() <= SPROUT_PROBABILITY:\r\n            # insert the new point into the tree\r\n            tree.insert_point(point, index=index)\r\n            \r\n            # add 1 to freq record\r\n            freq += 1\r\n            \r\n        # if tree already full\r\n        if len(tree.leaves) == TREE_SIZE: \r\n            TREE_FULL_FLAG = True\r\n            \r\n    # if no tree save current shingle\r\n    if freq == 0:\r\n        # chose any tree\r\n        tree = np.random.choice(forest)\r\n\r\n        # insert the new point into the tree\r\n        tree.insert_point(point, index=index)\r\n        \r\n        # if tree already full\r\n        if len(tree.leaves) == TREE_SIZE: # if TREE_SIZE\r\n            TREE_FULL_FLAG = True\r\n    \r\n    # if any tree is above permitted size...\r\n    if TREE_FULL_FLAG:\r\n        break\r\n\r\n# Compute codisp\r\nfreq = np.zeros(index + 1)\r\nfor tree in forest:\r\n    codisp = pd.Series({leaf : tree.codisp(leaf) for leaf in tree.leaves})\r\n    avg_codisp[codisp.index] += codisp\r\n    np.add.at(freq, codisp.index.values, 1)\r\n\r\nfor i in range(index + 1):\r\n    if freq[i] >= 1:\r\n        avg_codisp[i] = avg_codisp[i] / freq[i]\r\n        \r\n# After any tree is above permitted size and if points haven't empty, for each shingle...\r\nfor point in points:\r\n    # Continue index counter\r\n    index += 1\r\n    \r\n    codisp = 0\r\n    freq = 0\r\n    for tree in forest:\r\n        # Roll dice to plant or not\r\n        if np.random.random() <= SPROUT_PROBABILITY:\r\n            # Check if leave can sprout\r\n            if len(tree.leaves) == TREE_SIZE:\r\n                # Drop the oldest point (FIFO)\r\n                tree.forget_point(min(tree.leaves.keys()))\r\n\r\n            # Insert the new point into the tree\r\n            tree.insert_point(point, index=index)\r\n            \r\n            codisp += tree.codisp(index)\r\n            freq += 1\r\n\r\n    if freq == 0: # leaf not sprouted at any tree\r\n        tree = np.random.choice(forest)\r\n        # Check if leave can sprout\r\n        if len(tree.leaves) == TREE_SIZE:\r\n            # Drop the oldest point (FIFO)\r\n            tree.forget_point(min(tree.leaves.keys()))\r\n\r\n        # Insert the new point into the tree\r\n        tree.insert_point(point, index=index)\r\n\r\n        codisp += tree.codisp(index)\r\n        freq += 1\r\n        \r\n    avg_codisp[index] = codisp / freq\r\n\r\nplt.plot(avg_codisp)\r\nplt.show()\r\n```\r\n\r\nThen, I will double (based on your case) the maximum value of train CoDisp as the threshold, and you can use insert and delete the new point in testing or deployment.","reactions":{"url":"https://api.github.com/repos/kLabUM/rrcf/issues/comments/759314340/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"yasirroni","id":48709672,"node_id":"MDQ6VXNlcjQ4NzA5Njcy","avatar_url":"https://avatars.githubusercontent.com/u/48709672?v=4","gravatar_id":"","url":"https://api.github.com/users/yasirroni","html_url":"https://github.com/yasirroni","followers_url":"https://api.github.com/users/yasirroni/followers","following_url":"https://api.github.com/users/yasirroni/following{/other_user}","gists_url":"https://api.github.com/users/yasirroni/gists{/gist_id}","starred_url":"https://api.github.com/users/yasirroni/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yasirroni/subscriptions","organizations_url":"https://api.github.com/users/yasirroni/orgs","repos_url":"https://api.github.com/users/yasirroni/repos","events_url":"https://api.github.com/users/yasirroni/events{/privacy}","received_events_url":"https://api.github.com/users/yasirroni/received_events","type":"User","site_admin":false}}]