{"url":"https://api.github.com/repos/logictensornetworks/logictensornetworks/issues/27","repository_url":"https://api.github.com/repos/logictensornetworks/logictensornetworks","labels_url":"https://api.github.com/repos/logictensornetworks/logictensornetworks/issues/27/labels{/name}","comments_url":"https://api.github.com/repos/logictensornetworks/logictensornetworks/issues/27/comments","events_url":"https://api.github.com/repos/logictensornetworks/logictensornetworks/issues/27/events","html_url":"https://github.com/logictensornetworks/logictensornetworks/issues/27","id":1285206719,"node_id":"I_kwDOCFoAF85MmrK_","number":27,"title":"Allow to permanently `diag` variables","user":{"login":"sbadredd","id":43364643,"node_id":"MDQ6VXNlcjQzMzY0NjQz","avatar_url":"https://avatars.githubusercontent.com/u/43364643?v=4","gravatar_id":"","url":"https://api.github.com/users/sbadredd","html_url":"https://github.com/sbadredd","followers_url":"https://api.github.com/users/sbadredd/followers","following_url":"https://api.github.com/users/sbadredd/following{/other_user}","gists_url":"https://api.github.com/users/sbadredd/gists{/gist_id}","starred_url":"https://api.github.com/users/sbadredd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sbadredd/subscriptions","organizations_url":"https://api.github.com/users/sbadredd/orgs","repos_url":"https://api.github.com/users/sbadredd/repos","events_url":"https://api.github.com/users/sbadredd/events{/privacy}","received_events_url":"https://api.github.com/users/sbadredd/received_events","type":"User","site_admin":false},"labels":[{"id":986963946,"node_id":"MDU6TGFiZWw5ODY5NjM5NDY=","url":"https://api.github.com/repos/logictensornetworks/logictensornetworks/labels/enhancement","name":"enhancement","color":"a2eeef","default":true,"description":"New feature or request"}],"state":"open","locked":false,"assignee":{"login":"sbadredd","id":43364643,"node_id":"MDQ6VXNlcjQzMzY0NjQz","avatar_url":"https://avatars.githubusercontent.com/u/43364643?v=4","gravatar_id":"","url":"https://api.github.com/users/sbadredd","html_url":"https://github.com/sbadredd","followers_url":"https://api.github.com/users/sbadredd/followers","following_url":"https://api.github.com/users/sbadredd/following{/other_user}","gists_url":"https://api.github.com/users/sbadredd/gists{/gist_id}","starred_url":"https://api.github.com/users/sbadredd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sbadredd/subscriptions","organizations_url":"https://api.github.com/users/sbadredd/orgs","repos_url":"https://api.github.com/users/sbadredd/repos","events_url":"https://api.github.com/users/sbadredd/events{/privacy}","received_events_url":"https://api.github.com/users/sbadredd/received_events","type":"User","site_admin":false},"assignees":[{"login":"sbadredd","id":43364643,"node_id":"MDQ6VXNlcjQzMzY0NjQz","avatar_url":"https://avatars.githubusercontent.com/u/43364643?v=4","gravatar_id":"","url":"https://api.github.com/users/sbadredd","html_url":"https://github.com/sbadredd","followers_url":"https://api.github.com/users/sbadredd/followers","following_url":"https://api.github.com/users/sbadredd/following{/other_user}","gists_url":"https://api.github.com/users/sbadredd/gists{/gist_id}","starred_url":"https://api.github.com/users/sbadredd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sbadredd/subscriptions","organizations_url":"https://api.github.com/users/sbadredd/orgs","repos_url":"https://api.github.com/users/sbadredd/repos","events_url":"https://api.github.com/users/sbadredd/events{/privacy}","received_events_url":"https://api.github.com/users/sbadredd/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2022-06-27T04:10:30Z","updated_at":"2022-06-27T04:10:31Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"### Diagonal quantification\r\n\r\nGiven 2 (or more) variables, `ltn.diag` allows to express statements about specific pairs (or tuples) of the variables, such that the i-th tuple contains the i-th instances of the variables.\r\n\r\nIn simplified pseudo-code, the usual quantification would compute:\r\n```python\r\nfor x_i in x:\r\n    for y_j in y:\r\n        results.append(P(x_i,y_j))\r\naggregate(results)\r\n```\r\nIn contrast, diagonal quantification would compute:\r\n```python\r\nfor x_i, y_i in zip(x,y):\r\n    results.append(P(x_i,y_i))\r\naggregate(results)\r\n```\r\n\r\nIn LTN code, given two variables `x1` and `x2`, we use diagonal quantification as follows:\r\n```python\r\nx1 = ltn.Variable(\"x1\",np.rand(10,2)) # 10 values in R^2\r\nx2 = ltn.Variable(\"x2\",np.rand(10,2)) # 10 values in R^2\r\nP = ltn.Predicate(...)\r\nP([x1,x2]) # -> returns 10x10 values\r\nltn.diag(x1,x2)\r\nP([x1,x2]) # -> returns only 10 \"zipped\" values\r\nltn.undiag(x1,x2)\r\nP([x1,x2]) # -> returns 10x10 values\r\n```\r\n\r\nSee also the [second tutorial](https://nbviewer.org/github/logictensornetworks/logictensornetworks/blob/master/tutorials/2-grounding_connectives.ipynb).\r\n\r\n### Issue\r\nAt the moment, every quantifier automatically calls `ltn.undiag` after the aggregation is performed, so that the variables keep their normal behavior outside of the formula. Therefore, it is recommended to use `ltn.diag` only in quantified formulas as follows.\r\n```python\r\nForall(ltn.diag(x1,x2), P([x1,x2])) # -> returns an aggregate of only 10 \"zipped values\"\r\nForall((x1,x2), P([x1,x2])) # -> returns an aggregate of 10x10 values\r\n```\r\n\r\nHowever, there are cases where the second (normal) behavior for the two variables `x1` and `x2` is never useful. Some variables are designed from the start to be used as paired, zipped variables. In that case, forcing the user to re-use the keyword `ltn.diag` at every quantification is redundant.\r\n\r\n### Proposition\r\nDefine a new keyword `ltn.diag_lock` which can be used once at the instantiation of the variables, and will force the diag behavior in every subsequent quantification. `ltn.undiag` will not be called after an aggregation.\r\n```python\r\nx1 = ltn.Variable(\"x1\",np.rand(10,2)) # 10 values in R^2\r\nx2 = ltn.Variable(\"x2\",np.rand(10,2)) # 10 values in R^2\r\nltn.diag_lock([x1,x2])\r\nP([x1,x2]) # -> returns only 10 \"zipped\" values\r\nForall((x1,x2), P([x1,x2])) # -> returns an aggregate of only 10 \"zipped values\"\r\nForall((x1,x2), P([x1,x2])) # -> still returns an aggregate of only 10 \"zipped values\"\r\n```\r\nPossibly, we can add an `ltn.undiag_lock` too.\r\n\r\nThe implementation details are left to define but shouldn't change the rest of the API.","closed_by":null,"reactions":{"url":"https://api.github.com/repos/logictensornetworks/logictensornetworks/issues/27/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/logictensornetworks/logictensornetworks/issues/27/timeline","performed_via_github_app":null,"state_reason":null}