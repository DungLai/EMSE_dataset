{"url":"https://api.github.com/repos/1adrianb/pytorch-estimate-flops/issues/10","repository_url":"https://api.github.com/repos/1adrianb/pytorch-estimate-flops","labels_url":"https://api.github.com/repos/1adrianb/pytorch-estimate-flops/issues/10/labels{/name}","comments_url":"https://api.github.com/repos/1adrianb/pytorch-estimate-flops/issues/10/comments","events_url":"https://api.github.com/repos/1adrianb/pytorch-estimate-flops/issues/10/events","html_url":"https://github.com/1adrianb/pytorch-estimate-flops/issues/10","id":939548993,"node_id":"MDU6SXNzdWU5Mzk1NDg5OTM=","number":10,"title":"IndexError: tuple index out of range ERROR IN CALCULATING FLOPS","user":{"login":"IAM-P-LP","id":54659792,"node_id":"MDQ6VXNlcjU0NjU5Nzky","avatar_url":"https://avatars.githubusercontent.com/u/54659792?v=4","gravatar_id":"","url":"https://api.github.com/users/IAM-P-LP","html_url":"https://github.com/IAM-P-LP","followers_url":"https://api.github.com/users/IAM-P-LP/followers","following_url":"https://api.github.com/users/IAM-P-LP/following{/other_user}","gists_url":"https://api.github.com/users/IAM-P-LP/gists{/gist_id}","starred_url":"https://api.github.com/users/IAM-P-LP/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IAM-P-LP/subscriptions","organizations_url":"https://api.github.com/users/IAM-P-LP/orgs","repos_url":"https://api.github.com/users/IAM-P-LP/repos","events_url":"https://api.github.com/users/IAM-P-LP/events{/privacy}","received_events_url":"https://api.github.com/users/IAM-P-LP/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-07-08T07:14:53Z","updated_at":"2022-12-22T22:15:26Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"Hi ,\r\nI am using the below code.\r\n\r\nimport torch\r\nimport torch.nn as nn\r\nimport torch.nn.functional as F\r\n\r\nfrom pthflops import count_ops\r\n\r\n\r\n\r\nimport torchvision\r\nclass BasicConv2d(nn.Module):\r\n\r\n    def __init__(self, in_channels, out_channels, **kwargs):\r\n        super(BasicConv2d, self).__init__()\r\n        self.conv = nn.Conv2d(in_channels, out_channels, bias=False, **kwargs)\r\n        self.bn = nn.BatchNorm2d(out_channels, eps=1e-5)\r\n\r\n    def forward(self, x):\r\n        x = self.conv(x)\r\n        x = self.bn(x)\r\n        return F.relu(x, inplace=True)\r\n\r\n\r\nclass Inception(nn.Module):\r\n\r\n  def __init__(self):\r\n    super(Inception, self).__init__()\r\n    self.branch1x1 = BasicConv2d(128, 32, kernel_size=1, padding=0)\r\n    self.branch1x1_2 = BasicConv2d(128, 32, kernel_size=1, padding=0)\r\n    self.branch3x3_reduce = BasicConv2d(128, 24, kernel_size=1, padding=0)\r\n    self.branch3x3 = BasicConv2d(24, 32, kernel_size=3, padding=1)\r\n    self.branch3x3_reduce_2 = BasicConv2d(128, 24, kernel_size=1, padding=0)\r\n    self.branch3x3_2 = BasicConv2d(24, 32, kernel_size=3, padding=1)\r\n    self.branch3x3_3 = BasicConv2d(32, 32, kernel_size=3, padding=1)\r\n\r\n  def forward(self, x):\r\n    branch1x1 = self.branch1x1(x)\r\n\r\n    branch1x1_pool = F.avg_pool2d(x, kernel_size=3, stride=1, padding=1)\r\n    branch1x1_2 = self.branch1x1_2(branch1x1_pool)\r\n\r\n    branch3x3_reduce = self.branch3x3_reduce(x)\r\n    branch3x3 = self.branch3x3(branch3x3_reduce)\r\n\r\n    branch3x3_reduce_2 = self.branch3x3_reduce_2(x)\r\n    branch3x3_2 = self.branch3x3_2(branch3x3_reduce_2)\r\n    branch3x3_3 = self.branch3x3_3(branch3x3_2)\r\n\r\n    outputs = [branch1x1, branch1x1_2, branch3x3, branch3x3_3]\r\n    return torch.cat(outputs, 1)\r\n\r\n\r\nclass CRelu(nn.Module):\r\n\r\n  def __init__(self, in_channels, out_channels, **kwargs):\r\n    super(CRelu, self).__init__()\r\n    self.conv = nn.Conv2d(in_channels, out_channels, bias=False, **kwargs)\r\n    self.bn = nn.BatchNorm2d(out_channels, eps=1e-5)\r\n\r\n  def forward(self, x):\r\n    x = self.conv(x)\r\n    x = self.bn(x)\r\n    x = torch.cat([x, -x], 1)\r\n    x = F.relu(x, inplace=True)\r\n    return x\r\n\r\n\r\nclass FaceBoxesNet(nn.Module):\r\n\r\n    def __init__(self):\r\n        super(FaceBoxesNet, self).__init__()\r\n\r\n        self.conv1 = CRelu(3, 24, kernel_size=7, stride=4, padding=3)\r\n        self.conv2 = CRelu(48, 64, kernel_size=5, stride=2, padding=2)\r\n\r\n        self.inception1 = Inception()\r\n        self.inception2 = Inception()\r\n        self.inception3 = Inception()\r\n\r\n        self.conv3_1 = BasicConv2d(128, 128, kernel_size=1, stride=1, padding=0)\r\n        self.conv3_2 = BasicConv2d(128, 256, kernel_size=3, stride=2, padding=1)\r\n\r\n        self.conv4_1 = BasicConv2d(256, 128, kernel_size=1, stride=1, padding=0)\r\n        self.conv4_2 = BasicConv2d(128, 256, kernel_size=3, stride=2, padding=1)\r\n\r\n        self.loc, self.conf = self.multibox(2)\r\n        self.softmax = nn.Softmax(dim=-1)\r\n    \r\n    def multibox(self, num_classes):\r\n        loc_layers = []\r\n        conf_layers = []\r\n        loc_layers += [nn.Conv2d(128, 21 * 4, kernel_size=3, padding=1)]\r\n        conf_layers += [nn.Conv2d(128, 21 * num_classes, kernel_size=3, padding=1)]\r\n        loc_layers += [nn.Conv2d(256, 1 * 4, kernel_size=3, padding=1)]\r\n        conf_layers += [nn.Conv2d(256, 1 * num_classes, kernel_size=3, padding=1)]\r\n        loc_layers += [nn.Conv2d(256, 1 * 4, kernel_size=3, padding=1)]\r\n        conf_layers += [nn.Conv2d(256, 1 * num_classes, kernel_size=3, padding=1)]\r\n        return nn.Sequential(*loc_layers), nn.Sequential(*conf_layers)\r\n\r\n    def forward(self, x):\r\n        detection_sources = list()\r\n        loc = list()\r\n        conf = list()\r\n\r\n        x = self.conv1(x)\r\n        x = F.max_pool2d(x, kernel_size=3, stride=2, padding=1)\r\n        x = self.conv2(x)\r\n        x = F.max_pool2d(x, kernel_size=3, stride=2, padding=1)\r\n        x = self.inception1(x)\r\n        x = self.inception2(x)\r\n        x = self.inception3(x)\r\n        detection_sources.append(x)\r\n\r\n        x = self.conv3_1(x)\r\n        x = self.conv3_2(x)\r\n        detection_sources.append(x)\r\n\r\n        x = self.conv4_1(x)\r\n        x = self.conv4_2(x)\r\n        detection_sources.append(x)\r\n\r\n        for (x, l, c) in zip(detection_sources, self.loc, self.conf):\r\n            loc.append(l(x).permute(0, 2, 3, 1).contiguous())\r\n            conf.append(c(x).permute(0, 2, 3, 1).contiguous())\r\n\r\n        loc = torch.cat([o.view(o.size(0), -1) for o in loc], 1)\r\n        conf = torch.cat([o.view(o.size(0), -1) for o in conf], 1)\r\n\r\n        output = (loc.view(loc.size(0), -1, 4), self.softmax(conf.view(-1, 2)))\r\n\r\n        return output\r\n\r\n\r\nmodel =FaceBoxesNet()\r\ndata = torch.rand(1,3,224,224)\r\n\r\ncount_ops(model,data)\r\n\r\n\r\n\r\nThe error I obtained is :\r\nreturn torch.max_pool2d(input, kernel_size, stride, padding, dilation, ceil_mode)\r\nTraceback (most recent call last):\r\n  File \"pthflops_CALC_FACEBOXES.py\", line 136, in <module>\r\n    count_ops(model,data, ignore_layers=['FaceBoxesNet'])\r\n  File \"/home/Documents/PYTORCH_CPP/PYTORCH_CPP/lib/python3.8/site-packages/pthflops/__init__.py\", line 15, in count_ops\r\n    return count_ops_fx(\r\n  File \"/home/Documents/PYTORCH_CPP/PYTORCH_CPP/lib/python3.8/site-packages/pthflops/ops_fx.py\", line 255, in count_ops_fx\r\n    tracer.run(input)\r\n  File \"/home/Documents/PYTORCH_CPP/PYTORCH_CPP/lib/python3.8/site-packages/torch/fx/interpreter.py\", line 116, in run\r\n    self.env[node] = self.run_node(node)\r\n  File \"/home/Documents/PYTORCH_CPP/PYTORCH_CPP/lib/python3.8/site-packages/pthflops/ops_fx.py\", line 195, in run_node\r\n    self.parameters[n] = return_val[2]\r\n**IndexError: tuple index out of range**\r\n\r\n","closed_by":null,"reactions":{"url":"https://api.github.com/repos/1adrianb/pytorch-estimate-flops/issues/10/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/1adrianb/pytorch-estimate-flops/issues/10/timeline","performed_via_github_app":null,"state_reason":null}