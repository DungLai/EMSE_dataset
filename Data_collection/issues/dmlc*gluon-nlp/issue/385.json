{"url":"https://api.github.com/repos/dmlc/gluon-nlp/issues/385","repository_url":"https://api.github.com/repos/dmlc/gluon-nlp","labels_url":"https://api.github.com/repos/dmlc/gluon-nlp/issues/385/labels{/name}","comments_url":"https://api.github.com/repos/dmlc/gluon-nlp/issues/385/comments","events_url":"https://api.github.com/repos/dmlc/gluon-nlp/issues/385/events","html_url":"https://github.com/dmlc/gluon-nlp/issues/385","id":374631033,"node_id":"MDU6SXNzdWUzNzQ2MzEwMzM=","number":385,"title":"Making CandidateSamplers Blocks","user":{"login":"leezu","id":946903,"node_id":"MDQ6VXNlcjk0NjkwMw==","avatar_url":"https://avatars.githubusercontent.com/u/946903?v=4","gravatar_id":"","url":"https://api.github.com/users/leezu","html_url":"https://github.com/leezu","followers_url":"https://api.github.com/users/leezu/followers","following_url":"https://api.github.com/users/leezu/following{/other_user}","gists_url":"https://api.github.com/users/leezu/gists{/gist_id}","starred_url":"https://api.github.com/users/leezu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/leezu/subscriptions","organizations_url":"https://api.github.com/users/leezu/orgs","repos_url":"https://api.github.com/users/leezu/repos","events_url":"https://api.github.com/users/leezu/events{/privacy}","received_events_url":"https://api.github.com/users/leezu/received_events","type":"User","site_admin":false},"labels":[{"id":890393503,"node_id":"MDU6TGFiZWw4OTAzOTM1MDM=","url":"https://api.github.com/repos/dmlc/gluon-nlp/labels/enhancement","name":"enhancement","color":"135caf","default":true,"description":"New feature or request"},{"id":963101581,"node_id":"MDU6TGFiZWw5NjMxMDE1ODE=","url":"https://api.github.com/repos/dmlc/gluon-nlp/labels/discussion","name":"discussion","color":"c5def5","default":false,"description":""},{"id":994710322,"node_id":"MDU6TGFiZWw5OTQ3MTAzMjI=","url":"https://api.github.com/repos/dmlc/gluon-nlp/labels/API%20change","name":"API change","color":"d93f0b","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2018-10-27T10:31:33Z","updated_at":"2018-11-22T20:17:28Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Currently, `nlp.data.CandidateSampler` are not Blocks but are completely based on imperative API. This brings some overhead. `UnigramCandidateSampler` (the so far only supported CandidateSampler) can easily be changed to a HybridBlock.\r\n\r\nDue to lack of support for specifying the output shape of F.random.uniform via NDarray (/Symbol) and lack of  F.random.uniform_like, changing to HybridBlock would require fixing the shape when constructing the Sampler.\r\n\r\nLet's discuss if that is reasonable or if / when we can work around it.\r\n\r\n``` diff\r\nmodified   gluonnlp/data/candidate_sampler.py\r\n@@ -20,10 +20,13 @@\r\n \r\n __all__ = ['CandidateSampler', 'UnigramCandidateSampler']\r\n \r\n+import functools\r\n+import operator\r\n+\r\n import mxnet as mx\r\n \r\n \r\n-class CandidateSampler(object):\r\n+class CandidateSampler(mx.gluon.Block):\r\n     \"\"\"Abstract Candidate Sampler\r\n \r\n     After initializing one of the concrete candidate sample implementations,\r\n@@ -35,7 +38,7 @@ class CandidateSampler(object):\r\n         raise NotImplementedError\r\n \r\n \r\n-class UnigramCandidateSampler(CandidateSampler):\r\n+class UnigramCandidateSampler(mx.gluon.HybridBlock):\r\n     \"\"\"Unigram Candidate Sampler\r\n \r\n     Draw random samples from a unigram distribution with specified weights\r\n@@ -46,22 +49,27 @@ class UnigramCandidateSampler(CandidateSampler):\r\n     weights : mx.nd.NDArray\r\n         Unnormalized class probabilities. Samples are drawn and returned on the\r\n         same context as weights.context.\r\n+    shape : int or tuple of int\r\n+        Shape of data to be sampled.\r\n \r\n     \"\"\"\r\n \r\n-    def __init__(self, weights):\r\n+    def __init__(self, weights, shape):\r\n+        super(UnigramCandidateSampler, self).__init__()\r\n+        self._shape = shape\r\n+\r\n         self._context = weights.context\r\n         self.N = weights.size\r\n         total_weights = weights.sum()\r\n-        self.prob = (weights * self.N / total_weights).asnumpy().tolist()\r\n-        self.alias = [0] * self.N\r\n+        prob = (weights * self.N / total_weights).asnumpy().tolist()\r\n+        alias = [0] * self.N\r\n \r\n         # sort the data into the outcomes with probabilities\r\n         # that are high and low than 1/N.\r\n         low = []\r\n         high = []\r\n         for i in range(self.N):\r\n-            if self.prob[i] < 1.0:\r\n+            if prob[i] < 1.0:\r\n                 low.append(i)\r\n             else:\r\n                 high.append(i)\r\n@@ -71,23 +79,25 @@ class UnigramCandidateSampler(CandidateSampler):\r\n             l = low.pop()\r\n             h = high.pop()\r\n \r\n-            self.alias[l] = h\r\n-            self.prob[h] = self.prob[h] - (1.0 - self.prob[l])\r\n+            alias[l] = h\r\n+            prob[h] = prob[h] - (1.0 - prob[l])\r\n \r\n-            if self.prob[h] < 1.0:\r\n+            if prob[h] < 1.0:\r\n                 low.append(h)\r\n             else:\r\n                 high.append(h)\r\n \r\n         for i in low + high:\r\n-            self.prob[i] = 1\r\n-            self.alias[i] = i\r\n+            prob[i] = 1\r\n+            alias[i] = i\r\n \r\n-        # convert to ndarrays\r\n-        self.prob = mx.nd.array(self.prob, ctx=self._context)\r\n-        self.alias = mx.nd.array(self.alias, ctx=self._context)\r\n+        # store\r\n+        prob = mx.nd.array(prob)\r\n+        alias = mx.nd.array(alias)\r\n+        self.prob = self.params.get_constant('prob', prob)\r\n+        self.alias = self.params.get_constant('alias', alias)\r\n \r\n-    def __call__(self, shape):\r\n+    def hybrid_forward(self, F, ctx_selector, prob, alias):\r\n         \"\"\"Draw samples from uniform distribution and return sampled candidates.\r\n \r\n         Parameters\r\n@@ -100,14 +110,18 @@ class UnigramCandidateSampler(CandidateSampler):\r\n         samples: NDArray\r\n             The sampled candidate classes.\r\n         \"\"\"\r\n-        idx = mx.nd.random.uniform(low=0, high=self.N, shape=shape,\r\n-                                   ctx=self._context,\r\n-                                   dtype='float64').floor().astype('float32')\r\n-        prob = self.prob[idx]\r\n-        alias = self.alias[idx]\r\n-        where = mx.nd.random.uniform(shape=shape, ctx=self._context) < prob\r\n+        flat_shape = functools.reduce(operator.mul, self._shape)\r\n+        idx = F.random.uniform(\r\n+            low=0,\r\n+            high=self.N,\r\n+            shape=flat_shape,\r\n+            ctx=self._context,\r\n+            dtype='float64').floor().astype('float32')\r\n+        prob = F.gather_nd(prob, idx.reshape((1, -1)))\r\n+        alias = F.gather_nd(alias, idx.reshape((1, -1)))\r\n+        where = F.random.uniform(shape=flat_shape, ctx=self._context) < prob\r\n         hit = idx * where\r\n         alt = alias * (1 - where)\r\n-        candidates = hit + alt\r\n+        candidates = (hit + alt).reshape(self._shape)\r\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/dmlc/gluon-nlp/issues/385/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/dmlc/gluon-nlp/issues/385/timeline","performed_via_github_app":null,"state_reason":null}