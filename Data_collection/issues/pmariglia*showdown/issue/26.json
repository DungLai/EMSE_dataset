{"url":"https://api.github.com/repos/pmariglia/showdown/issues/26","repository_url":"https://api.github.com/repos/pmariglia/showdown","labels_url":"https://api.github.com/repos/pmariglia/showdown/issues/26/labels{/name}","comments_url":"https://api.github.com/repos/pmariglia/showdown/issues/26/comments","events_url":"https://api.github.com/repos/pmariglia/showdown/issues/26/events","html_url":"https://github.com/pmariglia/showdown/issues/26","id":543990256,"node_id":"MDU6SXNzdWU1NDM5OTAyNTY=","number":26,"title":"trying to calculate the maximum damage each mon deal to the opponent","user":{"login":"mancho1987","id":59088002,"node_id":"MDQ6VXNlcjU5MDg4MDAy","avatar_url":"https://avatars.githubusercontent.com/u/59088002?v=4","gravatar_id":"","url":"https://api.github.com/users/mancho1987","html_url":"https://github.com/mancho1987","followers_url":"https://api.github.com/users/mancho1987/followers","following_url":"https://api.github.com/users/mancho1987/following{/other_user}","gists_url":"https://api.github.com/users/mancho1987/gists{/gist_id}","starred_url":"https://api.github.com/users/mancho1987/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mancho1987/subscriptions","organizations_url":"https://api.github.com/users/mancho1987/orgs","repos_url":"https://api.github.com/users/mancho1987/repos","events_url":"https://api.github.com/users/mancho1987/events{/privacy}","received_events_url":"https://api.github.com/users/mancho1987/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2019-12-30T19:44:08Z","updated_at":"2020-01-04T16:09:51Z","closed_at":"2020-01-04T16:09:38Z","author_association":"NONE","active_lock_reason":null,"body":"This is the code I have. Please excuse how bad it is, I am just starting and I am learning by reading your code. \r\n\r\n`\r\ndef find_most_damage_move(state, pkmn, opponent_pokemon):\r\n\r\n   #Here I was trying to make a switch before getting all state options, as mentioned in the previous message. I realize this way to do it doesn't work. \r\n\r\n    poke = state.self.active\r\n    state.self.active = pkmn\r\n\r\n    my_options, opponent_options = state.get_all_options()\r\n    moves = []\r\n    switches = []\r\n    for option in my_options:\r\n        if option.startswith(constants.SWITCH_STRING + \" \"):\r\n            switches.append(option)\r\n        else:\r\n            moves.append(option)\r\n\r\n    conditions = {\r\n        constants.REFLECT: state.opponent.side_conditions[constants.REFLECT],\r\n        constants.LIGHT_SCREEN: state.opponent.side_conditions[constants.LIGHT_SCREEN],\r\n        constants.AURORA_VEIL: state.opponent.side_conditions[constants.AURORA_VEIL],\r\n        constants.WEATHER: state.weather,\r\n        constants.TERRAIN: state.field\r\n    }\r\n    most_damage = -1\r\n    \r\n    #Here I was also trying to do for move in pkmn.moves:, which also didn't work. I need to be able to get here the 4 moves of \r\n    #the current pokemon I am analyzing, in order to get the maximum damage it can inflict to the current opponent pokemon.\r\n    for move in moves:\r\n        move_dict = all_move_json[move]\r\n        attacking_move = update_attacking_move(\r\n            pkmn,\r\n            opponent_pokemon,\r\n            move_dict,\r\n            {},\r\n            False,\r\n            state.weather\r\n        )\r\n        damage_amounts = calculate_damage(pkmn, opponent_pokemon, attacking_move, conditions=conditions)\r\n        damage = damage_amounts[0] if damage_amounts else 0\r\n\r\n        if damage > most_damage:\r\n            most_damage = damage\r\n            \r\n    #this is just what I was trying to switch back the pokemon to the active spot.  \r\n    \r\n    state.self.active = poke\r\n\r\n    return round(most_damage)\r\n\r\n#I also need to calculate the maximum damage each opponent pokemon can inflict on each of the bot's\r\n\r\ndef find_most_damage_move_opponent(state, pkmn, opponent_pokemon):\r\n\r\n\r\n    poke = state.opponent.active\r\n    state.opponent.active = pkmn\r\n\r\n    my_options, opponent_options = state.get_all_options()\r\n    moves = []\r\n    switches = []\r\n    for option in opponent_options:\r\n        if option.startswith(constants.SWITCH_STRING + \" \"):\r\n            switches.append(option)\r\n        else:\r\n            moves.append(option)\r\n\r\n    conditions = {\r\n        constants.REFLECT: state.opponent.side_conditions[constants.REFLECT],\r\n        constants.LIGHT_SCREEN: state.opponent.side_conditions[constants.LIGHT_SCREEN],\r\n        constants.AURORA_VEIL: state.opponent.side_conditions[constants.AURORA_VEIL],\r\n        constants.WEATHER: state.weather,\r\n        constants.TERRAIN: state.field\r\n    }\r\n    most_damage = -1\r\n   \r\n    for move in moves:\r\n        move_dict = all_move_json[move]\r\n        attacking_move = update_attacking_move(\r\n            pkmn,\r\n            opponent_pokemon,\r\n            move_dict,\r\n            {},\r\n            False,\r\n            state.weather\r\n        )\r\n        damage_amounts = calculate_damage(pkmn, opponent_pokemon, attacking_move, conditions=conditions)\r\n        damage = damage_amounts[0] if damage_amounts else 0\r\n\r\n        if damage > most_damage:\r\n          \r\n            most_damage = damage\r\n    state.opponent.active = poke\r\n\r\n    return round(most_damage)\r\n\r\n#Here is how I count how many opponent pokemon each of the bot's kills in one hit given their #current hp and the current conditions of the state. \r\n\r\ndef how_many_each_sweeps(state, user_pkmn):\r\n\r\n    count = 0\r\n    #I was also trying to make it with this filter, but was not working, I think the wrong part was the x.is_alive()\r\n    #for pkmn in filter(lambda x: x.is_alive(), state.opponent.reserve):\r\n    if state.opponent.active.hp > 0:\r\n        if find_most_damage_move(state, user_pkmn, state.opponent.active) >= state.opponent.active.hp:\r\n                count = count + 1\r\n    for pkmn in state.opponent.reserve.values():\r\n        if pkmn.hp > 0:\r\n            if find_most_damage_move(state, user_pkmn, pkmn) >= pkmn.hp:\r\n                count = count + 1\r\n    return count\r\n\r\n\r\ndef how_many_each_sweeps_opponent(state, opponent_pkmn):\r\n\r\n    count = 0\r\n    if state.self.active.hp > 0:\r\n        if find_most_damage_move_opponent(state, opponent_pkmn, state.self.active) >= state.self.active.hp:\r\n                count = count + 1\r\n    for pkmn in state.self.reserve.values():\r\n        if pkmn.hp > 0:\r\n\r\n            if find_most_damage_move_opponent(state, opponent_pkmn, pkmn) >= pkmn.hp:\r\n                count = count + 1\r\n    return count\r\n`","closed_by":{"login":"pmariglia","id":25304649,"node_id":"MDQ6VXNlcjI1MzA0NjQ5","avatar_url":"https://avatars.githubusercontent.com/u/25304649?v=4","gravatar_id":"","url":"https://api.github.com/users/pmariglia","html_url":"https://github.com/pmariglia","followers_url":"https://api.github.com/users/pmariglia/followers","following_url":"https://api.github.com/users/pmariglia/following{/other_user}","gists_url":"https://api.github.com/users/pmariglia/gists{/gist_id}","starred_url":"https://api.github.com/users/pmariglia/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/pmariglia/subscriptions","organizations_url":"https://api.github.com/users/pmariglia/orgs","repos_url":"https://api.github.com/users/pmariglia/repos","events_url":"https://api.github.com/users/pmariglia/events{/privacy}","received_events_url":"https://api.github.com/users/pmariglia/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/pmariglia/showdown/issues/26/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/pmariglia/showdown/issues/26/timeline","performed_via_github_app":null,"state_reason":"completed"}