{"url":"https://api.github.com/repos/mlflow/mlflow/issues/7185","repository_url":"https://api.github.com/repos/mlflow/mlflow","labels_url":"https://api.github.com/repos/mlflow/mlflow/issues/7185/labels{/name}","comments_url":"https://api.github.com/repos/mlflow/mlflow/issues/7185/comments","events_url":"https://api.github.com/repos/mlflow/mlflow/issues/7185/events","html_url":"https://github.com/mlflow/mlflow/issues/7185","id":1426676100,"node_id":"I_kwDOCB5Jx85VCVmE","number":7185,"title":"Replace `unittest` assert methods with plain `assert`","user":{"login":"harupy","id":17039389,"node_id":"MDQ6VXNlcjE3MDM5Mzg5","avatar_url":"https://avatars.githubusercontent.com/u/17039389?v=4","gravatar_id":"","url":"https://api.github.com/users/harupy","html_url":"https://github.com/harupy","followers_url":"https://api.github.com/users/harupy/followers","following_url":"https://api.github.com/users/harupy/following{/other_user}","gists_url":"https://api.github.com/users/harupy/gists{/gist_id}","starred_url":"https://api.github.com/users/harupy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/harupy/subscriptions","organizations_url":"https://api.github.com/users/harupy/orgs","repos_url":"https://api.github.com/users/harupy/repos","events_url":"https://api.github.com/users/harupy/events{/privacy}","received_events_url":"https://api.github.com/users/harupy/received_events","type":"User","site_admin":false},"labels":[{"id":955449436,"node_id":"MDU6TGFiZWw5NTU0NDk0MzY=","url":"https://api.github.com/repos/mlflow/mlflow/labels/good%20first%20issue","name":"good first issue","color":"7057ff","default":true,"description":"Good for newcomers"},{"id":4300304016,"node_id":"LA_kwDOCB5Jx88AAAABAFFukA","url":"https://api.github.com/repos/mlflow/mlflow/labels/has-closing-pr","name":"has-closing-pr","color":"fef2c0","default":false,"description":"This issue has a closing PR"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2022-10-28T05:00:17Z","updated_at":"2022-11-03T16:22:08Z","closed_at":"2022-11-03T16:22:08Z","author_association":"MEMBER","active_lock_reason":null,"body":"## Details\r\n\r\nReplace unittest's assert methods with plain `assert`.\r\n\r\n## Example\r\n\r\n```diff\r\nclass TestExample(unittest.TestCase):\r\n    def test_foo(self):\r\n-        self.assertEqual(1, 2)\r\n+        assert 1 == 2\r\n```\r\n\r\n## Motivation\r\n\r\n1. `assert` (rewritten by pytest) gives a better error message than unittest assert methods.\r\n2. We'll migrate unittest test suites to pytest.\r\n3. For code consistency.\r\n\r\n## Instructions\r\n\r\n1. Run `pip install libcst` for automatic code transformation.\r\n2. Save the code below (which should transform all the assert methods in our code base) in `a.py`. Make sure that searching `self.assert[A-Z]` (regular expression) matches nothing. \r\n3. Run `python a.py $(git ls-files \"tests/**/*.py\")` in the repository root.\r\n4. Run `black .`.\r\n\r\n```python\r\nimport libcst as cst\r\nimport pathlib\r\nimport argparse\r\nimport difflib\r\n\r\n\r\nclass AssertMethodTransformer(cst.CSTTransformer):\r\n    @staticmethod\r\n    def is_unittest_assert_method(node: cst.Call, name: str) -> bool:\r\n        return (\r\n            isinstance(node.func, cst.Attribute)\r\n            and isinstance(node.func.value, cst.Name)\r\n            and node.func.value.value == \"self\"\r\n            and isinstance(node.func.attr, cst.Name)\r\n            and node.func.attr.value == name\r\n        )\r\n\r\n    def leave_Call(self, original_node: cst.Call, updated_node: cst.Call) -> cst.Assert:\r\n        if (\r\n            AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertEqual\")\r\n            or AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertListEqual\")\r\n            or AssertMethodTransformer.is_unittest_assert_method(\r\n                original_node, \"assertSequenceEqual\"\r\n            )\r\n        ):\r\n            left, right = original_node.args\r\n            left = left.value\r\n            right = right.value\r\n            assert_node = cst.Assert(\r\n                test=cst.Comparison(\r\n                    left=left,\r\n                    comparisons=[\r\n                        cst.ComparisonTarget(\r\n                            operator=cst.Equal(),\r\n                            comparator=right,\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n            return assert_node\r\n\r\n        if AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertCountEqual\"):\r\n            # `self.assertCountEqual({1, 2, 3}, x)` can converted to `assert {1, 2, 3} == x`\r\n            if any(isinstance(a.value, cst.Set) for a in original_node.args):\r\n                print(original_node.args[0].value.elements)\r\n                left = original_node.args[0].value\r\n                right = original_node.args[1].value\r\n                assert_node = cst.Assert(\r\n                    test=cst.Comparison(\r\n                        left=left,\r\n                        comparisons=[\r\n                            cst.ComparisonTarget(\r\n                                operator=cst.Equal(),\r\n                                comparator=right,\r\n                            )\r\n                        ],\r\n                    )\r\n                )\r\n                return assert_node\r\n            # `self.assertCountEqual([], x)` or `self.assertCountEqual([1], x)` can be converted to\r\n            # assert [] == x or assert [1] == x\r\n            if any(\r\n                isinstance(a.value, (cst.List, cst.Tuple)) and len(a.value.elements) < 2\r\n                for a in original_node.args\r\n            ):\r\n                left = original_node.args[0].value\r\n                right = original_node.args[1].value\r\n                assert_node = cst.Assert(\r\n                    test=cst.Comparison(\r\n                        left=left,\r\n                        comparisons=[\r\n                            cst.ComparisonTarget(\r\n                                operator=cst.Equal(),\r\n                                comparator=right,\r\n                            )\r\n                        ],\r\n                    )\r\n                )\r\n                return assert_node\r\n\r\n            # `self.assertCountEqual([1, 2], x)` can't be converted to `assert [1, 2] == x`.\r\n            # because x can be [2, 1]. We can convert it to either\r\n            # `assert sorted([1, 2]) == sorted(x)` or `assert {1, 2} == set(x)`.\r\n            # We choose the former because the latter allows x to contain duplicates.\r\n            # For example, if x is the return value of `search_experiments`, it should not contain duplicates.\r\n            left, right = original_node.args\r\n            assert_node = cst.Assert(\r\n                test=cst.Comparison(\r\n                    left=cst.Call(\r\n                        func=cst.Name(\"sorted\"),\r\n                        args=[left],\r\n                    ),\r\n                    comparisons=[\r\n                        cst.ComparisonTarget(\r\n                            operator=cst.Equal(),\r\n                            comparator=cst.Call(\r\n                                func=cst.Name(\"sorted\"),\r\n                                args=[left],\r\n                            ),\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n            return assert_node\r\n\r\n        elif AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertNotEqual\"):\r\n            left, right = original_node.args\r\n            left = left.value\r\n            right = right.value\r\n            assert_node = cst.Assert(\r\n                test=cst.Comparison(\r\n                    left=left,\r\n                    comparisons=[\r\n                        cst.ComparisonTarget(\r\n                            operator=cst.NotEqual(),\r\n                            comparator=right,\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n            return assert_node\r\n        elif AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertIsInstance\"):\r\n            left, right = original_node.args\r\n            assert_node = cst.Assert(test=cst.Call(func=cst.Name(\"isinstance\"), args=[left, right]))\r\n            return assert_node\r\n\r\n        elif AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertTrue\"):\r\n            assert_node = cst.Assert(test=original_node.args[0].value)\r\n            return assert_node\r\n\r\n        elif AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertIsNone\"):\r\n            (arg,) = original_node.args\r\n            assert_node = cst.Assert(\r\n                test=cst.Comparison(\r\n                    left=arg.value,\r\n                    comparisons=[\r\n                        cst.ComparisonTarget(\r\n                            operator=cst.Is(),\r\n                            comparator=cst.Name(\"None\"),\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n            return assert_node\r\n\r\n        elif AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertIsNotNone\"):\r\n            (arg,) = original_node.args\r\n            assert_node = cst.Assert(\r\n                test=cst.Comparison(\r\n                    left=arg.value,\r\n                    comparisons=[\r\n                        cst.ComparisonTarget(\r\n                            operator=cst.IsNot(),\r\n                            comparator=cst.Name(\"None\"),\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n            return assert_node\r\n\r\n        elif AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertIn\"):\r\n            left, right = original_node.args\r\n            assert_node = cst.Assert(\r\n                test=cst.Comparison(\r\n                    left=left.value,\r\n                    comparisons=[\r\n                        cst.ComparisonTarget(\r\n                            operator=cst.In(),\r\n                            comparator=right.value,\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n            return assert_node\r\n\r\n        elif AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertLessEqual\"):\r\n            left, right = original_node.args\r\n            assert_node = cst.Assert(\r\n                test=cst.Comparison(\r\n                    left=left.value,\r\n                    comparisons=[\r\n                        cst.ComparisonTarget(\r\n                            operator=cst.LessThanEqual(),\r\n                            comparator=right.value,\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n            return assert_node\r\n\r\n        elif AssertMethodTransformer.is_unittest_assert_method(original_node, \"assertAlmostEqual\"):\r\n            left, right = original_node.args[:2]\r\n            assert_node = cst.Assert(\r\n                test=cst.Comparison(\r\n                    left=left.value,\r\n                    comparisons=[\r\n                        cst.ComparisonTarget(\r\n                            operator=cst.Equal(),\r\n                            comparator=cst.Call(\r\n                                cst.Attribute(value=cst.Name(\"pytest\"), attr=cst.Name(\"approx\")),\r\n                                args=[right],\r\n                            ),\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n            return assert_node\r\n\r\n        return original_node\r\n\r\n\r\ndef transform_file(path: pathlib.Path) -> None:\r\n    src = path.read_text()\r\n    source_tree = cst.parse_module(src)\r\n    modified_tree = source_tree.visit(AssertMethodTransformer())\r\n    if not modified_tree.deep_equals(source_tree):\r\n        print(\"\".join(difflib.unified_diff(src.splitlines(1), modified_tree.code.splitlines(1))))\r\n        path.write_text(modified_tree.code)\r\n        print(f\"Transformed {path}\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # python a.py $(git ls-files \"tests/**/*.py\")\r\n    parser = argparse.ArgumentParser(description=\"Process some integers.\")\r\n    parser.add_argument(\"files\", metavar=\"N\", nargs=\"+\", help=\"an integer for the accumulator\")\r\n    args = parser.parse_args()\r\n    for f in args.files:\r\n        print(\"Processing\", f)\r\n        transform_file(pathlib.Path(f))\r\n```\r\n\r\n## Out of scope:\r\n\r\n- Swapping actual and expected values.\r\n","closed_by":{"login":"harupy","id":17039389,"node_id":"MDQ6VXNlcjE3MDM5Mzg5","avatar_url":"https://avatars.githubusercontent.com/u/17039389?v=4","gravatar_id":"","url":"https://api.github.com/users/harupy","html_url":"https://github.com/harupy","followers_url":"https://api.github.com/users/harupy/followers","following_url":"https://api.github.com/users/harupy/following{/other_user}","gists_url":"https://api.github.com/users/harupy/gists{/gist_id}","starred_url":"https://api.github.com/users/harupy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/harupy/subscriptions","organizations_url":"https://api.github.com/users/harupy/orgs","repos_url":"https://api.github.com/users/harupy/repos","events_url":"https://api.github.com/users/harupy/events{/privacy}","received_events_url":"https://api.github.com/users/harupy/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/mlflow/mlflow/issues/7185/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/mlflow/mlflow/issues/7185/timeline","performed_via_github_app":null,"state_reason":"completed"}