{"url":"https://api.github.com/repos/mlflow/mlflow/issues/740","repository_url":"https://api.github.com/repos/mlflow/mlflow","labels_url":"https://api.github.com/repos/mlflow/mlflow/issues/740/labels{/name}","comments_url":"https://api.github.com/repos/mlflow/mlflow/issues/740/comments","events_url":"https://api.github.com/repos/mlflow/mlflow/issues/740/events","html_url":"https://github.com/mlflow/mlflow/issues/740","id":387080633,"node_id":"MDU6SXNzdWUzODcwODA2MzM=","number":740,"title":"http server substitute for ftp","user":{"login":"suzhenyu22","id":26854721,"node_id":"MDQ6VXNlcjI2ODU0NzIx","avatar_url":"https://avatars.githubusercontent.com/u/26854721?v=4","gravatar_id":"","url":"https://api.github.com/users/suzhenyu22","html_url":"https://github.com/suzhenyu22","followers_url":"https://api.github.com/users/suzhenyu22/followers","following_url":"https://api.github.com/users/suzhenyu22/following{/other_user}","gists_url":"https://api.github.com/users/suzhenyu22/gists{/gist_id}","starred_url":"https://api.github.com/users/suzhenyu22/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/suzhenyu22/subscriptions","organizations_url":"https://api.github.com/users/suzhenyu22/orgs","repos_url":"https://api.github.com/users/suzhenyu22/repos","events_url":"https://api.github.com/users/suzhenyu22/events{/privacy}","received_events_url":"https://api.github.com/users/suzhenyu22/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2018-12-04T01:36:07Z","updated_at":"2018-12-28T06:13:57Z","closed_at":"2018-12-28T06:13:57Z","author_association":"NONE","active_lock_reason":null,"body":"because of ftp PASV mode when use in k8s, not all the time can get the right address, so i write the http server replace of ftp,  the struck and function name like ftp and ，please check.\r\n\r\n```python\r\n# http_artifact_repo.py\r\n\r\nimport os\r\nimport ftplib\r\nfrom ftplib import FTP\r\nfrom contextlib import contextmanager\r\n\r\nfrom six.moves import urllib\r\nfrom mlflow.entities.file_info import FileInfo\r\nfrom mlflow.store.artifact_repo import ArtifactRepository\r\nfrom mlflow.utils.file_utils import TempDir, build_path, get_relative_path\r\n\r\nfrom platform import system as system_type\r\nimport requests\r\nimport json\r\nimport traceback\r\n\r\n\r\ndef build_local_path(*path_segments):\r\n    \"\"\"build local path that store file in local machine\"\"\"\r\n    return os.path.join(*path_segments)\r\n\r\n\r\ndef build_remote_path(*path_segments):\r\n    \"\"\"build remote path where server store files,  note that path generate on linux or windows\"\"\"\r\n    if system_type().lower() == 'windows':\r\n        return '/'.join(path_segments).replace('//', '/')\r\n    else:\r\n        return os.path.join(*path_segments).replace('//', '/')\r\n\r\n\r\ndef to_remote_path(path):\r\n    \"\"\"change windows path to linux path, the specific path like /0/runid/artifact\\model\\MLproject\"\"\"\r\n    if not path:\r\n        return path\r\n    if system_type().lower() == 'windows':\r\n        return path.replace('\\\\', '/').replace('//', '/')\r\n    else:\r\n        return path\r\n\r\n\r\nclass HTTPArtifactRepository(ArtifactRepository):\r\n    \"\"\"Stores artifacts as files in a remote directory, via http.\"\"\"\r\n\r\n    def __init__(self, artifact_uri):\r\n        self.uri = artifact_uri\r\n        parsed = urllib.parse.urlparse(artifact_uri)\r\n        self.url = '%s://%s' % (parsed.scheme, parsed.netloc)  # example: http://127.0.0.1:5001\r\n        self.path = parsed.path  # example: /home/mlflow/store/0/runid/artifact\r\n\r\n        super(HTTPArtifactRepository, self).__init__(artifact_uri)\r\n\r\n    def _buile_url(self, api):\r\n        \"\"\"build http url, example: http://127.0.0.1:5001/upload\"\"\"\r\n        return '%s/%s' % (self.url, api)\r\n\r\n    def _is_dir(self, full_file_path):\r\n        if os.path.isdir(full_file_path):\r\n            return True\r\n        else:\r\n            return False\r\n\r\n    def _mkdir(self, artifact_dir):\r\n        if self._is_dir(artifact_dir):\r\n            return\r\n        else:\r\n            os.makedirs(artifact_dir)\r\n\r\n    def download_files(self, path, destination):\r\n        # make dir on local machine\r\n        if not os.path.isdir(destination):\r\n            os.makedirs(destination)\r\n        # get all files and dirs from http server\r\n        remote_path = build_remote_path(self.path, path) if path else self.path\r\n        r = requests.get(self._buile_url('listfile'), params={'remote_path': remote_path, 'root_path': self.path})\r\n        print(r.text)\r\n        # download files\r\n        # types: string, values is [ dir , file ]\r\n        # name: string, dir name or file name\r\n        # size: int, file size, 0 for dir\r\n        for types, name, size in json.loads(r.text):\r\n            name = os.path.basename(name)  # requests result：/model/MLproject\r\n            if types == 'file':\r\n                local_path = os.path.join(destination, name)      # file to save local path\r\n                remote_file_path = build_remote_path(remote_path, name)  # file store in remote path\r\n                r = requests.get(self._buile_url('download'), params={'path': remote_file_path})  # download\r\n                if r.status_code == 200:\r\n                    with open(local_path, 'wb') as file:\r\n                        file.write(r.content)\r\n                else:\r\n                    raise Exception('download file error', remote_file_path)\r\n            elif types == 'dir':\r\n                self.download_files(path=name, destination=os.path.join(destination, name))\r\n\r\n    def log_artifact(self, local_file, artifact_path=None):\r\n        # build remote path and post to server, http server will make it on server machine.\r\n        remote_path = build_remote_path(self.path, artifact_path) if artifact_path else self.path\r\n        # upload file\r\n        file_name = os.path.basename(local_file)\r\n        file_realpath = os.path.realpath(local_file)\r\n        files = {'field1': (file_name, open(local_file, \"rb\"))}  \r\n        data = {'remote_path': remote_path}  # path where file store in remote machine\r\n        r = requests.post(url=self._buile_url('upload'), data=data, files=files)  \r\n        if r.status_code == 200:\r\n            return\r\n        else:\r\n            raise Exception(r.text)\r\n\r\n    def log_artifacts(self, local_dir, artifact_path=None):\r\n        for (root, _, filenames) in os.walk(local_dir):\r\n            rel_path = os.path.relpath(root, local_dir) \r\n            rel_path = None if rel_path == '.' else rel_path \r\n            rel_path = to_remote_path(rel_path)\r\n            if artifact_path is None:\r\n                upload_path = rel_path\r\n            elif rel_path is None:\r\n                upload_path = artifact_path\r\n            else:\r\n                upload_path = build_remote_path(artifact_path, rel_path)\r\n            for file in filenames:\r\n                local_file = os.path.join(root, file)\r\n                self.log_artifact(local_file, upload_path)\r\n\r\n    def list_artifacts(self, path=None):\r\n        \"\"\"post path to http server and server will list files then return \"\"\"\r\n        remote_path = build_remote_path(self.path, path) if path else self.path\r\n        r = requests.get(self._buile_url('listfile'), params={'remote_path': remote_path, 'root_path': self.path})\r\n        if r.status_code == 200:\r\n            infos = []\r\n            all_files = json.loads(r.text)\r\n            for types, name, size in all_files:  \r\n                if types == 'dir':\r\n                    infos.append(FileInfo(name, True, None))\r\n                else:\r\n                    infos.append(FileInfo(name, False, size))\r\n            return infos\r\n\r\n    def download_artifacts(self, artifact_path=None):\r\n        full_path = build_remote_path(self.path, artifact_path) if artifact_path else self.path\r\n        return_path = None\r\n        with TempDir(remove_on_exit=False) as tmp:\r\n            tmp_path = tmp.path() \r\n            # check the path on server is dir or file\r\n            r = requests.get(self._buile_url('pathtype'), params={'path': full_path})\r\n            if r.text == 'file':\r\n                local_file = os.path.join(tmp_path, os.path.basename(full_path))\r\n                self._download_file(full_path, local_file)\r\n                return_path = local_file\r\n            if r.text == 'dir':\r\n                self.download_files(artifact_path, tmp_path)\r\n                return_path = tmp_path\r\n        return return_path\r\n\r\n    def _download_file(self, remote_file_path, local_path):\r\n        remote_full_path = build_remote_path(self.path, remote_file_path) if remote_file_path else self.path\r\n        r = requests.get(self._buile_url('download'), params={'path': remote_full_path})\r\n        if r.status_code == 200:\r\n            local_file = local_path\r\n            print('http download: local_file', local_file)\r\n            with open(local_file, 'wb') as file:\r\n                file.write(r.content)\r\n```\r\n```python\r\n# flask_server.py\r\n\r\nfrom flask import Flask, request\r\nimport flask\r\nimport traceback\r\nimport os\r\nimport json\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route('/test', methods=['GET', 'POST'])\r\ndef test():\r\n    if request.method == 'POST':\r\n        param = request.args.to_dict()\r\n        print(param)\r\n        return 'I have received you data \\n' + str(param)\r\n    else:\r\n        return 'I have received you data '\r\n\r\n\r\n@app.route('/upload', methods=['POST'])\r\ndef upload():\r\n    if request.method == 'POST':\r\n        try:\r\n            f = request.files['field1']\r\n            param = request.values.to_dict()\r\n            old_path = os.getcwd()\r\n            dest_path = param['remote_path']\r\n            filename = f.filename\r\n            if not os.path.exists(dest_path):\r\n                os.makedirs(dest_path)\r\n            # save upload file\r\n            os.chdir(dest_path)\r\n            f.save(filename)\r\n            os.chdir(old_path)\r\n            return '200'\r\n        except:\r\n            return '400'\r\n    return '400'\r\n\r\n\r\n@app.route('/listfile', methods=['GET'])\r\ndef listfile():\r\n    params = request.args.to_dict()\r\n    remote_path = params['remote_path']  # /home/mlflow/store/0/runid/artifact\r\n    root_path = params['root_path']  # /home/mlflow/store/0/runid\r\n    all_files = []\r\n    for file_or_dir in os.listdir(remote_path):\r\n        tmp_path = os.path.join(remote_path, file_or_dir)  \r\n        # /home/zhenyu/mlflowstore/1/22b48e39af1c4ddda7676f79368f3c7c/artifacts/model/MLmodel  \r\n        rel_path = os.path.relpath(tmp_path, root_path)  \r\n        # model/MLmodel \r\n        if os.path.isdir(tmp_path):\r\n            all_files.append(['dir', rel_path, 0])\r\n        else:\r\n            size = os.path.getsize(tmp_path)\r\n            all_files.append(['file', rel_path, size])\r\n    return json.dumps(all_files)\r\n\r\n\r\n@app.route('/download', methods=['GET'])\r\ndef download():\r\n    path = request.args.to_dict()['path']\r\n    dir, file = os.path.split(path)\r\n    if not os.path.exists(path):\r\n        return '400'\r\n    return flask.send_from_directory(dir, file, as_attachment=True)\r\n\r\n\r\n@app.route('/pathtype', methods=['GET'])\r\ndef pathtype():\r\n    \"\"\"check path is file or dir\"\"\"\r\n    path = request.args.to_dict()['path']\r\n    if os.path.exists(path) and os.path.isdir(path):\r\n        return 'dir'\r\n    if os.path.exists(path) and os.path.isfile(path):\r\n        return 'file'\r\n    return 'None'\r\n\r\n# start http server\r\napp.run(host='127.0.0.1', port=5001, threaded=True)\r\n```\r\n\r\n```artifact_repo.py```\r\nadd \r\n```\r\n        elif artifact_uri.startswith('http:/'):\r\n            from mlflow.store.http_artifact_repo import HTTPArtifactRepository\r\n            return HTTPArtifactRepository(artifact_uri)\r\n```\r\n\r\n\r\n","closed_by":{"login":"suzhenyu22","id":26854721,"node_id":"MDQ6VXNlcjI2ODU0NzIx","avatar_url":"https://avatars.githubusercontent.com/u/26854721?v=4","gravatar_id":"","url":"https://api.github.com/users/suzhenyu22","html_url":"https://github.com/suzhenyu22","followers_url":"https://api.github.com/users/suzhenyu22/followers","following_url":"https://api.github.com/users/suzhenyu22/following{/other_user}","gists_url":"https://api.github.com/users/suzhenyu22/gists{/gist_id}","starred_url":"https://api.github.com/users/suzhenyu22/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/suzhenyu22/subscriptions","organizations_url":"https://api.github.com/users/suzhenyu22/orgs","repos_url":"https://api.github.com/users/suzhenyu22/repos","events_url":"https://api.github.com/users/suzhenyu22/events{/privacy}","received_events_url":"https://api.github.com/users/suzhenyu22/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/mlflow/mlflow/issues/740/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/mlflow/mlflow/issues/740/timeline","performed_via_github_app":null,"state_reason":"completed"}