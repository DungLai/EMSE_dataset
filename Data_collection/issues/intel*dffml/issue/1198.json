{"url":"https://api.github.com/repos/intel/dffml/issues/1198","repository_url":"https://api.github.com/repos/intel/dffml","labels_url":"https://api.github.com/repos/intel/dffml/issues/1198/labels{/name}","comments_url":"https://api.github.com/repos/intel/dffml/issues/1198/comments","events_url":"https://api.github.com/repos/intel/dffml/issues/1198/events","html_url":"https://github.com/intel/dffml/issues/1198","id":975317960,"node_id":"MDU6SXNzdWU5NzUzMTc5NjA=","number":1198,"title":"operation: archive: Directory structure not preserved while creating a zip/tar archive of a directory","user":{"login":"programmer290399","id":41383069,"node_id":"MDQ6VXNlcjQxMzgzMDY5","avatar_url":"https://avatars.githubusercontent.com/u/41383069?v=4","gravatar_id":"","url":"https://api.github.com/users/programmer290399","html_url":"https://github.com/programmer290399","followers_url":"https://api.github.com/users/programmer290399/followers","following_url":"https://api.github.com/users/programmer290399/following{/other_user}","gists_url":"https://api.github.com/users/programmer290399/gists{/gist_id}","starred_url":"https://api.github.com/users/programmer290399/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/programmer290399/subscriptions","organizations_url":"https://api.github.com/users/programmer290399/orgs","repos_url":"https://api.github.com/users/programmer290399/repos","events_url":"https://api.github.com/users/programmer290399/events{/privacy}","received_events_url":"https://api.github.com/users/programmer290399/received_events","type":"User","site_admin":false},"labels":[{"id":1062701217,"node_id":"MDU6TGFiZWwxMDYyNzAxMjE3","url":"https://api.github.com/repos/intel/dffml/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-08-20T06:46:03Z","updated_at":"2021-08-22T23:41:11Z","closed_at":"2021-08-22T23:41:11Z","author_association":"COLLABORATOR","active_lock_reason":null,"body":"## Describe the bug\r\n\r\nWhile creating an archive the directory structure is not preserved. \r\n\r\n\r\n## Steps To Reproduce\r\n\r\nTry archiving any directory or use following example.\r\n\r\n<details><summary>Example by @pdxjohnny </summary>\r\n<p>\r\n\r\n```py\r\nimport os\r\nimport sys\r\nimport pathlib\r\nimport tempfile\r\nimport itertools\r\nfrom typing import Union, Callable\r\n\r\nfrom dffml.operation.archive import (\r\n    make_zip_archive,\r\n    extract_zip_archive,\r\n    make_tar_archive,\r\n    extract_tar_archive,\r\n)\r\nfrom dffml.operation.compression import (\r\n    gz_compress,\r\n    gz_decompress,\r\n    bz2_compress,\r\n    bz2_decompress,\r\n    xz_compress,\r\n    xz_decompress,\r\n)\r\n\r\nfrom dffml.df.types import DataFlow, Input, Operation\r\nfrom dffml.df.base import OperationImplementation, op\r\nfrom dffml.noasync import run\r\n\r\n# Must include output operation for results (from run()) to contain data!\r\nfrom dffml.operation.output import GetSingle\r\n\r\n\r\ndef make_dataflow(\r\n    *args: Union[Operation, OperationImplementation, Callable], **kwargs\r\n) -> DataFlow:\r\n    return DataFlow(\r\n        # Add an output operation. Results will be empty without one.\r\n        GetSingle,\r\n        # Add the operations to the dataflow.\r\n        *args,\r\n        seed=[\r\n            # Ensure the output operation returns a single value for each\r\n            # operation executed that has an output. If operations will be run\r\n            # multiple times and produce multiple outputs which you want to\r\n            # capture, you'll want to add GetMulti rather than GetSingle.\r\n            Input(\r\n                value=list(\r\n                    itertools.chain(\r\n                        *[\r\n                            [\r\n                                definition.name\r\n                                for definition in operation.op.outputs.values()\r\n                            ]\r\n                            for operation in args\r\n                        ]\r\n                    )\r\n                ),\r\n                definition=GetSingle.op.inputs[\"spec\"],\r\n            )\r\n        ]\r\n        + [\r\n            # Add each input from kwargs.\r\n            Input(\r\n                value=value,\r\n                # Look up the definition which should be used this value. The\r\n                # name of the keyword argument will be used to look up the\r\n                # definition. This is just a quick and dirty approach to this,\r\n                # obviously if there are two inputs with the same operation\r\n                # local name, only one of their definitions will be chosen.\r\n                definition=dict(\r\n                    itertools.chain(\r\n                        *[\r\n                            [\r\n                                (input_name, definition)\r\n                                for input_name, definition in operation.op.inputs.items()\r\n                            ]\r\n                            for operation in args\r\n                        ]\r\n                    )\r\n                )[key],\r\n            )\r\n            for key, value in kwargs.items()\r\n        ],\r\n    )\r\n\r\n\r\n@op\r\ndef debug_print_tempdir(input_directory_path: str):\r\n    \"\"\"\r\n    Debug function to print contents of tempdir\r\n    \"\"\"\r\n    os.system(f\"tree {input_directory_path}\")\r\n\r\n\r\ndef main():\r\n    # Create a temporary directory which we'll make an archive of\r\n    with tempfile.TemporaryDirectory() as tempdir:\r\n        # Create a file in the directory to make an archive of\r\n        pathlib.Path(tempdir, \"hello\").write_text(\"world\")\r\n        # Make a dataflow to run each operation (just for example purposes, we\r\n        # will connect operations in another example).\r\n        for dataflow in (\r\n            [\r\n                # Make the tar archive\r\n                make_dataflow(\r\n                    make_tar_archive,\r\n                    input_directory_path=tempdir,\r\n                    output_file_path=str(pathlib.Path(tempdir, \"test.tar\")),\r\n                )\r\n            ]\r\n            + list(\r\n                itertools.chain(\r\n                    *[\r\n                        [\r\n                            # Compress the tar archive\r\n                            make_dataflow(\r\n                                # Grab operation from the globals of this file by name\r\n                                getattr(\r\n                                    sys.modules[__name__],\r\n                                    f\"{compression_algorithm}_compress\",\r\n                                ),\r\n                                input_file_path=str(\r\n                                    pathlib.Path(tempdir, \"test.tar\")\r\n                                ),\r\n                                output_file_path=str(\r\n                                    pathlib.Path(\r\n                                        tempdir,\r\n                                        f\"test.tar.{compression_algorithm}\",\r\n                                    )\r\n                                ),\r\n                            ),\r\n                            # Decompress the tar archive\r\n                            make_dataflow(\r\n                                # Grab operation from the globals of this file by name\r\n                                getattr(\r\n                                    sys.modules[__name__],\r\n                                    f\"{compression_algorithm}_decompress\",\r\n                                ),\r\n                                input_file_path=str(\r\n                                    pathlib.Path(\r\n                                        tempdir,\r\n                                        f\"test.tar.{compression_algorithm}\",\r\n                                    )\r\n                                ),\r\n                                output_file_path=str(\r\n                                    pathlib.Path(\r\n                                        tempdir,\r\n                                        f\"test.decompressed_{compression_algorithm}.tar\",\r\n                                    )\r\n                                ),\r\n                            ),\r\n                            # Extract the tar archive. Ensure that compression and\r\n                            # decompression didn't mess up the archive\r\n                            make_dataflow(\r\n                                extract_tar_archive,\r\n                                input_file_path=str(\r\n                                    pathlib.Path(\r\n                                        tempdir,\r\n                                        f\"test.decompressed_{compression_algorithm}.tar\",\r\n                                    )\r\n                                ),\r\n                                output_directory_path=str(\r\n                                    pathlib.Path(\r\n                                        tempdir,\r\n                                        f\"tar_inflated_{compression_algorithm}\",\r\n                                    )\r\n                                ),\r\n                            ),\r\n                        ]\r\n                        for compression_algorithm in [\"gz\", \"bz2\", \"xz\"]\r\n                    ]\r\n                )\r\n            )\r\n            + [\r\n                # Make the zip archive (which will contain the tar archive)\r\n                make_dataflow(\r\n                    debug_print_tempdir, input_directory_path=tempdir,\r\n                ),\r\n                # Make the zip archive (which will contain the tar archive)\r\n                make_dataflow(\r\n                    make_zip_archive,\r\n                    input_directory_path=tempdir,\r\n                    output_file_path=str(pathlib.Path(tempdir, \"test.zip\")),\r\n                ),\r\n                # Extract the zip archive\r\n                make_dataflow(\r\n                    extract_tar_archive,\r\n                    input_file_path=str(pathlib.Path(tempdir, \"test.zip\")),\r\n                    output_directory_path=str(\r\n                        pathlib.Path(tempdir, \"zip_inflated\")\r\n                    ),\r\n                ),\r\n            ]\r\n        ):\r\n            # Run the dataflow. Keep in mind the dataflows in the above list\r\n            # will be run in order. Each dataflow is just one processing\r\n            # operation and one output operation (GetSingle).\r\n            print(list(dataflow.operations.keys())[1:])\r\n            print(dataflow.seed[1:])\r\n            for ctx, results in run(dataflow):\r\n                print(\"results\", results, \"\\n\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n## Expected behavior\r\n\r\nFor ex if we try to archive a directory with the following structure:\r\n```\r\ntop_level_dir\r\n├── child_dir_1 \r\n│   └── file1\r\n├── child_dir_2\r\n│   ├── file2\r\n│   └── file3\r\n└── child_dir_3\r\n    └── child_child_dir1\r\n        └── file4    \r\n```\r\n\r\nWe expect to have the same structure inside the archive as well, but currently we get the following structure in the archive:\r\n```\r\ntop_level_dir\r\n├── child_dir_1 \r\n├── child_dir_2\r\n├── child_dir_3\r\n├── child_child_dir1\r\n├── file1\r\n├── file2\r\n├── file3\r\n└── file4    \r\n```\r\n\r\n## Related:\r\n* Partially Blocks: \r\n    - #662 \r\n    - #1174 : Creating issues in loading and saving spacy models in archive format. \r\n* Introduced in: #1128 \r\n\r\n","closed_by":{"login":"pdxjohnny","id":5950433,"node_id":"MDQ6VXNlcjU5NTA0MzM=","avatar_url":"https://avatars.githubusercontent.com/u/5950433?v=4","gravatar_id":"","url":"https://api.github.com/users/pdxjohnny","html_url":"https://github.com/pdxjohnny","followers_url":"https://api.github.com/users/pdxjohnny/followers","following_url":"https://api.github.com/users/pdxjohnny/following{/other_user}","gists_url":"https://api.github.com/users/pdxjohnny/gists{/gist_id}","starred_url":"https://api.github.com/users/pdxjohnny/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/pdxjohnny/subscriptions","organizations_url":"https://api.github.com/users/pdxjohnny/orgs","repos_url":"https://api.github.com/users/pdxjohnny/repos","events_url":"https://api.github.com/users/pdxjohnny/events{/privacy}","received_events_url":"https://api.github.com/users/pdxjohnny/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/intel/dffml/issues/1198/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/intel/dffml/issues/1198/timeline","performed_via_github_app":null,"state_reason":"completed"}