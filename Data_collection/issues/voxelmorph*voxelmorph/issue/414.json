{"url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/414","repository_url":"https://api.github.com/repos/voxelmorph/voxelmorph","labels_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/414/labels{/name}","comments_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/414/comments","events_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/414/events","html_url":"https://github.com/voxelmorph/voxelmorph/issues/414","id":1192635443,"node_id":"I_kwDOB_Nd285HFiwz","number":414,"title":"About the range of NCC loss.","user":{"login":"Willianwatch","id":19358225,"node_id":"MDQ6VXNlcjE5MzU4MjI1","avatar_url":"https://avatars.githubusercontent.com/u/19358225?v=4","gravatar_id":"","url":"https://api.github.com/users/Willianwatch","html_url":"https://github.com/Willianwatch","followers_url":"https://api.github.com/users/Willianwatch/followers","following_url":"https://api.github.com/users/Willianwatch/following{/other_user}","gists_url":"https://api.github.com/users/Willianwatch/gists{/gist_id}","starred_url":"https://api.github.com/users/Willianwatch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Willianwatch/subscriptions","organizations_url":"https://api.github.com/users/Willianwatch/orgs","repos_url":"https://api.github.com/users/Willianwatch/repos","events_url":"https://api.github.com/users/Willianwatch/events{/privacy}","received_events_url":"https://api.github.com/users/Willianwatch/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-04-05T05:27:57Z","updated_at":"2022-04-05T11:22:07Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"**Task** (what are you trying to do/register?)\r\n\r\nI am try to register the neighboring to slices of MR image.\r\n\r\n**What have you tried**\r\n\r\nI use the 2D PyTorch version of VoxelMorph. \r\n\r\n**Details of experiments**\r\n\r\nI set the weight of gradient loss to 0 to see what will happen with only NCC loss. I rewrite the NCC loss as follows, but the loss is pretty slow and smaller than -1 (could to -50). Is it normal? I checked my code for several times and could not find any mistakes. Can you spare some time to see my code? Many thanks.\r\n`\r\nimport math\r\n\r\nimport numpy as np\r\nimport torch\r\nimport torch.nn as nn\r\nimport torch.nn.functional as F\r\n\r\nclass LocalCrossCorrelationWithSmoothnessLoss(nn.Module):\r\n    def __init__(self, shape, length, alpha, penalty):\r\n        super(LocalCrossCorrelationWithSmoothnessLoss, self).__init__()\r\n        ndims = len(shape) - 1\r\n        if not ndims in [1, 2, 3]:\r\n            raise AssertionError(\"volumes should be 1 to 3 dimensions. found: {}\".format(ndims))\r\n        win = [length] * ndims\r\n        sum_filt = torch.ones([1, shape[0], *win])\r\n        pad_no = math.floor(win[0] / 2)\r\n        \r\n        self.register_buffer(\"sum_filt\", sum_filt)\r\n        self.stride = [1] * ndims\r\n        self.padding = [pad_no] * ndims\r\n        self.win_size = np.prod(win)\r\n        self.epsilon = 1e-9\r\n        \r\n        self.alpha = alpha\r\n        self.penalty = penalty\r\n        \r\n    def forward(self, I: torch.Tensor, J: torch.Tensor, s: torch.Tensor):\r\n        I_var, J_var, cross = self.compute_local_sums(I, J)\r\n        cc = cross * cross / (I_var * J_var + self.epsilon)\r\n        \r\n        ncc_loss =  -1 * torch.mean(cc)\r\n        smoothness_loss = self.gradient_loss(s) * self.alpha\r\n        total_loss = ncc_loss + smoothness_loss\r\n        \r\n        return total_loss, ncc_loss, smoothness_loss\r\n           \r\n    def compute_local_sums(self, I: torch.Tensor, J: torch.Tensor):\r\n        filt = self.sum_filt\r\n        stride = self.stride\r\n        padding = self.padding\r\n        win_size = self.win_size\r\n        \r\n        I2, J2, IJ = I * I, J * J, I * J\r\n        I_sum = F.conv2d(I, filt, stride=stride, padding=padding)\r\n        J_sum = F.conv2d(J, filt, stride=stride, padding=padding)\r\n        I2_sum = F.conv2d(I2, filt, stride=stride, padding=padding)\r\n        J2_sum = F.conv2d(J2, filt, stride=stride, padding=padding)\r\n        IJ_sum = F.conv2d(IJ, filt, stride=stride, padding=padding)\r\n        u_I = I_sum / win_size\r\n        u_J = J_sum / win_size\r\n        cross = IJ_sum - u_J * I_sum - u_I * J_sum + u_I * u_J * win_size\r\n        I_var = I2_sum - 2 * u_I * I_sum + u_I * u_I * win_size\r\n        J_var = J2_sum - 2 * u_J * J_sum + u_J * u_J * win_size\r\n        return I_var, J_var, cross\r\n    \r\n    def gradient_loss(self, s):\r\n        dy = torch.abs(s[:, :, 1:, :] - s[:, :, :-1, :])\r\n        dx = torch.abs(s[:, :, :, 1:] - s[:, :, :, :-1])\r\n\r\n        if self.penalty == 'l2':\r\n            dy = dy * dy\r\n            dx = dx * dx\r\n\r\n        d = torch.mean(dx) + torch.mean(dy)\r\n        return d / 2.0\r\n`","closed_by":null,"reactions":{"url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/414/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/414/timeline","performed_via_github_app":null,"state_reason":null}