{"url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/313","repository_url":"https://api.github.com/repos/voxelmorph/voxelmorph","labels_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/313/labels{/name}","comments_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/313/comments","events_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/313/events","html_url":"https://github.com/voxelmorph/voxelmorph/issues/313","id":898591178,"node_id":"MDU6SXNzdWU4OTg1OTExNzg=","number":313,"title":"Modeling multi-channel NCC-based registration","user":{"login":"neel-dey","id":46202852,"node_id":"MDQ6VXNlcjQ2MjAyODUy","avatar_url":"https://avatars.githubusercontent.com/u/46202852?v=4","gravatar_id":"","url":"https://api.github.com/users/neel-dey","html_url":"https://github.com/neel-dey","followers_url":"https://api.github.com/users/neel-dey/followers","following_url":"https://api.github.com/users/neel-dey/following{/other_user}","gists_url":"https://api.github.com/users/neel-dey/gists{/gist_id}","starred_url":"https://api.github.com/users/neel-dey/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/neel-dey/subscriptions","organizations_url":"https://api.github.com/users/neel-dey/orgs","repos_url":"https://api.github.com/users/neel-dey/repos","events_url":"https://api.github.com/users/neel-dey/events{/privacy}","received_events_url":"https://api.github.com/users/neel-dey/received_events","type":"User","site_admin":false},"labels":[{"id":1347467145,"node_id":"MDU6TGFiZWwxMzQ3NDY3MTQ1","url":"https://api.github.com/repos/voxelmorph/voxelmorph/labels/voxelmorph","name":"voxelmorph","color":"1d76db","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2021-05-21T22:02:05Z","updated_at":"2021-05-24T02:20:26Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Hi Adrian & co.,\r\n\r\nFor multi-channel registration (eg, RGB image registration or 4D registration of subject A with T1 and T2 <---> subject B with T1 and T2), vxm implements 4D windows for local NCC (e.g., with window size [9, 9, 9, 2] for T1+T2).\r\n\r\nI wonder if this may be a problem when dealing with domain shifts (eg, scanner differences) in a heterogeneous dataset. Typically, 3D NCC handles this by standardizing local statistics and is mostly insensitive to domain shift. However, T1 and T2 intensities may not change with the same transformation and this impacts the statistics of the 4D window. \r\n\r\nIn practice, when training for multi-channel templates on a dataset with multiple centers, the NCC loss values had high variance and depended strongly on the center (which eventually lead to divergence). This effect goes away once I just used two separate 3D NCC terms for each modality (ANTs uses separate NCC terms as well). I imagine that if the batch size is high enough, this would not be an issue, but we're stuck with a low number for 3D MRI. :)\r\n\r\nHere's a minimal example demonstrating that 4D NCC is sensitive to domain shifts, whereas 3D NCC on each channel is relatively insensitive. The example uses [ICBM 2009a Nonlinear Asymmetric T1+T2](http://www.bic.mni.mcgill.ca/~vfonov/icbm/2009/mni_icbm152_nlin_asym_09a_nifti.zip) as image 1 and [NIH's pediatric template](http://www.bic.mni.mcgill.ca/~vfonov/nihpd/obj1/nihpd_asym_04.5-18.5_nifti.zip) as image 2.\r\n\r\n```python\r\nimport numpy as np\r\nimport SimpleITK as sitk\r\nimport tensorflow as tf\r\n\r\nfrom voxelmorph.tf.losses import NCC\r\n\r\nncc_object = NCC(win=[9, 9, 9], eps=1e-3)\r\n\r\n# -----------------------------------------------------------------------------\r\n# Utility functions\r\n\r\ndef load_images(fpath):\r\n    img = sitk.GetArrayFromImage(sitk.ReadImage(fpath))\r\n    return img\r\n\r\n\r\ndef stack_to_tf_tensor(arr1, arr2):\r\n    arr = np.stack((arr1, arr2), axis=-1)  # 4D concatenate T1 and T2\r\n    arr = arr[np.newaxis, ...]  # add batch axis\r\n    return tf.convert_to_tensor(arr)\r\n\r\n\r\ndef scale_shift_clamp(arr, scale, shift):\r\n    arr = scale*arr + shift  # linearly transform image intensities\r\n    return np.maximum(arr, 0)\r\n\r\n\r\ndef ch(tfarr, dim):\r\n    \"\"\"Extract a channel from a (bs, x, y, z, ch) array.\"\"\" \r\n    return tfarr[..., dim, tf.newaxis]\r\n\r\n\r\n# -----------------------------------------------------------------------------\r\n# Load images\r\n\r\n# Multimodal image 1:\r\nadult_t1 = load_images('./adult/mni_icbm152_t1_tal_nlin_asym_09a.nii')\r\nadult_t2 = load_images('./adult/mni_icbm152_t2_tal_nlin_asym_09a.nii')\r\n\r\nadult = stack_to_tf_tensor(adult_t1, adult_t2)\r\n\r\n# Multimodal image 2:\r\npediatric_t1 = load_images('./pediatric/nihpd_asym_04.5-18.5_t1w.nii')\r\npediatric_t2 = load_images('./pediatric/nihpd_asym_04.5-18.5_t2w.nii')\r\n\r\npediatric = stack_to_tf_tensor(pediatric_t1, pediatric_t2)\r\n\r\n# -----------------------------------------------------------------------------\r\n# Initial NCC\r\n\r\nprint('Original 4D NCC: {}'.format(ncc_object.loss(adult, pediatric)))\r\n\r\n\r\n# -----------------------------------------------------------------------------\r\n# Domain shift images\r\n\r\n# Simulate 3 different domains/scanner pairs with arbitrary transforms: \r\n# Adult images:\r\nadult_transform1 = stack_to_tf_tensor(\r\n    scale_shift_clamp(adult_t1, 0.5, 10), \r\n    scale_shift_clamp(adult_t2, 1.3, 47),\r\n)\r\nadult_transform2 = stack_to_tf_tensor(\r\n    scale_shift_clamp(adult_t1, 1.2, 16), \r\n    scale_shift_clamp(adult_t2, 0.4, 0),\r\n)\r\nadult_transform3 = stack_to_tf_tensor(\r\n    scale_shift_clamp(adult_t1, 1.0, 20), \r\n    scale_shift_clamp(adult_t2, 2.0, 60),\r\n)\r\n\r\n# Pediatric images:\r\npediatric_transform1 = stack_to_tf_tensor(\r\n    scale_shift_clamp(pediatric_t1, 0.9, 30), \r\n    scale_shift_clamp(pediatric_t2, 1.4, 3),\r\n)\r\npediatric_transform2 = stack_to_tf_tensor(\r\n    scale_shift_clamp(pediatric_t1, 2.0, 12), \r\n    scale_shift_clamp(pediatric_t2, 0.9, 0),\r\n)\r\npediatric_transform3 = stack_to_tf_tensor(\r\n    scale_shift_clamp(pediatric_t1, 0.8, 0), \r\n    scale_shift_clamp(pediatric_t2, 1.1, 0),\r\n)\r\n\r\n\r\n# -----------------------------------------------------------------------------\r\n# Calculate 4D NCC between original images with new domain shifts\r\n\r\nprint('4D NCC domain 1: {}'.format(\r\n    ncc_object.loss(adult_transform1, pediatric_transform1),\r\n))\r\nprint('4D NCC domain 2: {}'.format(\r\n    ncc_object.loss(adult_transform2, pediatric_transform2),\r\n))\r\nprint('4D NCC domain 3: {}'.format(\r\n    ncc_object.loss(adult_transform3, pediatric_transform3),\r\n))\r\n\r\n\r\n# -----------------------------------------------------------------------------\r\n# Calculate 3D NCC_T1 + NCC_T2 between original images with new domain shifts\r\n\r\nprint('Split 3D NCC: {}'.format(\r\n    0.5*ncc_object.loss(ch(adult_transform1, 0), ch(pediatric_transform1, 0))\r\n    + 0.5*ncc_object.loss(ch(adult_transform1, 1), ch(pediatric_transform1, 1)),\r\n))\r\nprint('Split 3D NCC: {}'.format(\r\n    0.5*ncc_object.loss(ch(adult_transform2, 0), ch(pediatric_transform2, 0))\r\n    + 0.5*ncc_object.loss(ch(adult_transform2, 1), ch(pediatric_transform2, 1)),\r\n))\r\nprint('Split 3D NCC: {}'.format(\r\n    0.5*ncc_object.loss(ch(adult_transform3, 0), ch(pediatric_transform3, 0))\r\n    + 0.5*ncc_object.loss(ch(adult_transform3, 1), ch(pediatric_transform3, 1)),\r\n))\r\n\r\n```\r\n\r\nThis yields output:\r\n```\r\nOriginal NCC: [-0.6175599]\r\n4D NCC domain 1: [-0.57820976]\r\n4D NCC domain 2: [-0.9330061]\r\n4D NCC domain 3: [-0.6425893]\r\nSplit 3D NCC domain 1: [-0.54893446]\r\nSplit 3D NCC domain 2: [-0.54617786]\r\nSplit 3D NCC domain 3: [-0.53752065]\r\n```\r\n\r\nDo you have any thoughts on this phenomenon and if 4D NCC would be better than split 3D NCC in other applications? \r\n\r\nThanks!","closed_by":null,"reactions":{"url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/313/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/313/timeline","performed_via_github_app":null,"state_reason":null}