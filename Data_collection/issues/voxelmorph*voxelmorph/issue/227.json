{"url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/227","repository_url":"https://api.github.com/repos/voxelmorph/voxelmorph","labels_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/227/labels{/name}","comments_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/227/comments","events_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/227/events","html_url":"https://github.com/voxelmorph/voxelmorph/issues/227","id":722066405,"node_id":"MDU6SXNzdWU3MjIwNjY0MDU=","number":227,"title":"NCC implement error (with test code)","user":{"login":"flealq","id":7707974,"node_id":"MDQ6VXNlcjc3MDc5NzQ=","avatar_url":"https://avatars.githubusercontent.com/u/7707974?v=4","gravatar_id":"","url":"https://api.github.com/users/flealq","html_url":"https://github.com/flealq","followers_url":"https://api.github.com/users/flealq/followers","following_url":"https://api.github.com/users/flealq/following{/other_user}","gists_url":"https://api.github.com/users/flealq/gists{/gist_id}","starred_url":"https://api.github.com/users/flealq/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/flealq/subscriptions","organizations_url":"https://api.github.com/users/flealq/orgs","repos_url":"https://api.github.com/users/flealq/repos","events_url":"https://api.github.com/users/flealq/events{/privacy}","received_events_url":"https://api.github.com/users/flealq/received_events","type":"User","site_admin":false},"labels":[{"id":1347467145,"node_id":"MDU6TGFiZWwxMzQ3NDY3MTQ1","url":"https://api.github.com/repos/voxelmorph/voxelmorph/labels/voxelmorph","name":"voxelmorph","color":"1d76db","default":false,"description":""}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2020-10-15T07:11:08Z","updated_at":"2022-06-09T01:18:54Z","closed_at":"2020-10-16T01:29:11Z","author_association":"NONE","active_lock_reason":null,"body":"@adalca sorry for bothering. but still rather confused by the ncc implementation.\r\ncurrent line 58-65 of voxelmorph/torch/losses.py are:\r\n\r\n        58 u_I = I_sum / win_size\r\n        59 u_J = J_sum / win_size\r\n        60 \r\n        61 cross = IJ_sum - u_J * I_sum - u_I * J_sum + u_I * u_J * win_size\r\n        62 I_var = I2_sum - 2 * u_I * I_sum + u_I * u_I * win_size\r\n        63 J_var = J2_sum - 2 * u_J * J_sum + u_J * u_J * win_size\r\n        64 \r\n        65 cc = cross * cross / (I_var * J_var + 1e-5)\r\n\r\n# 1. code may wrong\r\ntake [58, 59] into [61-63], we have:\r\ncross = IJ_sum - I_sum * J_sum / win_size \r\nI_var = I2_sum - I_sum * I_sum / win_size \r\nJ_var = J2_sum - J_sum * J_sum / win_size \r\n\r\nthis is unresonable even if we only take computation complexity into account. \r\nsuppose two image I and J, their local smoothed version is I_bar and J_bar\r\nthen current implementation is\r\n<a href=\"https://www.codecogs.com/eqnedit.php?latex=cc=\\frac{(\\overline{I\\cdot&space;J}-\\overline{I}\\cdot&space;\\overline{J})^{2}}{(\\overline{I^2}-\\overline{I}^2)\\cdot(\\overline{J^2}-\\overline{J}^2)&space;}&space;(1)\" target=\"_blank\"><img src=\"https://latex.codecogs.com/gif.latex?cc=\\frac{(\\overline{I\\cdot&space;J}-\\overline{I}\\cdot&space;\\overline{J})^{2}}{(\\overline{I^2}-\\overline{I}^2)\\cdot(\\overline{J^2}-\\overline{J}^2)&space;}&space;(1)\" title=\"cc=\\frac{(\\overline{I\\cdot J}-\\overline{I}\\cdot \\overline{J})^{2}}{(\\overline{I^2}-\\overline{I}^2)\\cdot(\\overline{J^2}-\\overline{J}^2) }       (1)\" /></a>\r\n**and (1) is definitely not the paper means to be.**\r\n\r\nnotice, i'd tested (1)'s result is equivalent to line [65], and of course faster.\r\nso i dont think this is a matter of efficiency.\r\n\r\n# 2 author may try to\r\ni think line [61] should be at least:\r\n61 cross = IJ_sum - u_J * I - u_I * J + u_I * u_J * win_size\r\nbut still, this cross need to conv filtered before the square step: \r\ncross = conv_fn(IJ_sum - u_J * I - u_I * J + u_I * u_J * win_size)\r\nsame questions for line 62 and 63.\r\n\r\n# 3 my code\r\nmy code is attached below.\r\nand because my code still do not work, i think better leave it to the author.\r\nthank you.\r\n\r\n# 4 test code\r\n```python\r\nimport torch\r\nimport torch.nn.functional as F\r\nfrom functools import partial\r\nimport numpy as np\r\nimport math\r\n\r\n# the original code, with little revise such as window size and return value\r\ndef original_loss(y_true, y_pred):\r\n    I = y_true\r\n    J = y_pred\r\n\r\n    # get dimension of volume\r\n    # assumes I, J are sized [batch_size, *vol_shape, nb_feats]\r\n    ndims = len(list(I.size())) - 2\r\n    assert ndims in [1, 2, 3], \"volumes should be 1 to 3 dimensions. found: %d\" % ndims\r\n\r\n    # set window size\r\n    win = [3] * ndims\r\n\r\n    # compute filters\r\n    sum_filt = torch.ones([1, 1, *win]).to(\"cuda\")\r\n\r\n    pad_no = math.floor(win[0] / 2)\r\n\r\n    if ndims == 1:\r\n        stride = (1)\r\n        padding = (pad_no)\r\n    elif ndims == 2:\r\n        stride = (1, 1)\r\n        padding = (pad_no, pad_no)\r\n    else:\r\n        stride = (1, 1, 1)\r\n        padding = (pad_no, pad_no, pad_no)\r\n\r\n    # get convolution function\r\n    conv_fn = getattr(F, 'conv%dd' % ndims)\r\n\r\n    # compute CC squares\r\n    I2 = I * I\r\n    J2 = J * J\r\n    IJ = I * J\r\n\r\n    I_sum = conv_fn(I, sum_filt, stride=stride, padding=padding)\r\n    J_sum = conv_fn(J, sum_filt, stride=stride, padding=padding)\r\n    I2_sum = conv_fn(I2, sum_filt, stride=stride, padding=padding)\r\n    J2_sum = conv_fn(J2, sum_filt, stride=stride, padding=padding)\r\n    IJ_sum = conv_fn(IJ, sum_filt, stride=stride, padding=padding)\r\n\r\n    win_size = np.prod(win)\r\n    u_I = I_sum / win_size\r\n    u_J = J_sum / win_size\r\n\r\n    cross = IJ_sum - u_J * I_sum - u_I * J_sum + u_I * u_J * win_size\r\n    I_var = I2_sum - 2 * u_I * I_sum + u_I * u_I * win_size\r\n    J_var = J2_sum - 2 * u_J * J_sum + u_J * u_J * win_size\r\n\r\n    cc = cross * cross / (I_var * J_var + 1e-10)\r\n\r\n    return cross.mean(), I_var.mean(), J_var.mean(), cc.mean()\r\n    # return -torch.mean(cc)\r\n\r\n\r\n# modify original code for simplicity\r\n# same result with tolerable error\r\ndef calc_cross_simple(I, J):\r\n    win = [3, 3]\r\n    sum_filt = torch.ones(1, 1, *win).cuda() / np.prod(win)\r\n    padding = [x // 2 for x in win]\r\n    conv_fn = partial(F.conv2d, weight=sum_filt, stride=1, padding=padding)\r\n\r\n    I2 = I * I\r\n    J2 = J * J\r\n    IJ = I * J\r\n\r\n    I_sum = conv_fn(I)\r\n    J_sum = conv_fn(J)\r\n    I2_sum = conv_fn(I2)\r\n    J2_sum = conv_fn(J2)\r\n    IJ_sum = conv_fn(IJ)\r\n\r\n    win_size = np.prod(win)\r\n\r\n    cross = IJ_sum - I_sum * J_sum # err 1e-8\r\n    I_var = I2_sum - I_sum * I_sum # err 1e-8\r\n    J_var = J2_sum - J_sum * J_sum # err 1e-8\r\n    cc = cross * cross / (I_var * J_var + 1e-10) # err 1e-8\r\n\r\n    return cross.mean() * win_size, I_var.mean() * win_size, J_var.mean() * win_size, cc.mean()\r\n\r\n\r\n# my implementation accroding to the paper\r\ndef calc_cross_my(I, J):\r\n    win = [3, 3]\r\n    win_size = np.prod(win)\r\n    sum_filt = torch.ones(1, 1, *win).cuda() / np.prod(win)\r\n    padding = [x // 2 for x in win]\r\n    conv_fn = partial(F.conv2d, weight=sum_filt, stride=1, padding=padding)\r\n\r\n    I_sum = conv_fn(I)\r\n    J_sum = conv_fn(J)\r\n\r\n    cross = conv_fn((I - I_sum) * (J - J_sum)) # totally different result\r\n    I_var = conv_fn((I - I_sum).pow(2))\r\n    J_var = conv_fn((J - J_sum).pow(2))\r\n    cc = cross * cross / (I_var * J_var + 1e-10) # err 1e-8\r\n\r\n    return cross.mean() * win_size, I_var.mean() * win_size, J_var.mean() * win_size, cc.mean()\r\n\r\n\r\n#maybe what the original code want to be?\r\ndef original_may_want_to(I, J):\r\n    win = [3, 3]\r\n    win_size = np.prod(win)\r\n    sum_filt = torch.ones(1, 1, *win).cuda() / np.prod(win)\r\n    padding = [x // 2 for x in win]\r\n    conv_fn = partial(F.conv2d, weight=sum_filt, stride=1, padding=padding)\r\n\r\n    I2 = I * I\r\n    J2 = J * J\r\n    IJ = I * J\r\n\r\n    I_sum = conv_fn(I)\r\n    J_sum = conv_fn(J)\r\n\r\n    cross = conv_fn(IJ - I_sum * J - I * J_sum + I_sum * J_sum)\r\n    I_var = conv_fn(I2 - 2 * I * I_sum + I_sum * I_sum)\r\n    J_var = conv_fn(J2 - 2 * J * J_sum + J_sum * J_sum)\r\n    cc = cross * cross / (I_var * J_var + 1e-10)\r\n\r\n    return cross.mean() * win_size, I_var.mean() * win_size, J_var.mean() * win_size, cc.mean()\r\n\r\n\r\ndef print_tensor_list(l):\r\n    print([x.detach().cpu().numpy().tolist() for x in l])\r\n\r\n\r\ndef check_ncc():\r\n    torch.torch.manual_seed(0)\r\n    for i in range(10):\r\n        print('test {}'.format(i))\r\n        I = torch.rand([1, 1, 10, 10]).cuda()\r\n        J = torch.rand([1, 1, 10, 10]).cuda()\r\n        # wrong\r\n        org = original_loss(I, J)\r\n        simple = calc_cross_simple(I, J)\r\n\r\n        # maybe right?\r\n        my = calc_cross_my(I, J)\r\n        org_rev = original_may_want_to(I, J)\r\n\r\n        print_tensor_list(org)\r\n        print_tensor_list(simple)\r\n        print_tensor_list(my)\r\n        print_tensor_list(org_rev)\r\n        debug = 1\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    check_ncc()\r\n``` ```\r\n","closed_by":{"login":"flealq","id":7707974,"node_id":"MDQ6VXNlcjc3MDc5NzQ=","avatar_url":"https://avatars.githubusercontent.com/u/7707974?v=4","gravatar_id":"","url":"https://api.github.com/users/flealq","html_url":"https://github.com/flealq","followers_url":"https://api.github.com/users/flealq/followers","following_url":"https://api.github.com/users/flealq/following{/other_user}","gists_url":"https://api.github.com/users/flealq/gists{/gist_id}","starred_url":"https://api.github.com/users/flealq/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/flealq/subscriptions","organizations_url":"https://api.github.com/users/flealq/orgs","repos_url":"https://api.github.com/users/flealq/repos","events_url":"https://api.github.com/users/flealq/events{/privacy}","received_events_url":"https://api.github.com/users/flealq/received_events","type":"User","site_admin":false},"reactions":{"url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/227/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/voxelmorph/voxelmorph/issues/227/timeline","performed_via_github_app":null,"state_reason":"completed"}